// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// AddEvaluationsParams is parameters of addEvaluations operation.
type AddEvaluationsParams struct {
	ContentEncoding OptNilString `json:",omitempty,omitzero"`
}

func unpackAddEvaluationsParams(packed middleware.Parameters) (params AddEvaluationsParams) {
	{
		key := middleware.ParameterKey{
			Name: "content-encoding",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.ContentEncoding = v.(OptNilString)
		}
	}
	return params
}

func decodeAddEvaluationsParams(args [0]string, argsEscaped bool, r *http.Request) (params AddEvaluationsParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: content-encoding.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "content-encoding",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentEncodingVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentEncodingVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ContentEncoding.SetTo(paramsDotContentEncodingVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "content-encoding",
			In:   "header",
			Err:  err,
		}
	}
	return params, nil
}

// AnnotateSessionsParams is parameters of annotateSessions operation.
type AnnotateSessionsParams struct {
	// If true, fulfill request synchronously.
	Sync OptBool `json:",omitempty,omitzero"`
}

func unpackAnnotateSessionsParams(packed middleware.Parameters) (params AnnotateSessionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "sync",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sync = v.(OptBool)
		}
	}
	return params
}

func decodeAnnotateSessionsParams(args [0]string, argsEscaped bool, r *http.Request) (params AnnotateSessionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: sync.
	{
		val := bool(false)
		params.Sync.SetTo(val)
	}
	// Decode query: sync.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sync",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSyncVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotSyncVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sync.SetTo(paramsDotSyncVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sync",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// AnnotateSpanDocumentsParams is parameters of annotateSpanDocuments operation.
type AnnotateSpanDocumentsParams struct {
	// If set to true, the annotations are inserted synchronously.
	Sync OptBool `json:",omitempty,omitzero"`
}

func unpackAnnotateSpanDocumentsParams(packed middleware.Parameters) (params AnnotateSpanDocumentsParams) {
	{
		key := middleware.ParameterKey{
			Name: "sync",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sync = v.(OptBool)
		}
	}
	return params
}

func decodeAnnotateSpanDocumentsParams(args [0]string, argsEscaped bool, r *http.Request) (params AnnotateSpanDocumentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: sync.
	{
		val := bool(false)
		params.Sync.SetTo(val)
	}
	// Decode query: sync.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sync",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSyncVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotSyncVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sync.SetTo(paramsDotSyncVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sync",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// AnnotateSpansParams is parameters of annotateSpans operation.
type AnnotateSpansParams struct {
	// If true, fulfill request synchronously.
	Sync OptBool `json:",omitempty,omitzero"`
}

func unpackAnnotateSpansParams(packed middleware.Parameters) (params AnnotateSpansParams) {
	{
		key := middleware.ParameterKey{
			Name: "sync",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sync = v.(OptBool)
		}
	}
	return params
}

func decodeAnnotateSpansParams(args [0]string, argsEscaped bool, r *http.Request) (params AnnotateSpansParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: sync.
	{
		val := bool(false)
		params.Sync.SetTo(val)
	}
	// Decode query: sync.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sync",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSyncVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotSyncVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sync.SetTo(paramsDotSyncVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sync",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// AnnotateTracesParams is parameters of annotateTraces operation.
type AnnotateTracesParams struct {
	// If true, fulfill request synchronously.
	Sync OptBool `json:",omitempty,omitzero"`
}

func unpackAnnotateTracesParams(packed middleware.Parameters) (params AnnotateTracesParams) {
	{
		key := middleware.ParameterKey{
			Name: "sync",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sync = v.(OptBool)
		}
	}
	return params
}

func decodeAnnotateTracesParams(args [0]string, argsEscaped bool, r *http.Request) (params AnnotateTracesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: sync.
	{
		val := bool(false)
		params.Sync.SetTo(val)
	}
	// Decode query: sync.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sync",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSyncVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotSyncVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sync.SetTo(paramsDotSyncVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sync",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// CreateExperimentParams is parameters of createExperiment operation.
type CreateExperimentParams struct {
	DatasetID string
}

func unpackCreateExperimentParams(packed middleware.Parameters) (params CreateExperimentParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataset_id",
			In:   "path",
		}
		params.DatasetID = packed[key].(string)
	}
	return params
}

func decodeCreateExperimentParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateExperimentParams, _ error) {
	// Decode path: dataset_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dataset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DatasetID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataset_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CreateExperimentRunParams is parameters of createExperimentRun operation.
type CreateExperimentRunParams struct {
	ExperimentID string
}

func unpackCreateExperimentRunParams(packed middleware.Parameters) (params CreateExperimentRunParams) {
	{
		key := middleware.ParameterKey{
			Name: "experiment_id",
			In:   "path",
		}
		params.ExperimentID = packed[key].(string)
	}
	return params
}

func decodeCreateExperimentRunParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateExperimentRunParams, _ error) {
	// Decode path: experiment_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "experiment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ExperimentID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "experiment_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CreatePromptVersionTagParams is parameters of createPromptVersionTag operation.
type CreatePromptVersionTagParams struct {
	// The ID of the prompt version.
	PromptVersionID string
}

func unpackCreatePromptVersionTagParams(packed middleware.Parameters) (params CreatePromptVersionTagParams) {
	{
		key := middleware.ParameterKey{
			Name: "prompt_version_id",
			In:   "path",
		}
		params.PromptVersionID = packed[key].(string)
	}
	return params
}

func decodeCreatePromptVersionTagParams(args [1]string, argsEscaped bool, r *http.Request) (params CreatePromptVersionTagParams, _ error) {
	// Decode path: prompt_version_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "prompt_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PromptVersionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "prompt_version_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CreateSpansParams is parameters of createSpans operation.
type CreateSpansParams struct {
	// The project identifier: either project ID or project name. If using a project name, it cannot
	// contain slash (/), question mark (?), or pound sign (#) characters.
	ProjectIdentifier string
}

func unpackCreateSpansParams(packed middleware.Parameters) (params CreateSpansParams) {
	{
		key := middleware.ParameterKey{
			Name: "project_identifier",
			In:   "path",
		}
		params.ProjectIdentifier = packed[key].(string)
	}
	return params
}

func decodeCreateSpansParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateSpansParams, _ error) {
	// Decode path: project_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProjectIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "project_identifier",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteParams is parameters of delete_annotation_config_v1_annotation_configs__config_id__delete operation.
type DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteParams struct {
	// ID of the annotation configuration.
	ConfigID string
}

func unpackDeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteParams(packed middleware.Parameters) (params DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteParams) {
	{
		key := middleware.ParameterKey{
			Name: "config_id",
			In:   "path",
		}
		params.ConfigID = packed[key].(string)
	}
	return params
}

func decodeDeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteParams, _ error) {
	// Decode path: config_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "config_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ConfigID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "config_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteDatasetByIdParams is parameters of deleteDatasetById operation.
type DeleteDatasetByIdParams struct {
	// The ID of the dataset to delete.
	ID string
}

func unpackDeleteDatasetByIdParams(packed middleware.Parameters) (params DeleteDatasetByIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteDatasetByIdParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteDatasetByIdParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteExperimentParams is parameters of deleteExperiment operation.
type DeleteExperimentParams struct {
	ExperimentID string
}

func unpackDeleteExperimentParams(packed middleware.Parameters) (params DeleteExperimentParams) {
	{
		key := middleware.ParameterKey{
			Name: "experiment_id",
			In:   "path",
		}
		params.ExperimentID = packed[key].(string)
	}
	return params
}

func decodeDeleteExperimentParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteExperimentParams, _ error) {
	// Decode path: experiment_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "experiment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ExperimentID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "experiment_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteProjectParams is parameters of deleteProject operation.
type DeleteProjectParams struct {
	// The project identifier: either project ID or project name. If using a project name, it cannot
	// contain slash (/), question mark (?), or pound sign (#) characters.
	ProjectIdentifier string
}

func unpackDeleteProjectParams(packed middleware.Parameters) (params DeleteProjectParams) {
	{
		key := middleware.ParameterKey{
			Name: "project_identifier",
			In:   "path",
		}
		params.ProjectIdentifier = packed[key].(string)
	}
	return params
}

func decodeDeleteProjectParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteProjectParams, _ error) {
	// Decode path: project_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProjectIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "project_identifier",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteSpanParams is parameters of deleteSpan operation.
type DeleteSpanParams struct {
	// The span identifier: either a relay GlobalID or OpenTelemetry span_id.
	SpanIdentifier string
}

func unpackDeleteSpanParams(packed middleware.Parameters) (params DeleteSpanParams) {
	{
		key := middleware.ParameterKey{
			Name: "span_identifier",
			In:   "path",
		}
		params.SpanIdentifier = packed[key].(string)
	}
	return params
}

func decodeDeleteSpanParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteSpanParams, _ error) {
	// Decode path: span_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "span_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpanIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "span_identifier",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteTraceParams is parameters of deleteTrace operation.
type DeleteTraceParams struct {
	// The trace identifier: either a relay GlobalID or OpenTelemetry trace_id.
	TraceIdentifier string
}

func unpackDeleteTraceParams(packed middleware.Parameters) (params DeleteTraceParams) {
	{
		key := middleware.ParameterKey{
			Name: "trace_identifier",
			In:   "path",
		}
		params.TraceIdentifier = packed[key].(string)
	}
	return params
}

func decodeDeleteTraceParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteTraceParams, _ error) {
	// Decode path: trace_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "trace_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TraceIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "trace_identifier",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteUserParams is parameters of deleteUser operation.
type DeleteUserParams struct {
	// The GlobalID of the user (e.g. 'VXNlcjox').
	UserID string
}

func unpackDeleteUserParams(packed middleware.Parameters) (params DeleteUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "user_id",
			In:   "path",
		}
		params.UserID = packed[key].(string)
	}
	return params
}

func decodeDeleteUserParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteUserParams, _ error) {
	// Decode path: user_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "user_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetParams is parameters of get_annotation_config_by_name_or_id_v1_annotation_configs__config_identifier__get operation.
type GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetParams struct {
	// ID or name of the annotation configuration.
	ConfigIdentifier string
}

func unpackGetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetParams(packed middleware.Parameters) (params GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "config_identifier",
			In:   "path",
		}
		params.ConfigIdentifier = packed[key].(string)
	}
	return params
}

func decodeGetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetParams, _ error) {
	// Decode path: config_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "config_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ConfigIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "config_identifier",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatasetParams is parameters of getDataset operation.
type GetDatasetParams struct {
	// The ID of the dataset.
	ID string
}

func unpackGetDatasetParams(packed middleware.Parameters) (params GetDatasetParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetDatasetParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDatasetParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatasetCsvParams is parameters of getDatasetCsv operation.
type GetDatasetCsvParams struct {
	// The ID of the dataset.
	ID string
	// The ID of the dataset version (if omitted, returns data from the latest version).
	VersionID OptNilString `json:",omitempty,omitzero"`
}

func unpackGetDatasetCsvParams(packed middleware.Parameters) (params GetDatasetCsvParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "version_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VersionID = v.(OptNilString)
		}
	}
	return params
}

func decodeGetDatasetCsvParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDatasetCsvParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: version_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "version_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVersionIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVersionIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VersionID.SetTo(paramsDotVersionIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "version_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatasetExamplesParams is parameters of getDatasetExamples operation.
type GetDatasetExamplesParams struct {
	// The ID of the dataset.
	ID string
	// The ID of the dataset version (if omitted, returns data from the latest version).
	VersionID OptNilString `json:",omitempty,omitzero"`
	// List of dataset split identifiers (GlobalIDs or names) to filter by.
	Split OptNilStringArray `json:",omitempty,omitzero"`
}

func unpackGetDatasetExamplesParams(packed middleware.Parameters) (params GetDatasetExamplesParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "version_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VersionID = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "split",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Split = v.(OptNilStringArray)
		}
	}
	return params
}

func decodeGetDatasetExamplesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDatasetExamplesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: version_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "version_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVersionIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVersionIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VersionID.SetTo(paramsDotVersionIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "version_id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: split.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "split",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSplitVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotSplitValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotSplitValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotSplitVal = append(paramsDotSplitVal, paramsDotSplitValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.Split.SetTo(paramsDotSplitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Split.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "split",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatasetJSONLOpenAIEvalsParams is parameters of getDatasetJSONLOpenAIEvals operation.
type GetDatasetJSONLOpenAIEvalsParams struct {
	// The ID of the dataset.
	ID string
	// The ID of the dataset version (if omitted, returns data from the latest version).
	VersionID OptNilString `json:",omitempty,omitzero"`
}

func unpackGetDatasetJSONLOpenAIEvalsParams(packed middleware.Parameters) (params GetDatasetJSONLOpenAIEvalsParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "version_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VersionID = v.(OptNilString)
		}
	}
	return params
}

func decodeGetDatasetJSONLOpenAIEvalsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDatasetJSONLOpenAIEvalsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: version_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "version_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVersionIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVersionIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VersionID.SetTo(paramsDotVersionIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "version_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatasetJSONLOpenAIFineTuningParams is parameters of getDatasetJSONLOpenAIFineTuning operation.
type GetDatasetJSONLOpenAIFineTuningParams struct {
	// The ID of the dataset.
	ID string
	// The ID of the dataset version (if omitted, returns data from the latest version).
	VersionID OptNilString `json:",omitempty,omitzero"`
}

func unpackGetDatasetJSONLOpenAIFineTuningParams(packed middleware.Parameters) (params GetDatasetJSONLOpenAIFineTuningParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "version_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VersionID = v.(OptNilString)
		}
	}
	return params
}

func decodeGetDatasetJSONLOpenAIFineTuningParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDatasetJSONLOpenAIFineTuningParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: version_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "version_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVersionIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVersionIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VersionID.SetTo(paramsDotVersionIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "version_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetEvaluationsParams is parameters of getEvaluations operation.
type GetEvaluationsParams struct {
	// The name of the project to get evaluations from (if omitted, evaluations will be drawn from the
	// `default` project).
	ProjectName OptNilString `json:",omitempty,omitzero"`
}

func unpackGetEvaluationsParams(packed middleware.Parameters) (params GetEvaluationsParams) {
	{
		key := middleware.ParameterKey{
			Name: "project_name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProjectName = v.(OptNilString)
		}
	}
	return params
}

func decodeGetEvaluationsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetEvaluationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: project_name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "project_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProjectNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProjectNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ProjectName.SetTo(paramsDotProjectNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "project_name",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetExperimentParams is parameters of getExperiment operation.
type GetExperimentParams struct {
	ExperimentID string
}

func unpackGetExperimentParams(packed middleware.Parameters) (params GetExperimentParams) {
	{
		key := middleware.ParameterKey{
			Name: "experiment_id",
			In:   "path",
		}
		params.ExperimentID = packed[key].(string)
	}
	return params
}

func decodeGetExperimentParams(args [1]string, argsEscaped bool, r *http.Request) (params GetExperimentParams, _ error) {
	// Decode path: experiment_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "experiment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ExperimentID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "experiment_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetExperimentCSVParams is parameters of getExperimentCSV operation.
type GetExperimentCSVParams struct {
	ExperimentID string
}

func unpackGetExperimentCSVParams(packed middleware.Parameters) (params GetExperimentCSVParams) {
	{
		key := middleware.ParameterKey{
			Name: "experiment_id",
			In:   "path",
		}
		params.ExperimentID = packed[key].(string)
	}
	return params
}

func decodeGetExperimentCSVParams(args [1]string, argsEscaped bool, r *http.Request) (params GetExperimentCSVParams, _ error) {
	// Decode path: experiment_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "experiment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ExperimentID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "experiment_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetExperimentJSONParams is parameters of getExperimentJSON operation.
type GetExperimentJSONParams struct {
	ExperimentID string
}

func unpackGetExperimentJSONParams(packed middleware.Parameters) (params GetExperimentJSONParams) {
	{
		key := middleware.ParameterKey{
			Name: "experiment_id",
			In:   "path",
		}
		params.ExperimentID = packed[key].(string)
	}
	return params
}

func decodeGetExperimentJSONParams(args [1]string, argsEscaped bool, r *http.Request) (params GetExperimentJSONParams, _ error) {
	// Decode path: experiment_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "experiment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ExperimentID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "experiment_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetIncompleteExperimentEvaluationsParams is parameters of getIncompleteExperimentEvaluations operation.
type GetIncompleteExperimentEvaluationsParams struct {
	ExperimentID string
	// Evaluation names to check.
	EvaluationName []string `json:",omitempty"`
	// Cursor for pagination.
	Cursor OptNilString `json:",omitempty,omitzero"`
	// Maximum number of runs with incomplete evaluations to return.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackGetIncompleteExperimentEvaluationsParams(packed middleware.Parameters) (params GetIncompleteExperimentEvaluationsParams) {
	{
		key := middleware.ParameterKey{
			Name: "experiment_id",
			In:   "path",
		}
		params.ExperimentID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "evaluation_name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EvaluationName = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeGetIncompleteExperimentEvaluationsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetIncompleteExperimentEvaluationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: experiment_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "experiment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ExperimentID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "experiment_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: evaluation_name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "evaluation_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotEvaluationNameVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotEvaluationNameVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.EvaluationName = append(params.EvaluationName, paramsDotEvaluationNameVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "evaluation_name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(50)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetIncompleteExperimentRunsParams is parameters of getIncompleteExperimentRuns operation.
type GetIncompleteExperimentRunsParams struct {
	ExperimentID string
	// Cursor for pagination.
	Cursor OptNilString `json:",omitempty,omitzero"`
	// Maximum number of examples with incomplete runs to return.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackGetIncompleteExperimentRunsParams(packed middleware.Parameters) (params GetIncompleteExperimentRunsParams) {
	{
		key := middleware.ParameterKey{
			Name: "experiment_id",
			In:   "path",
		}
		params.ExperimentID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeGetIncompleteExperimentRunsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetIncompleteExperimentRunsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: experiment_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "experiment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ExperimentID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "experiment_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(50)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetProjectParams is parameters of getProject operation.
type GetProjectParams struct {
	// The project identifier: either project ID or project name. If using a project name, it cannot
	// contain slash (/), question mark (?), or pound sign (#) characters.
	ProjectIdentifier string
}

func unpackGetProjectParams(packed middleware.Parameters) (params GetProjectParams) {
	{
		key := middleware.ParameterKey{
			Name: "project_identifier",
			In:   "path",
		}
		params.ProjectIdentifier = packed[key].(string)
	}
	return params
}

func decodeGetProjectParams(args [1]string, argsEscaped bool, r *http.Request) (params GetProjectParams, _ error) {
	// Decode path: project_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProjectIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "project_identifier",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetProjectsParams is parameters of getProjects operation.
type GetProjectsParams struct {
	// Cursor for pagination (project ID).
	Cursor OptNilString `json:",omitempty,omitzero"`
	// The max number of projects to return at a time.
	Limit OptInt `json:",omitempty,omitzero"`
	// Include experiment projects in the response. Experiment projects are created from running
	// experiments.
	IncludeExperimentProjects OptBool `json:",omitempty,omitzero"`
}

func unpackGetProjectsParams(packed middleware.Parameters) (params GetProjectsParams) {
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "include_experiment_projects",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludeExperimentProjects = v.(OptBool)
		}
	}
	return params
}

func decodeGetProjectsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetProjectsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: include_experiment_projects.
	{
		val := bool(false)
		params.IncludeExperimentProjects.SetTo(val)
	}
	// Decode query: include_experiment_projects.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include_experiment_projects",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeExperimentProjectsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIncludeExperimentProjectsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IncludeExperimentProjects.SetTo(paramsDotIncludeExperimentProjectsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "include_experiment_projects",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetPromptVersionByPromptVersionIdParams is parameters of getPromptVersionByPromptVersionId operation.
type GetPromptVersionByPromptVersionIdParams struct {
	// The ID of the prompt version.
	PromptVersionID string
}

func unpackGetPromptVersionByPromptVersionIdParams(packed middleware.Parameters) (params GetPromptVersionByPromptVersionIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "prompt_version_id",
			In:   "path",
		}
		params.PromptVersionID = packed[key].(string)
	}
	return params
}

func decodeGetPromptVersionByPromptVersionIdParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPromptVersionByPromptVersionIdParams, _ error) {
	// Decode path: prompt_version_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "prompt_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PromptVersionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "prompt_version_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetPromptVersionByTagNameParams is parameters of getPromptVersionByTagName operation.
type GetPromptVersionByTagNameParams struct {
	// The identifier of the prompt, i.e. name or ID.
	PromptIdentifier string
	// The tag of the prompt version.
	TagName string
}

func unpackGetPromptVersionByTagNameParams(packed middleware.Parameters) (params GetPromptVersionByTagNameParams) {
	{
		key := middleware.ParameterKey{
			Name: "prompt_identifier",
			In:   "path",
		}
		params.PromptIdentifier = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "tag_name",
			In:   "path",
		}
		params.TagName = packed[key].(string)
	}
	return params
}

func decodeGetPromptVersionByTagNameParams(args [2]string, argsEscaped bool, r *http.Request) (params GetPromptVersionByTagNameParams, _ error) {
	// Decode path: prompt_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "prompt_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PromptIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "prompt_identifier",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tag_name.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TagName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tag_name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetPromptVersionLatestParams is parameters of getPromptVersionLatest operation.
type GetPromptVersionLatestParams struct {
	// The identifier of the prompt, i.e. name or ID.
	PromptIdentifier string
}

func unpackGetPromptVersionLatestParams(packed middleware.Parameters) (params GetPromptVersionLatestParams) {
	{
		key := middleware.ParameterKey{
			Name: "prompt_identifier",
			In:   "path",
		}
		params.PromptIdentifier = packed[key].(string)
	}
	return params
}

func decodeGetPromptVersionLatestParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPromptVersionLatestParams, _ error) {
	// Decode path: prompt_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "prompt_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PromptIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "prompt_identifier",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetPromptVersionTagsParams is parameters of getPromptVersionTags operation.
type GetPromptVersionTagsParams struct {
	// The ID of the prompt version.
	PromptVersionID string
	// Cursor for pagination (base64-encoded promptVersionTag ID).
	Cursor OptNilString `json:",omitempty,omitzero"`
	// The max number of tags to return at a time.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackGetPromptVersionTagsParams(packed middleware.Parameters) (params GetPromptVersionTagsParams) {
	{
		key := middleware.ParameterKey{
			Name: "prompt_version_id",
			In:   "path",
		}
		params.PromptVersionID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeGetPromptVersionTagsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPromptVersionTagsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: prompt_version_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "prompt_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PromptVersionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "prompt_version_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetPromptsParams is parameters of getPrompts operation.
type GetPromptsParams struct {
	// Cursor for pagination (base64-encoded prompt ID).
	Cursor OptNilString `json:",omitempty,omitzero"`
	// The max number of prompts to return at a time.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackGetPromptsParams(packed middleware.Parameters) (params GetPromptsParams) {
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeGetPromptsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetPromptsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetSpansParams is parameters of getSpans operation.
type GetSpansParams struct {
	// The project identifier: either project ID or project name. If using a project name, it cannot
	// contain slash (/), question mark (?), or pound sign (#) characters.
	ProjectIdentifier string
	// Pagination cursor (Span Global ID).
	Cursor OptNilString `json:",omitempty,omitzero"`
	// Maximum number of spans to return.
	Limit OptInt `json:",omitempty,omitzero"`
	// Inclusive lower bound time.
	StartTime OptNilDateTime `json:",omitempty,omitzero"`
	// Exclusive upper bound time.
	EndTime OptNilDateTime `json:",omitempty,omitzero"`
}

func unpackGetSpansParams(packed middleware.Parameters) (params GetSpansParams) {
	{
		key := middleware.ParameterKey{
			Name: "project_identifier",
			In:   "path",
		}
		params.ProjectIdentifier = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "start_time",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTime = v.(OptNilDateTime)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_time",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndTime = v.(OptNilDateTime)
		}
	}
	return params
}

func decodeGetSpansParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSpansParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: project_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProjectIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "project_identifier",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start_time.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimeVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotStartTimeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTime.SetTo(paramsDotStartTimeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_time",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end_time.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndTimeVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotEndTimeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndTime.SetTo(paramsDotEndTimeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_time",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetUsersParams is parameters of getUsers operation.
type GetUsersParams struct {
	// Cursor for pagination (base64-encoded user ID).
	Cursor OptString `json:",omitempty,omitzero"`
	// The max number of users to return at a time.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackGetUsersParams(packed middleware.Parameters) (params GetUsersParams) {
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeGetUsersParams(args [0]string, argsEscaped bool, r *http.Request) (params GetUsersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListAnnotationConfigsV1AnnotationConfigsGetParams is parameters of list_annotation_configs_v1_annotation_configs_get operation.
type ListAnnotationConfigsV1AnnotationConfigsGetParams struct {
	// Cursor for pagination (base64-encoded annotation config ID).
	Cursor OptNilString `json:",omitempty,omitzero"`
	// Maximum number of configs to return.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackListAnnotationConfigsV1AnnotationConfigsGetParams(packed middleware.Parameters) (params ListAnnotationConfigsV1AnnotationConfigsGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeListAnnotationConfigsV1AnnotationConfigsGetParams(args [0]string, argsEscaped bool, r *http.Request) (params ListAnnotationConfigsV1AnnotationConfigsGetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListDatasetVersionsByDatasetIdParams is parameters of listDatasetVersionsByDatasetId operation.
type ListDatasetVersionsByDatasetIdParams struct {
	// The ID of the dataset.
	ID string
	// Cursor for pagination.
	Cursor OptNilString `json:",omitempty,omitzero"`
	// The max number of dataset versions to return at a time.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackListDatasetVersionsByDatasetIdParams(packed middleware.Parameters) (params ListDatasetVersionsByDatasetIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeListDatasetVersionsByDatasetIdParams(args [1]string, argsEscaped bool, r *http.Request) (params ListDatasetVersionsByDatasetIdParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(10)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListDatasetsParams is parameters of listDatasets operation.
type ListDatasetsParams struct {
	// Cursor for pagination.
	Cursor OptNilString `json:",omitempty,omitzero"`
	// An optional dataset name to filter by.
	Name OptNilString `json:",omitempty,omitzero"`
	// The max number of datasets to return at a time.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackListDatasetsParams(packed middleware.Parameters) (params ListDatasetsParams) {
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeListDatasetsParams(args [0]string, argsEscaped bool, r *http.Request) (params ListDatasetsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(10)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListExperimentRunsParams is parameters of listExperimentRuns operation.
type ListExperimentRunsParams struct {
	ExperimentID string
	// Cursor for pagination (base64-encoded experiment run ID).
	Cursor OptNilString `json:",omitempty,omitzero"`
	// The max number of experiment runs to return at a time. If not specified, returns all results.
	Limit OptNilInt `json:",omitempty,omitzero"`
}

func unpackListExperimentRunsParams(packed middleware.Parameters) (params ListExperimentRunsParams) {
	{
		key := middleware.ParameterKey{
			Name: "experiment_id",
			In:   "path",
		}
		params.ExperimentID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptNilInt)
		}
	}
	return params
}

func decodeListExperimentRunsParams(args [1]string, argsEscaped bool, r *http.Request) (params ListExperimentRunsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: experiment_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "experiment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ExperimentID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "experiment_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListExperimentsParams is parameters of listExperiments operation.
type ListExperimentsParams struct {
	DatasetID string
	// Cursor for pagination (base64-encoded experiment ID).
	Cursor OptNilString `json:",omitempty,omitzero"`
	// The max number of experiments to return at a time.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackListExperimentsParams(packed middleware.Parameters) (params ListExperimentsParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataset_id",
			In:   "path",
		}
		params.DatasetID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeListExperimentsParams(args [1]string, argsEscaped bool, r *http.Request) (params ListExperimentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: dataset_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dataset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DatasetID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataset_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(50)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListPromptVersionsParams is parameters of listPromptVersions operation.
type ListPromptVersionsParams struct {
	// The identifier of the prompt, i.e. name or ID.
	PromptIdentifier string
	// Cursor for pagination (base64-encoded promptVersion ID).
	Cursor OptNilString `json:",omitempty,omitzero"`
	// The max number of prompt versions to return at a time.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackListPromptVersionsParams(packed middleware.Parameters) (params ListPromptVersionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "prompt_identifier",
			In:   "path",
		}
		params.PromptIdentifier = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeListPromptVersionsParams(args [1]string, argsEscaped bool, r *http.Request) (params ListPromptVersionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: prompt_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "prompt_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PromptIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "prompt_identifier",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListSessionAnnotationsBySessionIdsParams is parameters of listSessionAnnotationsBySessionIds operation.
type ListSessionAnnotationsBySessionIdsParams struct {
	// The project identifier: either project ID or project name. If using a project name as the
	// identifier, it cannot contain slash (/), question mark (?), or pound sign (#) characters.
	ProjectIdentifier string
	// One or more session id to fetch annotations for.
	SessionIds []string `json:",omitempty"`
	// Optional list of annotation names to include. If provided, only annotations with these names will
	// be returned. 'note' annotations are excluded by default unless explicitly included in this list.
	IncludeAnnotationNames OptNilStringArray `json:",omitempty,omitzero"`
	// Optional list of annotation names to exclude from results.
	ExcludeAnnotationNames OptNilStringArray `json:",omitempty,omitzero"`
	// A cursor for pagination.
	Cursor OptNilString `json:",omitempty,omitzero"`
	// The maximum number of annotations to return in a single request.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackListSessionAnnotationsBySessionIdsParams(packed middleware.Parameters) (params ListSessionAnnotationsBySessionIdsParams) {
	{
		key := middleware.ParameterKey{
			Name: "project_identifier",
			In:   "path",
		}
		params.ProjectIdentifier = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "session_ids",
			In:   "query",
		}
		params.SessionIds = packed[key].([]string)
	}
	{
		key := middleware.ParameterKey{
			Name: "include_annotation_names",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludeAnnotationNames = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "exclude_annotation_names",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ExcludeAnnotationNames = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeListSessionAnnotationsBySessionIdsParams(args [1]string, argsEscaped bool, r *http.Request) (params ListSessionAnnotationsBySessionIdsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: project_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProjectIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "project_identifier",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: session_ids.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "session_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotSessionIdsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotSessionIdsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.SessionIds = append(params.SessionIds, paramsDotSessionIdsVal)
					return nil
				})
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.SessionIds == nil {
					return errors.New("nil is invalid value")
				}
				if err := (validate.Array{
					MinLength:    1,
					MinLengthSet: true,
					MaxLength:    0,
					MaxLengthSet: false,
				}).ValidateLength(len(params.SessionIds)); err != nil {
					return errors.Wrap(err, "array")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "session_ids",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: include_annotation_names.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeAnnotationNamesVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotIncludeAnnotationNamesValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotIncludeAnnotationNamesValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotIncludeAnnotationNamesVal = append(paramsDotIncludeAnnotationNamesVal, paramsDotIncludeAnnotationNamesValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.IncludeAnnotationNames.SetTo(paramsDotIncludeAnnotationNamesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.IncludeAnnotationNames.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "include_annotation_names",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: exclude_annotation_names.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exclude_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotExcludeAnnotationNamesVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotExcludeAnnotationNamesValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotExcludeAnnotationNamesValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotExcludeAnnotationNamesVal = append(paramsDotExcludeAnnotationNamesVal, paramsDotExcludeAnnotationNamesValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.ExcludeAnnotationNames.SetTo(paramsDotExcludeAnnotationNamesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.ExcludeAnnotationNames.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "exclude_annotation_names",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(10)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           10000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListSpanAnnotationsBySpanIdsParams is parameters of listSpanAnnotationsBySpanIds operation.
type ListSpanAnnotationsBySpanIdsParams struct {
	// The project identifier: either project ID or project name. If using a project name as the
	// identifier, it cannot contain slash (/), question mark (?), or pound sign (#) characters.
	ProjectIdentifier string
	// One or more span id to fetch annotations for.
	SpanIds []string `json:",omitempty"`
	// Optional list of annotation names to include. If provided, only annotations with these names will
	// be returned. 'note' annotations are excluded by default unless explicitly included in this list.
	IncludeAnnotationNames OptNilStringArray `json:",omitempty,omitzero"`
	// Optional list of annotation names to exclude from results.
	ExcludeAnnotationNames OptNilStringArray `json:",omitempty,omitzero"`
	// A cursor for pagination.
	Cursor OptNilString `json:",omitempty,omitzero"`
	// The maximum number of annotations to return in a single request.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackListSpanAnnotationsBySpanIdsParams(packed middleware.Parameters) (params ListSpanAnnotationsBySpanIdsParams) {
	{
		key := middleware.ParameterKey{
			Name: "project_identifier",
			In:   "path",
		}
		params.ProjectIdentifier = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "span_ids",
			In:   "query",
		}
		params.SpanIds = packed[key].([]string)
	}
	{
		key := middleware.ParameterKey{
			Name: "include_annotation_names",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludeAnnotationNames = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "exclude_annotation_names",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ExcludeAnnotationNames = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeListSpanAnnotationsBySpanIdsParams(args [1]string, argsEscaped bool, r *http.Request) (params ListSpanAnnotationsBySpanIdsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: project_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProjectIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "project_identifier",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: span_ids.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "span_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotSpanIdsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotSpanIdsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.SpanIds = append(params.SpanIds, paramsDotSpanIdsVal)
					return nil
				})
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.SpanIds == nil {
					return errors.New("nil is invalid value")
				}
				if err := (validate.Array{
					MinLength:    1,
					MinLengthSet: true,
					MaxLength:    0,
					MaxLengthSet: false,
				}).ValidateLength(len(params.SpanIds)); err != nil {
					return errors.Wrap(err, "array")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "span_ids",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: include_annotation_names.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeAnnotationNamesVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotIncludeAnnotationNamesValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotIncludeAnnotationNamesValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotIncludeAnnotationNamesVal = append(paramsDotIncludeAnnotationNamesVal, paramsDotIncludeAnnotationNamesValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.IncludeAnnotationNames.SetTo(paramsDotIncludeAnnotationNamesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.IncludeAnnotationNames.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "include_annotation_names",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: exclude_annotation_names.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exclude_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotExcludeAnnotationNamesVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotExcludeAnnotationNamesValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotExcludeAnnotationNamesValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotExcludeAnnotationNamesVal = append(paramsDotExcludeAnnotationNamesVal, paramsDotExcludeAnnotationNamesValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.ExcludeAnnotationNames.SetTo(paramsDotExcludeAnnotationNamesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.ExcludeAnnotationNames.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "exclude_annotation_names",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(10)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           10000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListTraceAnnotationsByTraceIdsParams is parameters of listTraceAnnotationsByTraceIds operation.
type ListTraceAnnotationsByTraceIdsParams struct {
	// The project identifier: either project ID or project name. If using a project name as the
	// identifier, it cannot contain slash (/), question mark (?), or pound sign (#) characters.
	ProjectIdentifier string
	// One or more trace id to fetch annotations for.
	TraceIds []string `json:",omitempty"`
	// Optional list of annotation names to include. If provided, only annotations with these names will
	// be returned. 'note' annotations are excluded by default unless explicitly included in this list.
	IncludeAnnotationNames OptNilStringArray `json:",omitempty,omitzero"`
	// Optional list of annotation names to exclude from results.
	ExcludeAnnotationNames OptNilStringArray `json:",omitempty,omitzero"`
	// A cursor for pagination.
	Cursor OptNilString `json:",omitempty,omitzero"`
	// The maximum number of annotations to return in a single request.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackListTraceAnnotationsByTraceIdsParams(packed middleware.Parameters) (params ListTraceAnnotationsByTraceIdsParams) {
	{
		key := middleware.ParameterKey{
			Name: "project_identifier",
			In:   "path",
		}
		params.ProjectIdentifier = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "trace_ids",
			In:   "query",
		}
		params.TraceIds = packed[key].([]string)
	}
	{
		key := middleware.ParameterKey{
			Name: "include_annotation_names",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludeAnnotationNames = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "exclude_annotation_names",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ExcludeAnnotationNames = v.(OptNilStringArray)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeListTraceAnnotationsByTraceIdsParams(args [1]string, argsEscaped bool, r *http.Request) (params ListTraceAnnotationsByTraceIdsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: project_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProjectIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "project_identifier",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: trace_ids.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "trace_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotTraceIdsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotTraceIdsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.TraceIds = append(params.TraceIds, paramsDotTraceIdsVal)
					return nil
				})
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.TraceIds == nil {
					return errors.New("nil is invalid value")
				}
				if err := (validate.Array{
					MinLength:    1,
					MinLengthSet: true,
					MaxLength:    0,
					MaxLengthSet: false,
				}).ValidateLength(len(params.TraceIds)); err != nil {
					return errors.Wrap(err, "array")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "trace_ids",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: include_annotation_names.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeAnnotationNamesVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotIncludeAnnotationNamesValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotIncludeAnnotationNamesValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotIncludeAnnotationNamesVal = append(paramsDotIncludeAnnotationNamesVal, paramsDotIncludeAnnotationNamesValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.IncludeAnnotationNames.SetTo(paramsDotIncludeAnnotationNamesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.IncludeAnnotationNames.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "include_annotation_names",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: exclude_annotation_names.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exclude_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotExcludeAnnotationNamesVal []string
				if err := func() error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var paramsDotExcludeAnnotationNamesValVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							paramsDotExcludeAnnotationNamesValVal = c
							return nil
						}(); err != nil {
							return err
						}
						paramsDotExcludeAnnotationNamesVal = append(paramsDotExcludeAnnotationNamesVal, paramsDotExcludeAnnotationNamesValVal)
						return nil
					})
				}(); err != nil {
					return err
				}
				params.ExcludeAnnotationNames.SetTo(paramsDotExcludeAnnotationNamesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.ExcludeAnnotationNames.Get(); ok {
					if err := func() error {
						if value == nil {
							return errors.New("nil is invalid value")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "exclude_annotation_names",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(10)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           10000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutParams is parameters of update_annotation_config_v1_annotation_configs__config_id__put operation.
type UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutParams struct {
	// ID of the annotation configuration.
	ConfigID string
}

func unpackUpdateAnnotationConfigV1AnnotationConfigsConfigIDPutParams(packed middleware.Parameters) (params UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutParams) {
	{
		key := middleware.ParameterKey{
			Name: "config_id",
			In:   "path",
		}
		params.ConfigID = packed[key].(string)
	}
	return params
}

func decodeUpdateAnnotationConfigV1AnnotationConfigsConfigIDPutParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutParams, _ error) {
	// Decode path: config_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "config_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ConfigID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "config_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateProjectParams is parameters of updateProject operation.
type UpdateProjectParams struct {
	// The project identifier: either project ID or project name. If using a project name, it cannot
	// contain slash (/), question mark (?), or pound sign (#) characters.
	ProjectIdentifier string
}

func unpackUpdateProjectParams(packed middleware.Parameters) (params UpdateProjectParams) {
	{
		key := middleware.ParameterKey{
			Name: "project_identifier",
			In:   "path",
		}
		params.ProjectIdentifier = packed[key].(string)
	}
	return params
}

func decodeUpdateProjectParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateProjectParams, _ error) {
	// Decode path: project_identifier.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_identifier",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProjectIdentifier = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "project_identifier",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UploadDatasetParams is parameters of uploadDataset operation.
type UploadDatasetParams struct {
	// If true, fulfill request synchronously and return JSON containing dataset_id.
	Sync OptBool `json:",omitempty,omitzero"`
}

func unpackUploadDatasetParams(packed middleware.Parameters) (params UploadDatasetParams) {
	{
		key := middleware.ParameterKey{
			Name: "sync",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sync = v.(OptBool)
		}
	}
	return params
}

func decodeUploadDatasetParams(args [0]string, argsEscaped bool, r *http.Request) (params UploadDatasetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: sync.
	{
		val := bool(false)
		params.Sync.SetTo(val)
	}
	// Decode query: sync.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sync",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSyncVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotSyncVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sync.SetTo(paramsDotSyncVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sync",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}
