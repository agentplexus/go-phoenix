// Code generated by ogen, DO NOT EDIT.

package api

import (
	"io"
	"net/http"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

func encodeAddEvaluationsResponse(response AddEvaluationsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AddEvaluationsNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))

		return nil

	case *AddEvaluationsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AddEvaluationsUnsupportedMediaType:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AddEvaluationsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeAnnotateSessionsResponse(response AnnotateSessionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AnnotateSessionsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AnnotateSessionsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AnnotateSessionsNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeAnnotateSpanDocumentsResponse(response AnnotateSpanDocumentsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AnnotateSpanDocumentsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AnnotateSpanDocumentsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AnnotateSpanDocumentsNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AnnotateSpanDocumentsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeAnnotateSpansResponse(response AnnotateSpansRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AnnotateSpansResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AnnotateSpansForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AnnotateSpansNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeAnnotateTracesResponse(response AnnotateTracesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AnnotateTracesResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AnnotateTracesForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AnnotateTracesNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeCreateAnnotationConfigV1AnnotationConfigsPostResponse(response CreateAnnotationConfigV1AnnotationConfigsPostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CreateAnnotationConfigResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateAnnotationConfigV1AnnotationConfigsPostForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeCreateExperimentResponse(response CreateExperimentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CreateExperimentResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateExperimentForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateExperimentNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeCreateExperimentRunResponse(response CreateExperimentRunRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CreateExperimentRunResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateExperimentRunForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateExperimentRunNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateExperimentRunConflict:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeCreateProjectResponse(response CreateProjectRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CreateProjectResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateProjectForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateProjectUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeCreatePromptVersionTagResponse(response CreatePromptVersionTagRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CreatePromptVersionTagNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))

		return nil

	case *CreatePromptVersionTagForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreatePromptVersionTagNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreatePromptVersionTagUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeCreateSpanNoteResponse(response CreateSpanNoteRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CreateSpanNoteResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateSpanNoteForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateSpanNoteNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeCreateSpansResponse(response CreateSpansRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CreateSpansResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(202)
		span.SetStatus(codes.Ok, http.StatusText(202))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateSpansBadRequest:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateSpansForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateSpansNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeCreateUserResponse(response CreateUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CreateUserResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(201)
		span.SetStatus(codes.Ok, http.StatusText(201))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateUserBadRequest:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateUserForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateUserConflict:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *CreateUserUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeDeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteResponse(response DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *DeleteAnnotationConfigResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeDeleteDatasetByIdResponse(response DeleteDatasetByIdRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *DeleteDatasetByIdNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))

		return nil

	case *DeleteDatasetByIdForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *DeleteDatasetByIdNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *DeleteDatasetByIdUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeDeleteExperimentResponse(response DeleteExperimentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *DeleteExperimentNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))

		return nil

	case *DeleteExperimentForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *DeleteExperimentNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeDeleteProjectResponse(response DeleteProjectRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *DeleteProjectNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))

		return nil

	case *DeleteProjectForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *DeleteProjectNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *DeleteProjectUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeDeleteSpanResponse(response DeleteSpanRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *DeleteSpanNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))

		return nil

	case *DeleteSpanForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *DeleteSpanNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeDeleteTraceResponse(response DeleteTraceRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *DeleteTraceNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))

		return nil

	case *DeleteTraceForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *DeleteTraceNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeDeleteUserResponse(response DeleteUserRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *DeleteUserNoContent:
		w.WriteHeader(204)
		span.SetStatus(codes.Ok, http.StatusText(204))

		return nil

	case *DeleteUserForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *DeleteUserNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *DeleteUserUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetResponse(response GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetAnnotationConfigResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetDatasetResponse(response GetDatasetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetDatasetResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetDatasetForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetDatasetNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetDatasetCsvResponse(response GetDatasetCsvRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetDatasetCsvOK:
		w.Header().Set("Content-Type", "text/csv")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetDatasetCsvForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetDatasetCsvUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetDatasetExamplesResponse(response GetDatasetExamplesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ListDatasetExamplesResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetDatasetExamplesForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetDatasetExamplesNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetDatasetJSONLOpenAIEvalsResponse(response GetDatasetJSONLOpenAIEvalsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetDatasetJSONLOpenAIEvalsOK:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetDatasetJSONLOpenAIEvalsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetDatasetJSONLOpenAIEvalsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetDatasetJSONLOpenAIFineTuningResponse(response GetDatasetJSONLOpenAIFineTuningRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetDatasetJSONLOpenAIFineTuningOK:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetDatasetJSONLOpenAIFineTuningForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetDatasetJSONLOpenAIFineTuningUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetEvaluationsResponse(response GetEvaluationsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetEvaluationsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetEvaluationsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetEvaluationsNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetExperimentResponse(response GetExperimentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetExperimentResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetExperimentForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetExperimentNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetExperimentCSVResponse(response GetExperimentCSVRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetExperimentCSVOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetExperimentCSVOKTextCsv:
		w.Header().Set("Content-Type", "text/csv")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetExperimentCSVForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetExperimentJSONResponse(response GetExperimentJSONRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetExperimentJSONOK:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetExperimentJSONForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetExperimentJSONNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetIncompleteExperimentEvaluationsResponse(response GetIncompleteExperimentEvaluationsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetIncompleteEvaluationsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetIncompleteExperimentEvaluationsBadRequest:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetIncompleteExperimentEvaluationsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetIncompleteExperimentEvaluationsNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetIncompleteExperimentEvaluationsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetIncompleteExperimentRunsResponse(response GetIncompleteExperimentRunsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetIncompleteExperimentRunsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetIncompleteExperimentRunsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetIncompleteExperimentRunsNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetIncompleteExperimentRunsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetProjectResponse(response GetProjectRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetProjectResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetProjectForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetProjectNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetProjectUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetProjectsResponse(response GetProjectsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetProjectsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetProjectsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetProjectsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetPromptVersionByPromptVersionIdResponse(response GetPromptVersionByPromptVersionIdRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetPromptResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionByPromptVersionIdForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionByPromptVersionIdNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionByPromptVersionIdUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetPromptVersionByTagNameResponse(response GetPromptVersionByTagNameRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetPromptResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionByTagNameForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionByTagNameNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionByTagNameUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetPromptVersionLatestResponse(response GetPromptVersionLatestRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetPromptResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionLatestForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionLatestNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionLatestUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetPromptVersionTagsResponse(response GetPromptVersionTagsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetPromptVersionTagsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionTagsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionTagsNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptVersionTagsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetPromptsResponse(response GetPromptsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetPromptsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetPromptsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetSpansResponse(response GetSpansRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SpansResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetSpansForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetSpansNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetSpansUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeGetUsersResponse(response GetUsersRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetUsersResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetUsersForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *GetUsersUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeListAnnotationConfigsV1AnnotationConfigsGetResponse(response ListAnnotationConfigsV1AnnotationConfigsGetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetAnnotationConfigsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListAnnotationConfigsV1AnnotationConfigsGetForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeListDatasetVersionsByDatasetIdResponse(response ListDatasetVersionsByDatasetIdRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ListDatasetVersionsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListDatasetVersionsByDatasetIdForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListDatasetVersionsByDatasetIdUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeListDatasetsResponse(response ListDatasetsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ListDatasetsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListDatasetsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListDatasetsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeListExperimentRunsResponse(response ListExperimentRunsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ListExperimentRunsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListExperimentRunsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListExperimentRunsNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListExperimentRunsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeListExperimentsResponse(response ListExperimentsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ListExperimentsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListExperimentsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListExperimentsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeListPromptVersionsResponse(response ListPromptVersionsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *GetPromptVersionsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListPromptVersionsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListPromptVersionsNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListPromptVersionsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeListSessionAnnotationsBySessionIdsResponse(response ListSessionAnnotationsBySessionIdsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SessionAnnotationsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListSessionAnnotationsBySessionIdsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListSessionAnnotationsBySessionIdsNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListSessionAnnotationsBySessionIdsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeListSpanAnnotationsBySpanIdsResponse(response ListSpanAnnotationsBySpanIdsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SpanAnnotationsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListSpanAnnotationsBySpanIdsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListSpanAnnotationsBySpanIdsNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListSpanAnnotationsBySpanIdsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeListTraceAnnotationsByTraceIdsResponse(response ListTraceAnnotationsByTraceIdsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TraceAnnotationsResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListTraceAnnotationsByTraceIdsForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListTraceAnnotationsByTraceIdsNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ListTraceAnnotationsByTraceIdsUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodePostPromptVersionResponse(response PostPromptVersionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *CreatePromptResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *PostPromptVersionForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *PostPromptVersionUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeUpdateAnnotationConfigV1AnnotationConfigsConfigIDPutResponse(response UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UpdateAnnotationConfigResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeUpdateProjectResponse(response UpdateProjectRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UpdateProjectResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *UpdateProjectForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *UpdateProjectNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *UpdateProjectUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeUploadDatasetResponse(response UploadDatasetRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UploadDatasetResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *UploadDatasetForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *UploadDatasetConflict:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(409)
		span.SetStatus(codes.Error, http.StatusText(409))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *UploadDatasetUnprocessableEntity:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeUpsertExperimentEvaluationResponse(response UpsertExperimentEvaluationRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *UpsertExperimentEvaluationResponseBody:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *UpsertExperimentEvaluationForbidden:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *UpsertExperimentEvaluationNotFound:
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		writer := w
		if closer, ok := response.Data.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := io.Copy(writer, response); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *HTTPValidationError:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(422)
		span.SetStatus(codes.Error, http.StatusText(422))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}
