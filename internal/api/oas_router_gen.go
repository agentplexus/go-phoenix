// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [2]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/v1/"

			if l := len("/v1/"); len(elem) >= l && elem[0:l] == "/v1/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "annotation_configs"

				if l := len("annotation_configs"); len(elem) >= l && elem[0:l] == "annotation_configs" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleListAnnotationConfigsV1AnnotationConfigsGetRequest([0]string{}, elemIsEscaped, w, r)
					case "POST":
						s.handleCreateAnnotationConfigV1AnnotationConfigsPostRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "config_id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "DELETE":
							s.handleDeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "PUT":
							s.handleUpdateAnnotationConfigV1AnnotationConfigsConfigIDPutRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,PUT")
						}

						return
					}

				}

			case 'd': // Prefix: "d"

				if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "atasets"

					if l := len("atasets"); len(elem) >= l && elem[0:l] == "atasets" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListDatasetsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'u': // Prefix: "upload"
							origElem := elem
							if l := len("upload"); len(elem) >= l && elem[0:l] == "upload" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleUploadDatasetRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

							elem = origElem
						}
						// Param: "dataset_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteDatasetByIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetDatasetRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "csv"

								if l := len("csv"); len(elem) >= l && elem[0:l] == "csv" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetDatasetCsvRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'e': // Prefix: "ex"

								if l := len("ex"); len(elem) >= l && elem[0:l] == "ex" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "amples"

									if l := len("amples"); len(elem) >= l && elem[0:l] == "amples" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetDatasetExamplesRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'p': // Prefix: "periments"

									if l := len("periments"); len(elem) >= l && elem[0:l] == "periments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleListExperimentsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "POST":
											s.handleCreateExperimentRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}

								}

							case 'j': // Prefix: "jsonl/openai_"

								if l := len("jsonl/openai_"); len(elem) >= l && elem[0:l] == "jsonl/openai_" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "evals"

									if l := len("evals"); len(elem) >= l && elem[0:l] == "evals" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetDatasetJSONLOpenAIEvalsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'f': // Prefix: "ft"

									if l := len("ft"); len(elem) >= l && elem[0:l] == "ft" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetDatasetJSONLOpenAIFineTuningRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'v': // Prefix: "versions"

								if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListDatasetVersionsByDatasetIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						}

					}

				case 'o': // Prefix: "ocument_annotations"

					if l := len("ocument_annotations"); len(elem) >= l && elem[0:l] == "ocument_annotations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAnnotateSpanDocumentsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				}

			case 'e': // Prefix: "e"

				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'v': // Prefix: "valuations"

					if l := len("valuations"); len(elem) >= l && elem[0:l] == "valuations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleGetEvaluationsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleAddEvaluationsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}

				case 'x': // Prefix: "xperiment"

					if l := len("xperiment"); len(elem) >= l && elem[0:l] == "xperiment" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '_': // Prefix: "_evaluations"

						if l := len("_evaluations"); len(elem) >= l && elem[0:l] == "_evaluations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleUpsertExperimentEvaluationRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 's': // Prefix: "s/"

						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "experiment_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteExperimentRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetExperimentRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "csv"

								if l := len("csv"); len(elem) >= l && elem[0:l] == "csv" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetExperimentCSVRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'i': // Prefix: "incomplete-"

								if l := len("incomplete-"); len(elem) >= l && elem[0:l] == "incomplete-" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "evaluations"

									if l := len("evaluations"); len(elem) >= l && elem[0:l] == "evaluations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetIncompleteExperimentEvaluationsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'r': // Prefix: "runs"

									if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetIncompleteExperimentRunsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'j': // Prefix: "json"

								if l := len("json"); len(elem) >= l && elem[0:l] == "json" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetExperimentJSONRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'r': // Prefix: "runs"

								if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListExperimentRunsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleCreateExperimentRunRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}

							}

						}

					}

				}

			case 'p': // Prefix: "pro"

				if l := len("pro"); len(elem) >= l && elem[0:l] == "pro" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'j': // Prefix: "jects"

					if l := len("jects"); len(elem) >= l && elem[0:l] == "jects" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetProjectsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateProjectRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "project_identifier"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteProjectRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetProjectRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateProjectRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "s"

								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ession_annotations"

									if l := len("ession_annotations"); len(elem) >= l && elem[0:l] == "ession_annotations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleListSessionAnnotationsBySessionIdsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'p': // Prefix: "pan"

									if l := len("pan"); len(elem) >= l && elem[0:l] == "pan" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '_': // Prefix: "_annotations"

										if l := len("_annotations"); len(elem) >= l && elem[0:l] == "_annotations" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleListSpanAnnotationsBySpanIdsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 's': // Prefix: "s"

										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetSpansRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handleCreateSpansRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}

									}

								}

							case 't': // Prefix: "trace_annotations"

								if l := len("trace_annotations"); len(elem) >= l && elem[0:l] == "trace_annotations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListTraceAnnotationsByTraceIdsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						}

					}

				case 'm': // Prefix: "mpt"

					if l := len("mpt"); len(elem) >= l && elem[0:l] == "mpt" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '_': // Prefix: "_versions/"

						if l := len("_versions/"); len(elem) >= l && elem[0:l] == "_versions/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "prompt_version_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetPromptVersionByPromptVersionIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/tags"

							if l := len("/tags"); len(elem) >= l && elem[0:l] == "/tags" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetPromptVersionTagsRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreatePromptVersionTagRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}

						}

					case 's': // Prefix: "s"

						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetPromptsRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handlePostPromptVersionRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "prompt_identifier"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'l': // Prefix: "latest"

									if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetPromptVersionLatestRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 't': // Prefix: "tags/"

									if l := len("tags/"); len(elem) >= l && elem[0:l] == "tags/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tag_name"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetPromptVersionByTagNameRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'v': // Prefix: "versions"

									if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleListPromptVersionsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						}

					}

				}

			case 's': // Prefix: "s"

				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "ession_annotations"

					if l := len("ession_annotations"); len(elem) >= l && elem[0:l] == "ession_annotations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAnnotateSessionsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 'p': // Prefix: "pan"

					if l := len("pan"); len(elem) >= l && elem[0:l] == "pan" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '_': // Prefix: "_"

						if l := len("_"); len(elem) >= l && elem[0:l] == "_" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "annotations"

							if l := len("annotations"); len(elem) >= l && elem[0:l] == "annotations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAnnotateSpansRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'n': // Prefix: "notes"

							if l := len("notes"); len(elem) >= l && elem[0:l] == "notes" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleCreateSpanNoteRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					case 's': // Prefix: "s/"

						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "span_identifier"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteSpanRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}

					}

				}

			case 't': // Prefix: "trace"

				if l := len("trace"); len(elem) >= l && elem[0:l] == "trace" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '_': // Prefix: "_annotations"

					if l := len("_annotations"); len(elem) >= l && elem[0:l] == "_annotations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleAnnotateTracesRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 's': // Prefix: "s/"

					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "trace_identifier"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "DELETE":
							s.handleDeleteTraceRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE")
						}

						return
					}

				}

			case 'u': // Prefix: "users"

				if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleGetUsersRequest([0]string{}, elemIsEscaped, w, r)
					case "POST":
						s.handleCreateUserRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "user_id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "DELETE":
							s.handleDeleteUserRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE")
						}

						return
					}

				}

			}

		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name           string
	summary        string
	operationID    string
	operationGroup string
	pathPattern    string
	count          int
	args           [2]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// OperationGroup returns the x-ogen-operation-group value.
func (r Route) OperationGroup() string {
	return r.operationGroup
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/v1/"

			if l := len("/v1/"); len(elem) >= l && elem[0:l] == "/v1/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "annotation_configs"

				if l := len("annotation_configs"); len(elem) >= l && elem[0:l] == "annotation_configs" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = ListAnnotationConfigsV1AnnotationConfigsGetOperation
						r.summary = "List annotation configurations"
						r.operationID = "list_annotation_configs_v1_annotation_configs_get"
						r.operationGroup = ""
						r.pathPattern = "/v1/annotation_configs"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = CreateAnnotationConfigV1AnnotationConfigsPostOperation
						r.summary = "Create an annotation configuration"
						r.operationID = "create_annotation_config_v1_annotation_configs_post"
						r.operationGroup = ""
						r.pathPattern = "/v1/annotation_configs"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "config_id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "DELETE":
							r.name = DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteOperation
							r.summary = "Delete an annotation configuration"
							r.operationID = "delete_annotation_config_v1_annotation_configs__config_id__delete"
							r.operationGroup = ""
							r.pathPattern = "/v1/annotation_configs/{config_id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							r.name = GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetOperation
							r.summary = "Get an annotation configuration by ID or name"
							r.operationID = "get_annotation_config_by_name_or_id_v1_annotation_configs__config_identifier__get"
							r.operationGroup = ""
							r.pathPattern = "/v1/annotation_configs/{config_identifier}"
							r.args = args
							r.count = 1
							return r, true
						case "PUT":
							r.name = UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutOperation
							r.summary = "Update an annotation configuration"
							r.operationID = "update_annotation_config_v1_annotation_configs__config_id__put"
							r.operationGroup = ""
							r.pathPattern = "/v1/annotation_configs/{config_id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				}

			case 'd': // Prefix: "d"

				if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "atasets"

					if l := len("atasets"); len(elem) >= l && elem[0:l] == "atasets" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = ListDatasetsOperation
							r.summary = "List datasets"
							r.operationID = "listDatasets"
							r.operationGroup = ""
							r.pathPattern = "/v1/datasets"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'u': // Prefix: "upload"
							origElem := elem
							if l := len("upload"); len(elem) >= l && elem[0:l] == "upload" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = UploadDatasetOperation
									r.summary = "Upload dataset from JSON, CSV, or PyArrow"
									r.operationID = "uploadDataset"
									r.operationGroup = ""
									r.pathPattern = "/v1/datasets/upload"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}
						// Param: "dataset_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = DeleteDatasetByIdOperation
								r.summary = "Delete dataset by ID"
								r.operationID = "deleteDatasetById"
								r.operationGroup = ""
								r.pathPattern = "/v1/datasets/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = GetDatasetOperation
								r.summary = "Get dataset by ID"
								r.operationID = "getDataset"
								r.operationGroup = ""
								r.pathPattern = "/v1/datasets/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "csv"

								if l := len("csv"); len(elem) >= l && elem[0:l] == "csv" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetDatasetCsvOperation
										r.summary = "Download dataset examples as CSV file"
										r.operationID = "getDatasetCsv"
										r.operationGroup = ""
										r.pathPattern = "/v1/datasets/{id}/csv"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'e': // Prefix: "ex"

								if l := len("ex"); len(elem) >= l && elem[0:l] == "ex" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "amples"

									if l := len("amples"); len(elem) >= l && elem[0:l] == "amples" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetDatasetExamplesOperation
											r.summary = "Get examples from a dataset"
											r.operationID = "getDatasetExamples"
											r.operationGroup = ""
											r.pathPattern = "/v1/datasets/{id}/examples"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'p': // Prefix: "periments"

									if l := len("periments"); len(elem) >= l && elem[0:l] == "periments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ListExperimentsOperation
											r.summary = "List experiments by dataset"
											r.operationID = "listExperiments"
											r.operationGroup = ""
											r.pathPattern = "/v1/datasets/{dataset_id}/experiments"
											r.args = args
											r.count = 1
											return r, true
										case "POST":
											r.name = CreateExperimentOperation
											r.summary = "Create experiment on a dataset"
											r.operationID = "createExperiment"
											r.operationGroup = ""
											r.pathPattern = "/v1/datasets/{dataset_id}/experiments"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'j': // Prefix: "jsonl/openai_"

								if l := len("jsonl/openai_"); len(elem) >= l && elem[0:l] == "jsonl/openai_" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "evals"

									if l := len("evals"); len(elem) >= l && elem[0:l] == "evals" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetDatasetJSONLOpenAIEvalsOperation
											r.summary = "Download dataset examples as OpenAI evals JSONL file"
											r.operationID = "getDatasetJSONLOpenAIEvals"
											r.operationGroup = ""
											r.pathPattern = "/v1/datasets/{id}/jsonl/openai_evals"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'f': // Prefix: "ft"

									if l := len("ft"); len(elem) >= l && elem[0:l] == "ft" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetDatasetJSONLOpenAIFineTuningOperation
											r.summary = "Download dataset examples as OpenAI fine-tuning JSONL file"
											r.operationID = "getDatasetJSONLOpenAIFineTuning"
											r.operationGroup = ""
											r.pathPattern = "/v1/datasets/{id}/jsonl/openai_ft"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'v': // Prefix: "versions"

								if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = ListDatasetVersionsByDatasetIdOperation
										r.summary = "List dataset versions"
										r.operationID = "listDatasetVersionsByDatasetId"
										r.operationGroup = ""
										r.pathPattern = "/v1/datasets/{id}/versions"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					}

				case 'o': // Prefix: "ocument_annotations"

					if l := len("ocument_annotations"); len(elem) >= l && elem[0:l] == "ocument_annotations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = AnnotateSpanDocumentsOperation
							r.summary = "Annotate Span Documents"
							r.operationID = "annotateSpanDocuments"
							r.operationGroup = ""
							r.pathPattern = "/v1/document_annotations"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			case 'e': // Prefix: "e"

				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'v': // Prefix: "valuations"

					if l := len("valuations"); len(elem) >= l && elem[0:l] == "valuations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = GetEvaluationsOperation
							r.summary = "Get span, trace, or document evaluations from a project"
							r.operationID = "getEvaluations"
							r.operationGroup = ""
							r.pathPattern = "/v1/evaluations"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = AddEvaluationsOperation
							r.summary = "Add span, trace, or document evaluations"
							r.operationID = "addEvaluations"
							r.operationGroup = ""
							r.pathPattern = "/v1/evaluations"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'x': // Prefix: "xperiment"

					if l := len("xperiment"); len(elem) >= l && elem[0:l] == "xperiment" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '_': // Prefix: "_evaluations"

						if l := len("_evaluations"); len(elem) >= l && elem[0:l] == "_evaluations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = UpsertExperimentEvaluationOperation
								r.summary = "Create or update evaluation for an experiment run"
								r.operationID = "upsertExperimentEvaluation"
								r.operationGroup = ""
								r.pathPattern = "/v1/experiment_evaluations"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 's': // Prefix: "s/"

						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "experiment_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = DeleteExperimentOperation
								r.summary = "Delete experiment by ID"
								r.operationID = "deleteExperiment"
								r.operationGroup = ""
								r.pathPattern = "/v1/experiments/{experiment_id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = GetExperimentOperation
								r.summary = "Get experiment by ID"
								r.operationID = "getExperiment"
								r.operationGroup = ""
								r.pathPattern = "/v1/experiments/{experiment_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "csv"

								if l := len("csv"); len(elem) >= l && elem[0:l] == "csv" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetExperimentCSVOperation
										r.summary = "Download experiment runs as a CSV file"
										r.operationID = "getExperimentCSV"
										r.operationGroup = ""
										r.pathPattern = "/v1/experiments/{experiment_id}/csv"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'i': // Prefix: "incomplete-"

								if l := len("incomplete-"); len(elem) >= l && elem[0:l] == "incomplete-" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "evaluations"

									if l := len("evaluations"); len(elem) >= l && elem[0:l] == "evaluations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetIncompleteExperimentEvaluationsOperation
											r.summary = "Get incomplete evaluations for an experiment"
											r.operationID = "getIncompleteExperimentEvaluations"
											r.operationGroup = ""
											r.pathPattern = "/v1/experiments/{experiment_id}/incomplete-evaluations"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'r': // Prefix: "runs"

									if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetIncompleteExperimentRunsOperation
											r.summary = "Get incomplete runs for an experiment"
											r.operationID = "getIncompleteExperimentRuns"
											r.operationGroup = ""
											r.pathPattern = "/v1/experiments/{experiment_id}/incomplete-runs"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'j': // Prefix: "json"

								if l := len("json"); len(elem) >= l && elem[0:l] == "json" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetExperimentJSONOperation
										r.summary = "Download experiment runs as a JSON file"
										r.operationID = "getExperimentJSON"
										r.operationGroup = ""
										r.pathPattern = "/v1/experiments/{experiment_id}/json"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'r': // Prefix: "runs"

								if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = ListExperimentRunsOperation
										r.summary = "List runs for an experiment"
										r.operationID = "listExperimentRuns"
										r.operationGroup = ""
										r.pathPattern = "/v1/experiments/{experiment_id}/runs"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = CreateExperimentRunOperation
										r.summary = "Create run for an experiment"
										r.operationID = "createExperimentRun"
										r.operationGroup = ""
										r.pathPattern = "/v1/experiments/{experiment_id}/runs"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					}

				}

			case 'p': // Prefix: "pro"

				if l := len("pro"); len(elem) >= l && elem[0:l] == "pro" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'j': // Prefix: "jects"

					if l := len("jects"); len(elem) >= l && elem[0:l] == "jects" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = GetProjectsOperation
							r.summary = "List all projects"
							r.operationID = "getProjects"
							r.operationGroup = ""
							r.pathPattern = "/v1/projects"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = CreateProjectOperation
							r.summary = "Create a new project"
							r.operationID = "createProject"
							r.operationGroup = ""
							r.pathPattern = "/v1/projects"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "project_identifier"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = DeleteProjectOperation
								r.summary = "Delete a project by ID or name"
								r.operationID = "deleteProject"
								r.operationGroup = ""
								r.pathPattern = "/v1/projects/{project_identifier}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = GetProjectOperation
								r.summary = "Get project by ID or name"
								r.operationID = "getProject"
								r.operationGroup = ""
								r.pathPattern = "/v1/projects/{project_identifier}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = UpdateProjectOperation
								r.summary = "Update a project by ID or name"
								r.operationID = "updateProject"
								r.operationGroup = ""
								r.pathPattern = "/v1/projects/{project_identifier}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "s"

								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ession_annotations"

									if l := len("ession_annotations"); len(elem) >= l && elem[0:l] == "ession_annotations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ListSessionAnnotationsBySessionIdsOperation
											r.summary = "Get session annotations for a list of session_ids."
											r.operationID = "listSessionAnnotationsBySessionIds"
											r.operationGroup = ""
											r.pathPattern = "/v1/projects/{project_identifier}/session_annotations"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'p': // Prefix: "pan"

									if l := len("pan"); len(elem) >= l && elem[0:l] == "pan" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '_': // Prefix: "_annotations"

										if l := len("_annotations"); len(elem) >= l && elem[0:l] == "_annotations" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = ListSpanAnnotationsBySpanIdsOperation
												r.summary = "Get span annotations for a list of span_ids."
												r.operationID = "listSpanAnnotationsBySpanIds"
												r.operationGroup = ""
												r.pathPattern = "/v1/projects/{project_identifier}/span_annotations"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 's': // Prefix: "s"

										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetSpansOperation
												r.summary = "List spans with simple filters (no DSL)"
												r.operationID = "getSpans"
												r.operationGroup = ""
												r.pathPattern = "/v1/projects/{project_identifier}/spans"
												r.args = args
												r.count = 1
												return r, true
											case "POST":
												r.name = CreateSpansOperation
												r.summary = "Create spans"
												r.operationID = "createSpans"
												r.operationGroup = ""
												r.pathPattern = "/v1/projects/{project_identifier}/spans"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							case 't': // Prefix: "trace_annotations"

								if l := len("trace_annotations"); len(elem) >= l && elem[0:l] == "trace_annotations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = ListTraceAnnotationsByTraceIdsOperation
										r.summary = "Get trace annotations for a list of trace_ids."
										r.operationID = "listTraceAnnotationsByTraceIds"
										r.operationGroup = ""
										r.pathPattern = "/v1/projects/{project_identifier}/trace_annotations"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					}

				case 'm': // Prefix: "mpt"

					if l := len("mpt"); len(elem) >= l && elem[0:l] == "mpt" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '_': // Prefix: "_versions/"

						if l := len("_versions/"); len(elem) >= l && elem[0:l] == "_versions/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "prompt_version_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = GetPromptVersionByPromptVersionIdOperation
								r.summary = "Get prompt version by ID"
								r.operationID = "getPromptVersionByPromptVersionId"
								r.operationGroup = ""
								r.pathPattern = "/v1/prompt_versions/{prompt_version_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/tags"

							if l := len("/tags"); len(elem) >= l && elem[0:l] == "/tags" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetPromptVersionTagsOperation
									r.summary = "List prompt version tags"
									r.operationID = "getPromptVersionTags"
									r.operationGroup = ""
									r.pathPattern = "/v1/prompt_versions/{prompt_version_id}/tags"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									r.name = CreatePromptVersionTagOperation
									r.summary = "Add tag to prompt version"
									r.operationID = "createPromptVersionTag"
									r.operationGroup = ""
									r.pathPattern = "/v1/prompt_versions/{prompt_version_id}/tags"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 's': // Prefix: "s"

						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = GetPromptsOperation
								r.summary = "List all prompts"
								r.operationID = "getPrompts"
								r.operationGroup = ""
								r.pathPattern = "/v1/prompts"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = PostPromptVersionOperation
								r.summary = "Create a new prompt"
								r.operationID = "postPromptVersion"
								r.operationGroup = ""
								r.pathPattern = "/v1/prompts"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "prompt_identifier"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'l': // Prefix: "latest"

									if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetPromptVersionLatestOperation
											r.summary = "Get latest prompt version"
											r.operationID = "getPromptVersionLatest"
											r.operationGroup = ""
											r.pathPattern = "/v1/prompts/{prompt_identifier}/latest"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 't': // Prefix: "tags/"

									if l := len("tags/"); len(elem) >= l && elem[0:l] == "tags/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tag_name"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetPromptVersionByTagNameOperation
											r.summary = "Get prompt version by tag"
											r.operationID = "getPromptVersionByTagName"
											r.operationGroup = ""
											r.pathPattern = "/v1/prompts/{prompt_identifier}/tags/{tag_name}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								case 'v': // Prefix: "versions"

									if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ListPromptVersionsOperation
											r.summary = "List prompt versions"
											r.operationID = "listPromptVersions"
											r.operationGroup = ""
											r.pathPattern = "/v1/prompts/{prompt_identifier}/versions"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					}

				}

			case 's': // Prefix: "s"

				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "ession_annotations"

					if l := len("ession_annotations"); len(elem) >= l && elem[0:l] == "ession_annotations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = AnnotateSessionsOperation
							r.summary = "Create session annotations"
							r.operationID = "annotateSessions"
							r.operationGroup = ""
							r.pathPattern = "/v1/session_annotations"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'p': // Prefix: "pan"

					if l := len("pan"); len(elem) >= l && elem[0:l] == "pan" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '_': // Prefix: "_"

						if l := len("_"); len(elem) >= l && elem[0:l] == "_" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "annotations"

							if l := len("annotations"); len(elem) >= l && elem[0:l] == "annotations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = AnnotateSpansOperation
									r.summary = "Create span annotations"
									r.operationID = "annotateSpans"
									r.operationGroup = ""
									r.pathPattern = "/v1/span_annotations"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'n': // Prefix: "notes"

							if l := len("notes"); len(elem) >= l && elem[0:l] == "notes" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = CreateSpanNoteOperation
									r.summary = "Create a span note"
									r.operationID = "createSpanNote"
									r.operationGroup = ""
									r.pathPattern = "/v1/span_notes"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 's': // Prefix: "s/"

						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "span_identifier"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "DELETE":
								r.name = DeleteSpanOperation
								r.summary = "Delete a span by span_identifier"
								r.operationID = "deleteSpan"
								r.operationGroup = ""
								r.pathPattern = "/v1/spans/{span_identifier}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					}

				}

			case 't': // Prefix: "trace"

				if l := len("trace"); len(elem) >= l && elem[0:l] == "trace" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '_': // Prefix: "_annotations"

					if l := len("_annotations"); len(elem) >= l && elem[0:l] == "_annotations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = AnnotateTracesOperation
							r.summary = "Create trace annotations"
							r.operationID = "annotateTraces"
							r.operationGroup = ""
							r.pathPattern = "/v1/trace_annotations"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 's': // Prefix: "s/"

					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "trace_identifier"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "DELETE":
							r.name = DeleteTraceOperation
							r.summary = "Delete a trace by identifier"
							r.operationID = "deleteTrace"
							r.operationGroup = ""
							r.pathPattern = "/v1/traces/{trace_identifier}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				}

			case 'u': // Prefix: "users"

				if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = GetUsersOperation
						r.summary = "List all users"
						r.operationID = "getUsers"
						r.operationGroup = ""
						r.pathPattern = "/v1/users"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = CreateUserOperation
						r.summary = "Create a new user"
						r.operationID = "createUser"
						r.operationGroup = ""
						r.pathPattern = "/v1/users"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "user_id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "DELETE":
							r.name = DeleteUserOperation
							r.summary = "Delete a user by ID"
							r.operationID = "deleteUser"
							r.operationGroup = ""
							r.pathPattern = "/v1/users/{user_id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				}

			}

		}
	}
	return r, false
}
