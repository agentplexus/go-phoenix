// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AddEvaluations invokes addEvaluations operation.
	//
	// Add span, trace, or document evaluations.
	//
	// POST /v1/evaluations
	AddEvaluations(ctx context.Context, request AddEvaluationsReq, params AddEvaluationsParams) (AddEvaluationsRes, error)
	// AnnotateSessions invokes annotateSessions operation.
	//
	// Create session annotations.
	//
	// POST /v1/session_annotations
	AnnotateSessions(ctx context.Context, request *AnnotateSessionsRequestBody, params AnnotateSessionsParams) (AnnotateSessionsRes, error)
	// AnnotateSpanDocuments invokes annotateSpanDocuments operation.
	//
	// Annotate Span Documents.
	//
	// POST /v1/document_annotations
	AnnotateSpanDocuments(ctx context.Context, request *AnnotateSpanDocumentsRequestBody, params AnnotateSpanDocumentsParams) (AnnotateSpanDocumentsRes, error)
	// AnnotateSpans invokes annotateSpans operation.
	//
	// Create span annotations.
	//
	// POST /v1/span_annotations
	AnnotateSpans(ctx context.Context, request *AnnotateSpansRequestBody, params AnnotateSpansParams) (AnnotateSpansRes, error)
	// AnnotateTraces invokes annotateTraces operation.
	//
	// Create trace annotations.
	//
	// POST /v1/trace_annotations
	AnnotateTraces(ctx context.Context, request *AnnotateTracesRequestBody, params AnnotateTracesParams) (AnnotateTracesRes, error)
	// CreateAnnotationConfigV1AnnotationConfigsPost invokes create_annotation_config_v1_annotation_configs_post operation.
	//
	// Create an annotation configuration.
	//
	// POST /v1/annotation_configs
	CreateAnnotationConfigV1AnnotationConfigsPost(ctx context.Context, request CreateAnnotationConfigData) (CreateAnnotationConfigV1AnnotationConfigsPostRes, error)
	// CreateExperiment invokes createExperiment operation.
	//
	// Create experiment on a dataset.
	//
	// POST /v1/datasets/{dataset_id}/experiments
	CreateExperiment(ctx context.Context, request *CreateExperimentRequestBody, params CreateExperimentParams) (CreateExperimentRes, error)
	// CreateExperimentRun invokes createExperimentRun operation.
	//
	// Create run for an experiment.
	//
	// POST /v1/experiments/{experiment_id}/runs
	CreateExperimentRun(ctx context.Context, request *CreateExperimentRunRequestBody, params CreateExperimentRunParams) (CreateExperimentRunRes, error)
	// CreateProject invokes createProject operation.
	//
	// Create a new project with the specified configuration.
	//
	// POST /v1/projects
	CreateProject(ctx context.Context, request *CreateProjectRequestBody) (CreateProjectRes, error)
	// CreatePromptVersionTag invokes createPromptVersionTag operation.
	//
	// Add a new tag to a specific prompt version. Tags help identify and categorize different versions
	// of a prompt.
	//
	// POST /v1/prompt_versions/{prompt_version_id}/tags
	CreatePromptVersionTag(ctx context.Context, request *PromptVersionTagData, params CreatePromptVersionTagParams) (CreatePromptVersionTagRes, error)
	// CreateSpanNote invokes createSpanNote operation.
	//
	// Add a note annotation to a span. Notes are special annotations that allow multiple entries per
	// span (unlike regular annotations which are unique by name and identifier). Each note gets a unique
	// timestamp-based identifier.
	//
	// POST /v1/span_notes
	CreateSpanNote(ctx context.Context, request *CreateSpanNoteRequestBody) (CreateSpanNoteRes, error)
	// CreateSpans invokes createSpans operation.
	//
	// Submit spans to be inserted into a project. If any spans are invalid or duplicates, no spans will
	// be inserted.
	//
	// POST /v1/projects/{project_identifier}/spans
	CreateSpans(ctx context.Context, request *CreateSpansRequestBody, params CreateSpansParams) (CreateSpansRes, error)
	// CreateUser invokes createUser operation.
	//
	// Create a new user with the specified configuration.
	//
	// POST /v1/users
	CreateUser(ctx context.Context, request *CreateUserRequestBody) (CreateUserRes, error)
	// DeleteAnnotationConfigV1AnnotationConfigsConfigIDDelete invokes delete_annotation_config_v1_annotation_configs__config_id__delete operation.
	//
	// Delete an annotation configuration.
	//
	// DELETE /v1/annotation_configs/{config_id}
	DeleteAnnotationConfigV1AnnotationConfigsConfigIDDelete(ctx context.Context, params DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteParams) (DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteRes, error)
	// DeleteDatasetById invokes deleteDatasetById operation.
	//
	// Delete dataset by ID.
	//
	// DELETE /v1/datasets/{id}
	DeleteDatasetById(ctx context.Context, params DeleteDatasetByIdParams) (DeleteDatasetByIdRes, error)
	// DeleteExperiment invokes deleteExperiment operation.
	//
	// Delete experiment by ID.
	//
	// DELETE /v1/experiments/{experiment_id}
	DeleteExperiment(ctx context.Context, params DeleteExperimentParams) (DeleteExperimentRes, error)
	// DeleteProject invokes deleteProject operation.
	//
	// Delete an existing project and all its associated data. The project identifier is either project
	// ID or project name. The default project cannot be deleted. Note: When using a project name as the
	// identifier, it cannot contain slash (/), question mark (?), or pound sign (#) characters.
	//
	// DELETE /v1/projects/{project_identifier}
	DeleteProject(ctx context.Context, params DeleteProjectParams) (DeleteProjectRes, error)
	// DeleteSpan invokes deleteSpan operation.
	//
	// Delete a single span by identifier.
	// **Important**: This operation deletes ONLY the specified span itself and does NOT
	// delete its descendants/children. All child spans will remain in the trace and
	// become orphaned (their parent_id will point to a non-existent span).
	// Behavior:
	// - Deletes only the target span (preserves all descendant spans)
	// - If this was the last span in the trace, the trace record is also deleted
	// - If the deleted span had a parent, its cumulative metrics (error count, token counts)
	// are subtracted from all ancestor spans in the chain
	// **Note**: This operation is irreversible and may create orphaned spans.
	//
	// DELETE /v1/spans/{span_identifier}
	DeleteSpan(ctx context.Context, params DeleteSpanParams) (DeleteSpanRes, error)
	// DeleteTrace invokes deleteTrace operation.
	//
	// Delete an entire trace by its identifier. The identifier can be either:
	// 1. A Relay node ID (base64-encoded)
	// 2. An OpenTelemetry trace_id (hex string)
	// This will permanently remove all spans in the trace and their associated data.
	//
	// DELETE /v1/traces/{trace_identifier}
	DeleteTrace(ctx context.Context, params DeleteTraceParams) (DeleteTraceRes, error)
	// DeleteUser invokes deleteUser operation.
	//
	// Delete an existing user by their unique GlobalID.
	//
	// DELETE /v1/users/{user_id}
	DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error)
	// GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGet invokes get_annotation_config_by_name_or_id_v1_annotation_configs__config_identifier__get operation.
	//
	// Get an annotation configuration by ID or name.
	//
	// GET /v1/annotation_configs/{config_identifier}
	GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGet(ctx context.Context, params GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetParams) (GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetRes, error)
	// GetDataset invokes getDataset operation.
	//
	// Get dataset by ID.
	//
	// GET /v1/datasets/{id}
	GetDataset(ctx context.Context, params GetDatasetParams) (GetDatasetRes, error)
	// GetDatasetCsv invokes getDatasetCsv operation.
	//
	// Download dataset examples as CSV file.
	//
	// GET /v1/datasets/{id}/csv
	GetDatasetCsv(ctx context.Context, params GetDatasetCsvParams) (GetDatasetCsvRes, error)
	// GetDatasetExamples invokes getDatasetExamples operation.
	//
	// Get examples from a dataset.
	//
	// GET /v1/datasets/{id}/examples
	GetDatasetExamples(ctx context.Context, params GetDatasetExamplesParams) (GetDatasetExamplesRes, error)
	// GetDatasetJSONLOpenAIEvals invokes getDatasetJSONLOpenAIEvals operation.
	//
	// Download dataset examples as OpenAI evals JSONL file.
	//
	// GET /v1/datasets/{id}/jsonl/openai_evals
	GetDatasetJSONLOpenAIEvals(ctx context.Context, params GetDatasetJSONLOpenAIEvalsParams) (GetDatasetJSONLOpenAIEvalsRes, error)
	// GetDatasetJSONLOpenAIFineTuning invokes getDatasetJSONLOpenAIFineTuning operation.
	//
	// Download dataset examples as OpenAI fine-tuning JSONL file.
	//
	// GET /v1/datasets/{id}/jsonl/openai_ft
	GetDatasetJSONLOpenAIFineTuning(ctx context.Context, params GetDatasetJSONLOpenAIFineTuningParams) (GetDatasetJSONLOpenAIFineTuningRes, error)
	// GetEvaluations invokes getEvaluations operation.
	//
	// Get span, trace, or document evaluations from a project.
	//
	// GET /v1/evaluations
	GetEvaluations(ctx context.Context, params GetEvaluationsParams) (GetEvaluationsRes, error)
	// GetExperiment invokes getExperiment operation.
	//
	// Get experiment by ID.
	//
	// GET /v1/experiments/{experiment_id}
	GetExperiment(ctx context.Context, params GetExperimentParams) (GetExperimentRes, error)
	// GetExperimentCSV invokes getExperimentCSV operation.
	//
	// Download experiment runs as a CSV file.
	//
	// GET /v1/experiments/{experiment_id}/csv
	GetExperimentCSV(ctx context.Context, params GetExperimentCSVParams) (GetExperimentCSVRes, error)
	// GetExperimentJSON invokes getExperimentJSON operation.
	//
	// Download experiment runs as a JSON file.
	//
	// GET /v1/experiments/{experiment_id}/json
	GetExperimentJSON(ctx context.Context, params GetExperimentJSONParams) (GetExperimentJSONRes, error)
	// GetIncompleteExperimentEvaluations invokes getIncompleteExperimentEvaluations operation.
	//
	// Get experiment runs that have incomplete evaluations.
	// Returns runs with:
	// - Missing evaluations (evaluator has not been run)
	// - Failed evaluations (evaluator ran but has errors)
	// Args:
	// experiment_id: The ID of the experiment
	// evaluation_name: List of evaluation names to check (required, at least one)
	// cursor: Cursor for pagination
	// limit: Maximum number of results to return
	// Returns:
	// Paginated list of runs with incomplete evaluations.
	//
	// GET /v1/experiments/{experiment_id}/incomplete-evaluations
	GetIncompleteExperimentEvaluations(ctx context.Context, params GetIncompleteExperimentEvaluationsParams) (GetIncompleteExperimentEvaluationsRes, error)
	// GetIncompleteExperimentRuns invokes getIncompleteExperimentRuns operation.
	//
	// Get runs that need to be completed for this experiment.
	// Returns all incomplete runs, including both missing runs (not yet attempted)
	// and failed runs (attempted but have errors).
	// Args:
	// experiment_id: The ID of the experiment
	// cursor: Cursor for pagination
	// limit: Maximum number of results to return
	// Returns:
	// Paginated list of incomplete runs grouped by dataset example,
	// with repetition numbers that need to be run.
	//
	// GET /v1/experiments/{experiment_id}/incomplete-runs
	GetIncompleteExperimentRuns(ctx context.Context, params GetIncompleteExperimentRunsParams) (GetIncompleteExperimentRunsRes, error)
	// GetProject invokes getProject operation.
	//
	// Retrieve a specific project using its unique identifier: either project ID or project name. Note:
	// When using a project name as the identifier, it cannot contain slash (/), question mark (?), or
	// pound sign (#) characters.
	//
	// GET /v1/projects/{project_identifier}
	GetProject(ctx context.Context, params GetProjectParams) (GetProjectRes, error)
	// GetProjects invokes getProjects operation.
	//
	// Retrieve a paginated list of all projects in the system.
	//
	// GET /v1/projects
	GetProjects(ctx context.Context, params GetProjectsParams) (GetProjectsRes, error)
	// GetPromptVersionByPromptVersionId invokes getPromptVersionByPromptVersionId operation.
	//
	// Retrieve a specific prompt version using its unique identifier. A prompt version contains the
	// actual template and configuration.
	//
	// GET /v1/prompt_versions/{prompt_version_id}
	GetPromptVersionByPromptVersionId(ctx context.Context, params GetPromptVersionByPromptVersionIdParams) (GetPromptVersionByPromptVersionIdRes, error)
	// GetPromptVersionByTagName invokes getPromptVersionByTagName operation.
	//
	// Retrieve a specific prompt version using its tag name. Tags are used to identify specific versions
	// of a prompt.
	//
	// GET /v1/prompts/{prompt_identifier}/tags/{tag_name}
	GetPromptVersionByTagName(ctx context.Context, params GetPromptVersionByTagNameParams) (GetPromptVersionByTagNameRes, error)
	// GetPromptVersionLatest invokes getPromptVersionLatest operation.
	//
	// Retrieve the most recent version of a specific prompt.
	//
	// GET /v1/prompts/{prompt_identifier}/latest
	GetPromptVersionLatest(ctx context.Context, params GetPromptVersionLatestParams) (GetPromptVersionLatestRes, error)
	// GetPromptVersionTags invokes getPromptVersionTags operation.
	//
	// Retrieve all tags associated with a specific prompt version. Tags are used to identify and
	// categorize different versions of a prompt.
	//
	// GET /v1/prompt_versions/{prompt_version_id}/tags
	GetPromptVersionTags(ctx context.Context, params GetPromptVersionTagsParams) (GetPromptVersionTagsRes, error)
	// GetPrompts invokes getPrompts operation.
	//
	// Retrieve a paginated list of all prompts in the system. A prompt can have multiple versions.
	//
	// GET /v1/prompts
	GetPrompts(ctx context.Context, params GetPromptsParams) (GetPromptsRes, error)
	// GetSpans invokes getSpans operation.
	//
	// Return spans within a project filtered by time range. Supports cursor-based pagination.
	//
	// GET /v1/projects/{project_identifier}/spans
	GetSpans(ctx context.Context, params GetSpansParams) (GetSpansRes, error)
	// GetUsers invokes getUsers operation.
	//
	// Retrieve a paginated list of all users in the system.
	//
	// GET /v1/users
	GetUsers(ctx context.Context, params GetUsersParams) (GetUsersRes, error)
	// ListAnnotationConfigsV1AnnotationConfigsGet invokes list_annotation_configs_v1_annotation_configs_get operation.
	//
	// Retrieve a paginated list of all annotation configurations in the system.
	//
	// GET /v1/annotation_configs
	ListAnnotationConfigsV1AnnotationConfigsGet(ctx context.Context, params ListAnnotationConfigsV1AnnotationConfigsGetParams) (ListAnnotationConfigsV1AnnotationConfigsGetRes, error)
	// ListDatasetVersionsByDatasetId invokes listDatasetVersionsByDatasetId operation.
	//
	// List dataset versions.
	//
	// GET /v1/datasets/{id}/versions
	ListDatasetVersionsByDatasetId(ctx context.Context, params ListDatasetVersionsByDatasetIdParams) (ListDatasetVersionsByDatasetIdRes, error)
	// ListDatasets invokes listDatasets operation.
	//
	// List datasets.
	//
	// GET /v1/datasets
	ListDatasets(ctx context.Context, params ListDatasetsParams) (ListDatasetsRes, error)
	// ListExperimentRuns invokes listExperimentRuns operation.
	//
	// Retrieve a paginated list of runs for an experiment.
	//
	// GET /v1/experiments/{experiment_id}/runs
	ListExperimentRuns(ctx context.Context, params ListExperimentRunsParams) (ListExperimentRunsRes, error)
	// ListExperiments invokes listExperiments operation.
	//
	// Retrieve a paginated list of experiments for the specified dataset.
	//
	// GET /v1/datasets/{dataset_id}/experiments
	ListExperiments(ctx context.Context, params ListExperimentsParams) (ListExperimentsRes, error)
	// ListPromptVersions invokes listPromptVersions operation.
	//
	// Retrieve all versions of a specific prompt with pagination support. Each prompt can have multiple
	// versions with different configurations.
	//
	// GET /v1/prompts/{prompt_identifier}/versions
	ListPromptVersions(ctx context.Context, params ListPromptVersionsParams) (ListPromptVersionsRes, error)
	// ListSessionAnnotationsBySessionIds invokes listSessionAnnotationsBySessionIds operation.
	//
	// Get session annotations for a list of session_ids.
	//
	// GET /v1/projects/{project_identifier}/session_annotations
	ListSessionAnnotationsBySessionIds(ctx context.Context, params ListSessionAnnotationsBySessionIdsParams) (ListSessionAnnotationsBySessionIdsRes, error)
	// ListSpanAnnotationsBySpanIds invokes listSpanAnnotationsBySpanIds operation.
	//
	// Get span annotations for a list of span_ids.
	//
	// GET /v1/projects/{project_identifier}/span_annotations
	ListSpanAnnotationsBySpanIds(ctx context.Context, params ListSpanAnnotationsBySpanIdsParams) (ListSpanAnnotationsBySpanIdsRes, error)
	// ListTraceAnnotationsByTraceIds invokes listTraceAnnotationsByTraceIds operation.
	//
	// Get trace annotations for a list of trace_ids.
	//
	// GET /v1/projects/{project_identifier}/trace_annotations
	ListTraceAnnotationsByTraceIds(ctx context.Context, params ListTraceAnnotationsByTraceIdsParams) (ListTraceAnnotationsByTraceIdsRes, error)
	// PostPromptVersion invokes postPromptVersion operation.
	//
	// Create a new prompt and its initial version. A prompt can have multiple versions.
	//
	// POST /v1/prompts
	PostPromptVersion(ctx context.Context, request *CreatePromptRequestBody) (PostPromptVersionRes, error)
	// UpdateAnnotationConfigV1AnnotationConfigsConfigIDPut invokes update_annotation_config_v1_annotation_configs__config_id__put operation.
	//
	// Update an annotation configuration.
	//
	// PUT /v1/annotation_configs/{config_id}
	UpdateAnnotationConfigV1AnnotationConfigsConfigIDPut(ctx context.Context, request CreateAnnotationConfigData, params UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutParams) (UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutRes, error)
	// UpdateProject invokes updateProject operation.
	//
	// Update an existing project with new configuration. Project names cannot be changed. The project
	// identifier is either project ID or project name. Note: When using a project name as the identifier,
	//  it cannot contain slash (/), question mark (?), or pound sign (#) characters.
	//
	// PUT /v1/projects/{project_identifier}
	UpdateProject(ctx context.Context, request *UpdateProjectRequestBody, params UpdateProjectParams) (UpdateProjectRes, error)
	// UploadDataset invokes uploadDataset operation.
	//
	// Upload dataset from JSON, CSV, or PyArrow.
	//
	// POST /v1/datasets/upload
	UploadDataset(ctx context.Context, request UploadDatasetReq, params UploadDatasetParams) (UploadDatasetRes, error)
	// UpsertExperimentEvaluation invokes upsertExperimentEvaluation operation.
	//
	// Create or update evaluation for an experiment run.
	//
	// POST /v1/experiment_evaluations
	UpsertExperimentEvaluation(ctx context.Context, request *UpsertExperimentEvaluationRequestBody) (UpsertExperimentEvaluationRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddEvaluations invokes addEvaluations operation.
//
// Add span, trace, or document evaluations.
//
// POST /v1/evaluations
func (c *Client) AddEvaluations(ctx context.Context, request AddEvaluationsReq, params AddEvaluationsParams) (AddEvaluationsRes, error) {
	res, err := c.sendAddEvaluations(ctx, request, params)
	return res, err
}

func (c *Client) sendAddEvaluations(ctx context.Context, request AddEvaluationsReq, params AddEvaluationsParams) (res AddEvaluationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addEvaluations"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/evaluations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddEvaluationsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/evaluations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddEvaluationsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "content-encoding",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ContentEncoding.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddEvaluationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnnotateSessions invokes annotateSessions operation.
//
// Create session annotations.
//
// POST /v1/session_annotations
func (c *Client) AnnotateSessions(ctx context.Context, request *AnnotateSessionsRequestBody, params AnnotateSessionsParams) (AnnotateSessionsRes, error) {
	res, err := c.sendAnnotateSessions(ctx, request, params)
	return res, err
}

func (c *Client) sendAnnotateSessions(ctx context.Context, request *AnnotateSessionsRequestBody, params AnnotateSessionsParams) (res AnnotateSessionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("annotateSessions"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/session_annotations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AnnotateSessionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/session_annotations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sync" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sync.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnnotateSessionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAnnotateSessionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnnotateSpanDocuments invokes annotateSpanDocuments operation.
//
// Annotate Span Documents.
//
// POST /v1/document_annotations
func (c *Client) AnnotateSpanDocuments(ctx context.Context, request *AnnotateSpanDocumentsRequestBody, params AnnotateSpanDocumentsParams) (AnnotateSpanDocumentsRes, error) {
	res, err := c.sendAnnotateSpanDocuments(ctx, request, params)
	return res, err
}

func (c *Client) sendAnnotateSpanDocuments(ctx context.Context, request *AnnotateSpanDocumentsRequestBody, params AnnotateSpanDocumentsParams) (res AnnotateSpanDocumentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("annotateSpanDocuments"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/document_annotations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AnnotateSpanDocumentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/document_annotations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sync" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sync.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnnotateSpanDocumentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAnnotateSpanDocumentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnnotateSpans invokes annotateSpans operation.
//
// Create span annotations.
//
// POST /v1/span_annotations
func (c *Client) AnnotateSpans(ctx context.Context, request *AnnotateSpansRequestBody, params AnnotateSpansParams) (AnnotateSpansRes, error) {
	res, err := c.sendAnnotateSpans(ctx, request, params)
	return res, err
}

func (c *Client) sendAnnotateSpans(ctx context.Context, request *AnnotateSpansRequestBody, params AnnotateSpansParams) (res AnnotateSpansRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("annotateSpans"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/span_annotations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AnnotateSpansOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/span_annotations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sync" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sync.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnnotateSpansRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAnnotateSpansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnnotateTraces invokes annotateTraces operation.
//
// Create trace annotations.
//
// POST /v1/trace_annotations
func (c *Client) AnnotateTraces(ctx context.Context, request *AnnotateTracesRequestBody, params AnnotateTracesParams) (AnnotateTracesRes, error) {
	res, err := c.sendAnnotateTraces(ctx, request, params)
	return res, err
}

func (c *Client) sendAnnotateTraces(ctx context.Context, request *AnnotateTracesRequestBody, params AnnotateTracesParams) (res AnnotateTracesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("annotateTraces"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/trace_annotations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AnnotateTracesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/trace_annotations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sync" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sync.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnnotateTracesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAnnotateTracesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAnnotationConfigV1AnnotationConfigsPost invokes create_annotation_config_v1_annotation_configs_post operation.
//
// Create an annotation configuration.
//
// POST /v1/annotation_configs
func (c *Client) CreateAnnotationConfigV1AnnotationConfigsPost(ctx context.Context, request CreateAnnotationConfigData) (CreateAnnotationConfigV1AnnotationConfigsPostRes, error) {
	res, err := c.sendCreateAnnotationConfigV1AnnotationConfigsPost(ctx, request)
	return res, err
}

func (c *Client) sendCreateAnnotationConfigV1AnnotationConfigsPost(ctx context.Context, request CreateAnnotationConfigData) (res CreateAnnotationConfigV1AnnotationConfigsPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_annotation_config_v1_annotation_configs_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/annotation_configs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAnnotationConfigV1AnnotationConfigsPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/annotation_configs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAnnotationConfigV1AnnotationConfigsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAnnotationConfigV1AnnotationConfigsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateExperiment invokes createExperiment operation.
//
// Create experiment on a dataset.
//
// POST /v1/datasets/{dataset_id}/experiments
func (c *Client) CreateExperiment(ctx context.Context, request *CreateExperimentRequestBody, params CreateExperimentParams) (CreateExperimentRes, error) {
	res, err := c.sendCreateExperiment(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateExperiment(ctx context.Context, request *CreateExperimentRequestBody, params CreateExperimentParams) (res CreateExperimentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createExperiment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/datasets/{dataset_id}/experiments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateExperimentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/datasets/"
	{
		// Encode "dataset_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatasetID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/experiments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateExperimentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateExperimentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateExperimentRun invokes createExperimentRun operation.
//
// Create run for an experiment.
//
// POST /v1/experiments/{experiment_id}/runs
func (c *Client) CreateExperimentRun(ctx context.Context, request *CreateExperimentRunRequestBody, params CreateExperimentRunParams) (CreateExperimentRunRes, error) {
	res, err := c.sendCreateExperimentRun(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateExperimentRun(ctx context.Context, request *CreateExperimentRunRequestBody, params CreateExperimentRunParams) (res CreateExperimentRunRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createExperimentRun"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/experiments/{experiment_id}/runs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateExperimentRunOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/experiments/"
	{
		// Encode "experiment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "experiment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExperimentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/runs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateExperimentRunRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateExperimentRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateProject invokes createProject operation.
//
// Create a new project with the specified configuration.
//
// POST /v1/projects
func (c *Client) CreateProject(ctx context.Context, request *CreateProjectRequestBody) (CreateProjectRes, error) {
	res, err := c.sendCreateProject(ctx, request)
	return res, err
}

func (c *Client) sendCreateProject(ctx context.Context, request *CreateProjectRequestBody) (res CreateProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createProject"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/projects"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreatePromptVersionTag invokes createPromptVersionTag operation.
//
// Add a new tag to a specific prompt version. Tags help identify and categorize different versions
// of a prompt.
//
// POST /v1/prompt_versions/{prompt_version_id}/tags
func (c *Client) CreatePromptVersionTag(ctx context.Context, request *PromptVersionTagData, params CreatePromptVersionTagParams) (CreatePromptVersionTagRes, error) {
	res, err := c.sendCreatePromptVersionTag(ctx, request, params)
	return res, err
}

func (c *Client) sendCreatePromptVersionTag(ctx context.Context, request *PromptVersionTagData, params CreatePromptVersionTagParams) (res CreatePromptVersionTagRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createPromptVersionTag"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/prompt_versions/{prompt_version_id}/tags"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreatePromptVersionTagOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/prompt_versions/"
	{
		// Encode "prompt_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "prompt_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PromptVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreatePromptVersionTagRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreatePromptVersionTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSpanNote invokes createSpanNote operation.
//
// Add a note annotation to a span. Notes are special annotations that allow multiple entries per
// span (unlike regular annotations which are unique by name and identifier). Each note gets a unique
// timestamp-based identifier.
//
// POST /v1/span_notes
func (c *Client) CreateSpanNote(ctx context.Context, request *CreateSpanNoteRequestBody) (CreateSpanNoteRes, error) {
	res, err := c.sendCreateSpanNote(ctx, request)
	return res, err
}

func (c *Client) sendCreateSpanNote(ctx context.Context, request *CreateSpanNoteRequestBody) (res CreateSpanNoteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createSpanNote"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/span_notes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateSpanNoteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/span_notes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSpanNoteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateSpanNoteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSpans invokes createSpans operation.
//
// Submit spans to be inserted into a project. If any spans are invalid or duplicates, no spans will
// be inserted.
//
// POST /v1/projects/{project_identifier}/spans
func (c *Client) CreateSpans(ctx context.Context, request *CreateSpansRequestBody, params CreateSpansParams) (CreateSpansRes, error) {
	res, err := c.sendCreateSpans(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateSpans(ctx context.Context, request *CreateSpansRequestBody, params CreateSpansParams) (res CreateSpansRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createSpans"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/projects/{project_identifier}/spans"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateSpansOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/projects/"
	{
		// Encode "project_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/spans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSpansRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateSpansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateUser invokes createUser operation.
//
// Create a new user with the specified configuration.
//
// POST /v1/users
func (c *Client) CreateUser(ctx context.Context, request *CreateUserRequestBody) (CreateUserRes, error) {
	res, err := c.sendCreateUser(ctx, request)
	return res, err
}

func (c *Client) sendCreateUser(ctx context.Context, request *CreateUserRequestBody) (res CreateUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createUser"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAnnotationConfigV1AnnotationConfigsConfigIDDelete invokes delete_annotation_config_v1_annotation_configs__config_id__delete operation.
//
// Delete an annotation configuration.
//
// DELETE /v1/annotation_configs/{config_id}
func (c *Client) DeleteAnnotationConfigV1AnnotationConfigsConfigIDDelete(ctx context.Context, params DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteParams) (DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteRes, error) {
	res, err := c.sendDeleteAnnotationConfigV1AnnotationConfigsConfigIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendDeleteAnnotationConfigV1AnnotationConfigsConfigIDDelete(ctx context.Context, params DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteParams) (res DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_annotation_config_v1_annotation_configs__config_id__delete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/annotation_configs/{config_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/annotation_configs/"
	{
		// Encode "config_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "config_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConfigID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAnnotationConfigV1AnnotationConfigsConfigIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDatasetById invokes deleteDatasetById operation.
//
// Delete dataset by ID.
//
// DELETE /v1/datasets/{id}
func (c *Client) DeleteDatasetById(ctx context.Context, params DeleteDatasetByIdParams) (DeleteDatasetByIdRes, error) {
	res, err := c.sendDeleteDatasetById(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDatasetById(ctx context.Context, params DeleteDatasetByIdParams) (res DeleteDatasetByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteDatasetById"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/datasets/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteDatasetByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteDatasetByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteExperiment invokes deleteExperiment operation.
//
// Delete experiment by ID.
//
// DELETE /v1/experiments/{experiment_id}
func (c *Client) DeleteExperiment(ctx context.Context, params DeleteExperimentParams) (DeleteExperimentRes, error) {
	res, err := c.sendDeleteExperiment(ctx, params)
	return res, err
}

func (c *Client) sendDeleteExperiment(ctx context.Context, params DeleteExperimentParams) (res DeleteExperimentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteExperiment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/experiments/{experiment_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteExperimentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/experiments/"
	{
		// Encode "experiment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "experiment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExperimentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteExperimentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProject invokes deleteProject operation.
//
// Delete an existing project and all its associated data. The project identifier is either project
// ID or project name. The default project cannot be deleted. Note: When using a project name as the
// identifier, it cannot contain slash (/), question mark (?), or pound sign (#) characters.
//
// DELETE /v1/projects/{project_identifier}
func (c *Client) DeleteProject(ctx context.Context, params DeleteProjectParams) (DeleteProjectRes, error) {
	res, err := c.sendDeleteProject(ctx, params)
	return res, err
}

func (c *Client) sendDeleteProject(ctx context.Context, params DeleteProjectParams) (res DeleteProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteProject"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/projects/{project_identifier}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/projects/"
	{
		// Encode "project_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSpan invokes deleteSpan operation.
//
// Delete a single span by identifier.
// **Important**: This operation deletes ONLY the specified span itself and does NOT
// delete its descendants/children. All child spans will remain in the trace and
// become orphaned (their parent_id will point to a non-existent span).
// Behavior:
// - Deletes only the target span (preserves all descendant spans)
// - If this was the last span in the trace, the trace record is also deleted
// - If the deleted span had a parent, its cumulative metrics (error count, token counts)
// are subtracted from all ancestor spans in the chain
// **Note**: This operation is irreversible and may create orphaned spans.
//
// DELETE /v1/spans/{span_identifier}
func (c *Client) DeleteSpan(ctx context.Context, params DeleteSpanParams) (DeleteSpanRes, error) {
	res, err := c.sendDeleteSpan(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSpan(ctx context.Context, params DeleteSpanParams) (res DeleteSpanRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteSpan"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/spans/{span_identifier}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteSpanOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/spans/"
	{
		// Encode "span_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "span_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SpanIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSpanResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTrace invokes deleteTrace operation.
//
// Delete an entire trace by its identifier. The identifier can be either:
// 1. A Relay node ID (base64-encoded)
// 2. An OpenTelemetry trace_id (hex string)
// This will permanently remove all spans in the trace and their associated data.
//
// DELETE /v1/traces/{trace_identifier}
func (c *Client) DeleteTrace(ctx context.Context, params DeleteTraceParams) (DeleteTraceRes, error) {
	res, err := c.sendDeleteTrace(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTrace(ctx context.Context, params DeleteTraceParams) (res DeleteTraceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteTrace"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/traces/{trace_identifier}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteTraceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/traces/"
	{
		// Encode "trace_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "trace_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TraceIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTraceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteUser invokes deleteUser operation.
//
// Delete an existing user by their unique GlobalID.
//
// DELETE /v1/users/{user_id}
func (c *Client) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	res, err := c.sendDeleteUser(ctx, params)
	return res, err
}

func (c *Client) sendDeleteUser(ctx context.Context, params DeleteUserParams) (res DeleteUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteUser"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/users/{user_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGet invokes get_annotation_config_by_name_or_id_v1_annotation_configs__config_identifier__get operation.
//
// Get an annotation configuration by ID or name.
//
// GET /v1/annotation_configs/{config_identifier}
func (c *Client) GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGet(ctx context.Context, params GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetParams) (GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetRes, error) {
	res, err := c.sendGetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGet(ctx context.Context, params GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetParams) (res GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_annotation_config_by_name_or_id_v1_annotation_configs__config_identifier__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/annotation_configs/{config_identifier}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/annotation_configs/"
	{
		// Encode "config_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "config_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConfigIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAnnotationConfigByNameOrIDV1AnnotationConfigsConfigIdentifierGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDataset invokes getDataset operation.
//
// Get dataset by ID.
//
// GET /v1/datasets/{id}
func (c *Client) GetDataset(ctx context.Context, params GetDatasetParams) (GetDatasetRes, error) {
	res, err := c.sendGetDataset(ctx, params)
	return res, err
}

func (c *Client) sendGetDataset(ctx context.Context, params GetDatasetParams) (res GetDatasetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDataset"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/datasets/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatasetCsv invokes getDatasetCsv operation.
//
// Download dataset examples as CSV file.
//
// GET /v1/datasets/{id}/csv
func (c *Client) GetDatasetCsv(ctx context.Context, params GetDatasetCsvParams) (GetDatasetCsvRes, error) {
	res, err := c.sendGetDatasetCsv(ctx, params)
	return res, err
}

func (c *Client) sendGetDatasetCsv(ctx context.Context, params GetDatasetCsvParams) (res GetDatasetCsvRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatasetCsv"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/datasets/{id}/csv"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetCsvOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/csv"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "version_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VersionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetCsvResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatasetExamples invokes getDatasetExamples operation.
//
// Get examples from a dataset.
//
// GET /v1/datasets/{id}/examples
func (c *Client) GetDatasetExamples(ctx context.Context, params GetDatasetExamplesParams) (GetDatasetExamplesRes, error) {
	res, err := c.sendGetDatasetExamples(ctx, params)
	return res, err
}

func (c *Client) sendGetDatasetExamples(ctx context.Context, params GetDatasetExamplesParams) (res GetDatasetExamplesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatasetExamples"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/datasets/{id}/examples"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetExamplesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/examples"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "version_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VersionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "split" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "split",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Split.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetExamplesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatasetJSONLOpenAIEvals invokes getDatasetJSONLOpenAIEvals operation.
//
// Download dataset examples as OpenAI evals JSONL file.
//
// GET /v1/datasets/{id}/jsonl/openai_evals
func (c *Client) GetDatasetJSONLOpenAIEvals(ctx context.Context, params GetDatasetJSONLOpenAIEvalsParams) (GetDatasetJSONLOpenAIEvalsRes, error) {
	res, err := c.sendGetDatasetJSONLOpenAIEvals(ctx, params)
	return res, err
}

func (c *Client) sendGetDatasetJSONLOpenAIEvals(ctx context.Context, params GetDatasetJSONLOpenAIEvalsParams) (res GetDatasetJSONLOpenAIEvalsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatasetJSONLOpenAIEvals"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/datasets/{id}/jsonl/openai_evals"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetJSONLOpenAIEvalsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/jsonl/openai_evals"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "version_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VersionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetJSONLOpenAIEvalsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatasetJSONLOpenAIFineTuning invokes getDatasetJSONLOpenAIFineTuning operation.
//
// Download dataset examples as OpenAI fine-tuning JSONL file.
//
// GET /v1/datasets/{id}/jsonl/openai_ft
func (c *Client) GetDatasetJSONLOpenAIFineTuning(ctx context.Context, params GetDatasetJSONLOpenAIFineTuningParams) (GetDatasetJSONLOpenAIFineTuningRes, error) {
	res, err := c.sendGetDatasetJSONLOpenAIFineTuning(ctx, params)
	return res, err
}

func (c *Client) sendGetDatasetJSONLOpenAIFineTuning(ctx context.Context, params GetDatasetJSONLOpenAIFineTuningParams) (res GetDatasetJSONLOpenAIFineTuningRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatasetJSONLOpenAIFineTuning"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/datasets/{id}/jsonl/openai_ft"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetJSONLOpenAIFineTuningOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/jsonl/openai_ft"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "version_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VersionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetJSONLOpenAIFineTuningResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEvaluations invokes getEvaluations operation.
//
// Get span, trace, or document evaluations from a project.
//
// GET /v1/evaluations
func (c *Client) GetEvaluations(ctx context.Context, params GetEvaluationsParams) (GetEvaluationsRes, error) {
	res, err := c.sendGetEvaluations(ctx, params)
	return res, err
}

func (c *Client) sendGetEvaluations(ctx context.Context, params GetEvaluationsParams) (res GetEvaluationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEvaluations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/evaluations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEvaluationsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/evaluations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEvaluationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetExperiment invokes getExperiment operation.
//
// Get experiment by ID.
//
// GET /v1/experiments/{experiment_id}
func (c *Client) GetExperiment(ctx context.Context, params GetExperimentParams) (GetExperimentRes, error) {
	res, err := c.sendGetExperiment(ctx, params)
	return res, err
}

func (c *Client) sendGetExperiment(ctx context.Context, params GetExperimentParams) (res GetExperimentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getExperiment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/experiments/{experiment_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetExperimentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/experiments/"
	{
		// Encode "experiment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "experiment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExperimentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetExperimentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetExperimentCSV invokes getExperimentCSV operation.
//
// Download experiment runs as a CSV file.
//
// GET /v1/experiments/{experiment_id}/csv
func (c *Client) GetExperimentCSV(ctx context.Context, params GetExperimentCSVParams) (GetExperimentCSVRes, error) {
	res, err := c.sendGetExperimentCSV(ctx, params)
	return res, err
}

func (c *Client) sendGetExperimentCSV(ctx context.Context, params GetExperimentCSVParams) (res GetExperimentCSVRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getExperimentCSV"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/experiments/{experiment_id}/csv"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetExperimentCSVOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/experiments/"
	{
		// Encode "experiment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "experiment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExperimentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/csv"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetExperimentCSVResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetExperimentJSON invokes getExperimentJSON operation.
//
// Download experiment runs as a JSON file.
//
// GET /v1/experiments/{experiment_id}/json
func (c *Client) GetExperimentJSON(ctx context.Context, params GetExperimentJSONParams) (GetExperimentJSONRes, error) {
	res, err := c.sendGetExperimentJSON(ctx, params)
	return res, err
}

func (c *Client) sendGetExperimentJSON(ctx context.Context, params GetExperimentJSONParams) (res GetExperimentJSONRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getExperimentJSON"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/experiments/{experiment_id}/json"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetExperimentJSONOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/experiments/"
	{
		// Encode "experiment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "experiment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExperimentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/json"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetExperimentJSONResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetIncompleteExperimentEvaluations invokes getIncompleteExperimentEvaluations operation.
//
// Get experiment runs that have incomplete evaluations.
// Returns runs with:
// - Missing evaluations (evaluator has not been run)
// - Failed evaluations (evaluator ran but has errors)
// Args:
// experiment_id: The ID of the experiment
// evaluation_name: List of evaluation names to check (required, at least one)
// cursor: Cursor for pagination
// limit: Maximum number of results to return
// Returns:
// Paginated list of runs with incomplete evaluations.
//
// GET /v1/experiments/{experiment_id}/incomplete-evaluations
func (c *Client) GetIncompleteExperimentEvaluations(ctx context.Context, params GetIncompleteExperimentEvaluationsParams) (GetIncompleteExperimentEvaluationsRes, error) {
	res, err := c.sendGetIncompleteExperimentEvaluations(ctx, params)
	return res, err
}

func (c *Client) sendGetIncompleteExperimentEvaluations(ctx context.Context, params GetIncompleteExperimentEvaluationsParams) (res GetIncompleteExperimentEvaluationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getIncompleteExperimentEvaluations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/experiments/{experiment_id}/incomplete-evaluations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetIncompleteExperimentEvaluationsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/experiments/"
	{
		// Encode "experiment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "experiment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExperimentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/incomplete-evaluations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "evaluation_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "evaluation_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.EvaluationName != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.EvaluationName {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetIncompleteExperimentEvaluationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetIncompleteExperimentRuns invokes getIncompleteExperimentRuns operation.
//
// Get runs that need to be completed for this experiment.
// Returns all incomplete runs, including both missing runs (not yet attempted)
// and failed runs (attempted but have errors).
// Args:
// experiment_id: The ID of the experiment
// cursor: Cursor for pagination
// limit: Maximum number of results to return
// Returns:
// Paginated list of incomplete runs grouped by dataset example,
// with repetition numbers that need to be run.
//
// GET /v1/experiments/{experiment_id}/incomplete-runs
func (c *Client) GetIncompleteExperimentRuns(ctx context.Context, params GetIncompleteExperimentRunsParams) (GetIncompleteExperimentRunsRes, error) {
	res, err := c.sendGetIncompleteExperimentRuns(ctx, params)
	return res, err
}

func (c *Client) sendGetIncompleteExperimentRuns(ctx context.Context, params GetIncompleteExperimentRunsParams) (res GetIncompleteExperimentRunsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getIncompleteExperimentRuns"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/experiments/{experiment_id}/incomplete-runs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetIncompleteExperimentRunsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/experiments/"
	{
		// Encode "experiment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "experiment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExperimentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/incomplete-runs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetIncompleteExperimentRunsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProject invokes getProject operation.
//
// Retrieve a specific project using its unique identifier: either project ID or project name. Note:
// When using a project name as the identifier, it cannot contain slash (/), question mark (?), or
// pound sign (#) characters.
//
// GET /v1/projects/{project_identifier}
func (c *Client) GetProject(ctx context.Context, params GetProjectParams) (GetProjectRes, error) {
	res, err := c.sendGetProject(ctx, params)
	return res, err
}

func (c *Client) sendGetProject(ctx context.Context, params GetProjectParams) (res GetProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getProject"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/projects/{project_identifier}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/projects/"
	{
		// Encode "project_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProjects invokes getProjects operation.
//
// Retrieve a paginated list of all projects in the system.
//
// GET /v1/projects
func (c *Client) GetProjects(ctx context.Context, params GetProjectsParams) (GetProjectsRes, error) {
	res, err := c.sendGetProjects(ctx, params)
	return res, err
}

func (c *Client) sendGetProjects(ctx context.Context, params GetProjectsParams) (res GetProjectsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getProjects"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/projects"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetProjectsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_experiment_projects" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_experiment_projects",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeExperimentProjects.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProjectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPromptVersionByPromptVersionId invokes getPromptVersionByPromptVersionId operation.
//
// Retrieve a specific prompt version using its unique identifier. A prompt version contains the
// actual template and configuration.
//
// GET /v1/prompt_versions/{prompt_version_id}
func (c *Client) GetPromptVersionByPromptVersionId(ctx context.Context, params GetPromptVersionByPromptVersionIdParams) (GetPromptVersionByPromptVersionIdRes, error) {
	res, err := c.sendGetPromptVersionByPromptVersionId(ctx, params)
	return res, err
}

func (c *Client) sendGetPromptVersionByPromptVersionId(ctx context.Context, params GetPromptVersionByPromptVersionIdParams) (res GetPromptVersionByPromptVersionIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPromptVersionByPromptVersionId"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/prompt_versions/{prompt_version_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPromptVersionByPromptVersionIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/prompt_versions/"
	{
		// Encode "prompt_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "prompt_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PromptVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromptVersionByPromptVersionIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPromptVersionByTagName invokes getPromptVersionByTagName operation.
//
// Retrieve a specific prompt version using its tag name. Tags are used to identify specific versions
// of a prompt.
//
// GET /v1/prompts/{prompt_identifier}/tags/{tag_name}
func (c *Client) GetPromptVersionByTagName(ctx context.Context, params GetPromptVersionByTagNameParams) (GetPromptVersionByTagNameRes, error) {
	res, err := c.sendGetPromptVersionByTagName(ctx, params)
	return res, err
}

func (c *Client) sendGetPromptVersionByTagName(ctx context.Context, params GetPromptVersionByTagNameParams) (res GetPromptVersionByTagNameRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPromptVersionByTagName"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/prompts/{prompt_identifier}/tags/{tag_name}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPromptVersionByTagNameOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/prompts/"
	{
		// Encode "prompt_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "prompt_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PromptIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags/"
	{
		// Encode "tag_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tag_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TagName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromptVersionByTagNameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPromptVersionLatest invokes getPromptVersionLatest operation.
//
// Retrieve the most recent version of a specific prompt.
//
// GET /v1/prompts/{prompt_identifier}/latest
func (c *Client) GetPromptVersionLatest(ctx context.Context, params GetPromptVersionLatestParams) (GetPromptVersionLatestRes, error) {
	res, err := c.sendGetPromptVersionLatest(ctx, params)
	return res, err
}

func (c *Client) sendGetPromptVersionLatest(ctx context.Context, params GetPromptVersionLatestParams) (res GetPromptVersionLatestRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPromptVersionLatest"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/prompts/{prompt_identifier}/latest"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPromptVersionLatestOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/prompts/"
	{
		// Encode "prompt_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "prompt_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PromptIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/latest"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromptVersionLatestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPromptVersionTags invokes getPromptVersionTags operation.
//
// Retrieve all tags associated with a specific prompt version. Tags are used to identify and
// categorize different versions of a prompt.
//
// GET /v1/prompt_versions/{prompt_version_id}/tags
func (c *Client) GetPromptVersionTags(ctx context.Context, params GetPromptVersionTagsParams) (GetPromptVersionTagsRes, error) {
	res, err := c.sendGetPromptVersionTags(ctx, params)
	return res, err
}

func (c *Client) sendGetPromptVersionTags(ctx context.Context, params GetPromptVersionTagsParams) (res GetPromptVersionTagsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPromptVersionTags"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/prompt_versions/{prompt_version_id}/tags"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPromptVersionTagsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/prompt_versions/"
	{
		// Encode "prompt_version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "prompt_version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PromptVersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromptVersionTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPrompts invokes getPrompts operation.
//
// Retrieve a paginated list of all prompts in the system. A prompt can have multiple versions.
//
// GET /v1/prompts
func (c *Client) GetPrompts(ctx context.Context, params GetPromptsParams) (GetPromptsRes, error) {
	res, err := c.sendGetPrompts(ctx, params)
	return res, err
}

func (c *Client) sendGetPrompts(ctx context.Context, params GetPromptsParams) (res GetPromptsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPrompts"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/prompts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPromptsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/prompts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromptsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpans invokes getSpans operation.
//
// Return spans within a project filtered by time range. Supports cursor-based pagination.
//
// GET /v1/projects/{project_identifier}/spans
func (c *Client) GetSpans(ctx context.Context, params GetSpansParams) (GetSpansRes, error) {
	res, err := c.sendGetSpans(ctx, params)
	return res, err
}

func (c *Client) sendGetSpans(ctx context.Context, params GetSpansParams) (res GetSpansRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSpans"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/projects/{project_identifier}/spans"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSpansOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/projects/"
	{
		// Encode "project_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/spans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUsers invokes getUsers operation.
//
// Retrieve a paginated list of all users in the system.
//
// GET /v1/users
func (c *Client) GetUsers(ctx context.Context, params GetUsersParams) (GetUsersRes, error) {
	res, err := c.sendGetUsers(ctx, params)
	return res, err
}

func (c *Client) sendGetUsers(ctx context.Context, params GetUsersParams) (res GetUsersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getUsers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetUsersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAnnotationConfigsV1AnnotationConfigsGet invokes list_annotation_configs_v1_annotation_configs_get operation.
//
// Retrieve a paginated list of all annotation configurations in the system.
//
// GET /v1/annotation_configs
func (c *Client) ListAnnotationConfigsV1AnnotationConfigsGet(ctx context.Context, params ListAnnotationConfigsV1AnnotationConfigsGetParams) (ListAnnotationConfigsV1AnnotationConfigsGetRes, error) {
	res, err := c.sendListAnnotationConfigsV1AnnotationConfigsGet(ctx, params)
	return res, err
}

func (c *Client) sendListAnnotationConfigsV1AnnotationConfigsGet(ctx context.Context, params ListAnnotationConfigsV1AnnotationConfigsGetParams) (res ListAnnotationConfigsV1AnnotationConfigsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_annotation_configs_v1_annotation_configs_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/annotation_configs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListAnnotationConfigsV1AnnotationConfigsGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/annotation_configs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAnnotationConfigsV1AnnotationConfigsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDatasetVersionsByDatasetId invokes listDatasetVersionsByDatasetId operation.
//
// List dataset versions.
//
// GET /v1/datasets/{id}/versions
func (c *Client) ListDatasetVersionsByDatasetId(ctx context.Context, params ListDatasetVersionsByDatasetIdParams) (ListDatasetVersionsByDatasetIdRes, error) {
	res, err := c.sendListDatasetVersionsByDatasetId(ctx, params)
	return res, err
}

func (c *Client) sendListDatasetVersionsByDatasetId(ctx context.Context, params ListDatasetVersionsByDatasetIdParams) (res ListDatasetVersionsByDatasetIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDatasetVersionsByDatasetId"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/datasets/{id}/versions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListDatasetVersionsByDatasetIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListDatasetVersionsByDatasetIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDatasets invokes listDatasets operation.
//
// List datasets.
//
// GET /v1/datasets
func (c *Client) ListDatasets(ctx context.Context, params ListDatasetsParams) (ListDatasetsRes, error) {
	res, err := c.sendListDatasets(ctx, params)
	return res, err
}

func (c *Client) sendListDatasets(ctx context.Context, params ListDatasetsParams) (res ListDatasetsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDatasets"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/datasets"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListDatasetsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/datasets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListDatasetsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListExperimentRuns invokes listExperimentRuns operation.
//
// Retrieve a paginated list of runs for an experiment.
//
// GET /v1/experiments/{experiment_id}/runs
func (c *Client) ListExperimentRuns(ctx context.Context, params ListExperimentRunsParams) (ListExperimentRunsRes, error) {
	res, err := c.sendListExperimentRuns(ctx, params)
	return res, err
}

func (c *Client) sendListExperimentRuns(ctx context.Context, params ListExperimentRunsParams) (res ListExperimentRunsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listExperimentRuns"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/experiments/{experiment_id}/runs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListExperimentRunsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/experiments/"
	{
		// Encode "experiment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "experiment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExperimentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/runs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListExperimentRunsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListExperiments invokes listExperiments operation.
//
// Retrieve a paginated list of experiments for the specified dataset.
//
// GET /v1/datasets/{dataset_id}/experiments
func (c *Client) ListExperiments(ctx context.Context, params ListExperimentsParams) (ListExperimentsRes, error) {
	res, err := c.sendListExperiments(ctx, params)
	return res, err
}

func (c *Client) sendListExperiments(ctx context.Context, params ListExperimentsParams) (res ListExperimentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listExperiments"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/datasets/{dataset_id}/experiments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListExperimentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/datasets/"
	{
		// Encode "dataset_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatasetID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/experiments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListExperimentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPromptVersions invokes listPromptVersions operation.
//
// Retrieve all versions of a specific prompt with pagination support. Each prompt can have multiple
// versions with different configurations.
//
// GET /v1/prompts/{prompt_identifier}/versions
func (c *Client) ListPromptVersions(ctx context.Context, params ListPromptVersionsParams) (ListPromptVersionsRes, error) {
	res, err := c.sendListPromptVersions(ctx, params)
	return res, err
}

func (c *Client) sendListPromptVersions(ctx context.Context, params ListPromptVersionsParams) (res ListPromptVersionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPromptVersions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/prompts/{prompt_identifier}/versions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListPromptVersionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/prompts/"
	{
		// Encode "prompt_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "prompt_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PromptIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListPromptVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSessionAnnotationsBySessionIds invokes listSessionAnnotationsBySessionIds operation.
//
// Get session annotations for a list of session_ids.
//
// GET /v1/projects/{project_identifier}/session_annotations
func (c *Client) ListSessionAnnotationsBySessionIds(ctx context.Context, params ListSessionAnnotationsBySessionIdsParams) (ListSessionAnnotationsBySessionIdsRes, error) {
	res, err := c.sendListSessionAnnotationsBySessionIds(ctx, params)
	return res, err
}

func (c *Client) sendListSessionAnnotationsBySessionIds(ctx context.Context, params ListSessionAnnotationsBySessionIdsParams) (res ListSessionAnnotationsBySessionIdsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listSessionAnnotationsBySessionIds"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/projects/{project_identifier}/session_annotations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListSessionAnnotationsBySessionIdsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/projects/"
	{
		// Encode "project_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/session_annotations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "session_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.SessionIds {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_annotation_names" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeAnnotationNames.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "exclude_annotation_names" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "exclude_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExcludeAnnotationNames.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListSessionAnnotationsBySessionIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListSpanAnnotationsBySpanIds invokes listSpanAnnotationsBySpanIds operation.
//
// Get span annotations for a list of span_ids.
//
// GET /v1/projects/{project_identifier}/span_annotations
func (c *Client) ListSpanAnnotationsBySpanIds(ctx context.Context, params ListSpanAnnotationsBySpanIdsParams) (ListSpanAnnotationsBySpanIdsRes, error) {
	res, err := c.sendListSpanAnnotationsBySpanIds(ctx, params)
	return res, err
}

func (c *Client) sendListSpanAnnotationsBySpanIds(ctx context.Context, params ListSpanAnnotationsBySpanIdsParams) (res ListSpanAnnotationsBySpanIdsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listSpanAnnotationsBySpanIds"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/projects/{project_identifier}/span_annotations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListSpanAnnotationsBySpanIdsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/projects/"
	{
		// Encode "project_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/span_annotations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "span_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "span_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.SpanIds {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_annotation_names" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeAnnotationNames.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "exclude_annotation_names" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "exclude_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExcludeAnnotationNames.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListSpanAnnotationsBySpanIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListTraceAnnotationsByTraceIds invokes listTraceAnnotationsByTraceIds operation.
//
// Get trace annotations for a list of trace_ids.
//
// GET /v1/projects/{project_identifier}/trace_annotations
func (c *Client) ListTraceAnnotationsByTraceIds(ctx context.Context, params ListTraceAnnotationsByTraceIdsParams) (ListTraceAnnotationsByTraceIdsRes, error) {
	res, err := c.sendListTraceAnnotationsByTraceIds(ctx, params)
	return res, err
}

func (c *Client) sendListTraceAnnotationsByTraceIds(ctx context.Context, params ListTraceAnnotationsByTraceIdsParams) (res ListTraceAnnotationsByTraceIdsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listTraceAnnotationsByTraceIds"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/projects/{project_identifier}/trace_annotations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListTraceAnnotationsByTraceIdsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/projects/"
	{
		// Encode "project_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/trace_annotations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "trace_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "trace_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.TraceIds {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_annotation_names" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeAnnotationNames.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "exclude_annotation_names" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "exclude_annotation_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExcludeAnnotationNames.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListTraceAnnotationsByTraceIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPromptVersion invokes postPromptVersion operation.
//
// Create a new prompt and its initial version. A prompt can have multiple versions.
//
// POST /v1/prompts
func (c *Client) PostPromptVersion(ctx context.Context, request *CreatePromptRequestBody) (PostPromptVersionRes, error) {
	res, err := c.sendPostPromptVersion(ctx, request)
	return res, err
}

func (c *Client) sendPostPromptVersion(ctx context.Context, request *CreatePromptRequestBody) (res PostPromptVersionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("postPromptVersion"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/prompts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PostPromptVersionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/prompts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPromptVersionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostPromptVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAnnotationConfigV1AnnotationConfigsConfigIDPut invokes update_annotation_config_v1_annotation_configs__config_id__put operation.
//
// Update an annotation configuration.
//
// PUT /v1/annotation_configs/{config_id}
func (c *Client) UpdateAnnotationConfigV1AnnotationConfigsConfigIDPut(ctx context.Context, request CreateAnnotationConfigData, params UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutParams) (UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutRes, error) {
	res, err := c.sendUpdateAnnotationConfigV1AnnotationConfigsConfigIDPut(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateAnnotationConfigV1AnnotationConfigsConfigIDPut(ctx context.Context, request CreateAnnotationConfigData, params UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutParams) (res UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_annotation_config_v1_annotation_configs__config_id__put"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/annotation_configs/{config_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateAnnotationConfigV1AnnotationConfigsConfigIDPutOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/annotation_configs/"
	{
		// Encode "config_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "config_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConfigID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAnnotationConfigV1AnnotationConfigsConfigIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAnnotationConfigV1AnnotationConfigsConfigIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateProject invokes updateProject operation.
//
// Update an existing project with new configuration. Project names cannot be changed. The project
// identifier is either project ID or project name. Note: When using a project name as the identifier,
//
//	it cannot contain slash (/), question mark (?), or pound sign (#) characters.
//
// PUT /v1/projects/{project_identifier}
func (c *Client) UpdateProject(ctx context.Context, request *UpdateProjectRequestBody, params UpdateProjectParams) (UpdateProjectRes, error) {
	res, err := c.sendUpdateProject(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateProject(ctx context.Context, request *UpdateProjectRequestBody, params UpdateProjectParams) (res UpdateProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateProject"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/projects/{project_identifier}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/projects/"
	{
		// Encode "project_identifier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_identifier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectIdentifier))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadDataset invokes uploadDataset operation.
//
// Upload dataset from JSON, CSV, or PyArrow.
//
// POST /v1/datasets/upload
func (c *Client) UploadDataset(ctx context.Context, request UploadDatasetReq, params UploadDatasetParams) (UploadDatasetRes, error) {
	res, err := c.sendUploadDataset(ctx, request, params)
	return res, err
}

func (c *Client) sendUploadDataset(ctx context.Context, request UploadDatasetReq, params UploadDatasetParams) (res UploadDatasetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("uploadDataset"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/datasets/upload"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UploadDatasetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/datasets/upload"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sync" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sync",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sync.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadDatasetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUploadDatasetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpsertExperimentEvaluation invokes upsertExperimentEvaluation operation.
//
// Create or update evaluation for an experiment run.
//
// POST /v1/experiment_evaluations
func (c *Client) UpsertExperimentEvaluation(ctx context.Context, request *UpsertExperimentEvaluationRequestBody) (UpsertExperimentEvaluationRes, error) {
	res, err := c.sendUpsertExperimentEvaluation(ctx, request)
	return res, err
}

func (c *Client) sendUpsertExperimentEvaluation(ctx context.Context, request *UpsertExperimentEvaluationRequestBody) (res UpsertExperimentEvaluationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("upsertExperimentEvaluation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/experiment_evaluations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpsertExperimentEvaluationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/experiment_evaluations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpsertExperimentEvaluationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpsertExperimentEvaluationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
