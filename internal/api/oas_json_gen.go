// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AnnotateSessionsRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotateSessionsRequestBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAnnotateSessionsRequestBody = [1]string{
	0: "data",
}

// Decode decodes AnnotateSessionsRequestBody from json.
func (s *AnnotateSessionsRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotateSessionsRequestBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]SessionAnnotationData, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SessionAnnotationData
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotateSessionsRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotateSessionsRequestBody) {
					name = jsonFieldsNameOfAnnotateSessionsRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotateSessionsRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotateSessionsRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotateSessionsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotateSessionsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAnnotateSessionsResponseBody = [1]string{
	0: "data",
}

// Decode decodes AnnotateSessionsResponseBody from json.
func (s *AnnotateSessionsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotateSessionsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]InsertedSessionAnnotation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InsertedSessionAnnotation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotateSessionsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotateSessionsResponseBody) {
					name = jsonFieldsNameOfAnnotateSessionsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotateSessionsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotateSessionsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotateSpanDocumentsRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotateSpanDocumentsRequestBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAnnotateSpanDocumentsRequestBody = [1]string{
	0: "data",
}

// Decode decodes AnnotateSpanDocumentsRequestBody from json.
func (s *AnnotateSpanDocumentsRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotateSpanDocumentsRequestBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]SpanDocumentAnnotationData, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpanDocumentAnnotationData
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotateSpanDocumentsRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotateSpanDocumentsRequestBody) {
					name = jsonFieldsNameOfAnnotateSpanDocumentsRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotateSpanDocumentsRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotateSpanDocumentsRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotateSpanDocumentsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotateSpanDocumentsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAnnotateSpanDocumentsResponseBody = [1]string{
	0: "data",
}

// Decode decodes AnnotateSpanDocumentsResponseBody from json.
func (s *AnnotateSpanDocumentsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotateSpanDocumentsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]InsertedSpanDocumentAnnotation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InsertedSpanDocumentAnnotation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotateSpanDocumentsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotateSpanDocumentsResponseBody) {
					name = jsonFieldsNameOfAnnotateSpanDocumentsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotateSpanDocumentsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotateSpanDocumentsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotateSpansRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotateSpansRequestBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAnnotateSpansRequestBody = [1]string{
	0: "data",
}

// Decode decodes AnnotateSpansRequestBody from json.
func (s *AnnotateSpansRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotateSpansRequestBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]SpanAnnotationData, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpanAnnotationData
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotateSpansRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotateSpansRequestBody) {
					name = jsonFieldsNameOfAnnotateSpansRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotateSpansRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotateSpansRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotateSpansResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotateSpansResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAnnotateSpansResponseBody = [1]string{
	0: "data",
}

// Decode decodes AnnotateSpansResponseBody from json.
func (s *AnnotateSpansResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotateSpansResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]InsertedSpanAnnotation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InsertedSpanAnnotation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotateSpansResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotateSpansResponseBody) {
					name = jsonFieldsNameOfAnnotateSpansResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotateSpansResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotateSpansResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotateTracesRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotateTracesRequestBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAnnotateTracesRequestBody = [1]string{
	0: "data",
}

// Decode decodes AnnotateTracesRequestBody from json.
func (s *AnnotateTracesRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotateTracesRequestBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]TraceAnnotationData, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TraceAnnotationData
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotateTracesRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotateTracesRequestBody) {
					name = jsonFieldsNameOfAnnotateTracesRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotateTracesRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotateTracesRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotateTracesResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotateTracesResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAnnotateTracesResponseBody = [1]string{
	0: "data",
}

// Decode decodes AnnotateTracesResponseBody from json.
func (s *AnnotateTracesResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotateTracesResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]InsertedTraceAnnotation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InsertedTraceAnnotation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotateTracesResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotateTracesResponseBody) {
					name = jsonFieldsNameOfAnnotateTracesResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotateTracesResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotateTracesResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotationResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotationResult) encodeFields(e *jx.Encoder) {
	{
		if s.Explanation.Set {
			e.FieldStart("explanation")
			s.Explanation.Encode(e)
		}
	}
	{
		if s.Label.Set {
			e.FieldStart("label")
			s.Label.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnnotationResult = [3]string{
	0: "explanation",
	1: "label",
	2: "score",
}

// Decode decodes AnnotationResult from json.
func (s *AnnotationResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotationResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "explanation":
			if err := func() error {
				s.Explanation.Reset()
				if err := s.Explanation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation\"")
			}
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotationResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotationResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotationResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoricalAnnotationConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoricalAnnotationConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("optimization_direction")
		s.OptimizationDirection.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("values")
		e.ArrStart()
		for _, elem := range s.Values {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCategoricalAnnotationConfig = [6]string{
	0: "description",
	1: "id",
	2: "name",
	3: "optimization_direction",
	4: "type",
	5: "values",
}

// Decode decodes CategoricalAnnotationConfig from json.
func (s *CategoricalAnnotationConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoricalAnnotationConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optimization_direction":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OptimizationDirection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimization_direction\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "values":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Values = make([]CategoricalAnnotationValue, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CategoricalAnnotationValue
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoricalAnnotationConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoricalAnnotationConfig) {
					name = jsonFieldsNameOfCategoricalAnnotationConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoricalAnnotationConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoricalAnnotationConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoricalAnnotationConfigData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoricalAnnotationConfigData) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("optimization_direction")
		s.OptimizationDirection.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("values")
		e.ArrStart()
		for _, elem := range s.Values {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCategoricalAnnotationConfigData = [5]string{
	0: "description",
	1: "name",
	2: "optimization_direction",
	3: "type",
	4: "values",
}

// Decode decodes CategoricalAnnotationConfigData from json.
func (s *CategoricalAnnotationConfigData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoricalAnnotationConfigData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optimization_direction":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.OptimizationDirection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimization_direction\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "values":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Values = make([]CategoricalAnnotationValue, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CategoricalAnnotationValue
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoricalAnnotationConfigData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoricalAnnotationConfigData) {
					name = jsonFieldsNameOfCategoricalAnnotationConfigData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoricalAnnotationConfigData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoricalAnnotationConfigData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CategoricalAnnotationConfigDataType as json.
func (s CategoricalAnnotationConfigDataType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CategoricalAnnotationConfigDataType from json.
func (s *CategoricalAnnotationConfigDataType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoricalAnnotationConfigDataType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CategoricalAnnotationConfigDataType(v) {
	case CategoricalAnnotationConfigDataTypeCATEGORICAL:
		*s = CategoricalAnnotationConfigDataTypeCATEGORICAL
	default:
		*s = CategoricalAnnotationConfigDataType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CategoricalAnnotationConfigDataType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoricalAnnotationConfigDataType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CategoricalAnnotationConfigType as json.
func (s CategoricalAnnotationConfigType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CategoricalAnnotationConfigType from json.
func (s *CategoricalAnnotationConfigType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoricalAnnotationConfigType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CategoricalAnnotationConfigType(v) {
	case CategoricalAnnotationConfigTypeCATEGORICAL:
		*s = CategoricalAnnotationConfigTypeCATEGORICAL
	default:
		*s = CategoricalAnnotationConfigType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CategoricalAnnotationConfigType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoricalAnnotationConfigType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoricalAnnotationValue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoricalAnnotationValue) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoricalAnnotationValue = [2]string{
	0: "label",
	1: "score",
}

// Decode decodes CategoricalAnnotationValue from json.
func (s *CategoricalAnnotationValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoricalAnnotationValue to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoricalAnnotationValue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoricalAnnotationValue) {
					name = jsonFieldsNameOfCategoricalAnnotationValue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoricalAnnotationValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoricalAnnotationValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContinuousAnnotationConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContinuousAnnotationConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.LowerBound.Set {
			e.FieldStart("lower_bound")
			s.LowerBound.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("optimization_direction")
		s.OptimizationDirection.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.UpperBound.Set {
			e.FieldStart("upper_bound")
			s.UpperBound.Encode(e)
		}
	}
}

var jsonFieldsNameOfContinuousAnnotationConfig = [7]string{
	0: "description",
	1: "id",
	2: "lower_bound",
	3: "name",
	4: "optimization_direction",
	5: "type",
	6: "upper_bound",
}

// Decode decodes ContinuousAnnotationConfig from json.
func (s *ContinuousAnnotationConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContinuousAnnotationConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "lower_bound":
			if err := func() error {
				s.LowerBound.Reset()
				if err := s.LowerBound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lower_bound\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optimization_direction":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.OptimizationDirection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimization_direction\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "upper_bound":
			if err := func() error {
				s.UpperBound.Reset()
				if err := s.UpperBound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upper_bound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContinuousAnnotationConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContinuousAnnotationConfig) {
					name = jsonFieldsNameOfContinuousAnnotationConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContinuousAnnotationConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContinuousAnnotationConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContinuousAnnotationConfigData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContinuousAnnotationConfigData) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.LowerBound.Set {
			e.FieldStart("lower_bound")
			s.LowerBound.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("optimization_direction")
		s.OptimizationDirection.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.UpperBound.Set {
			e.FieldStart("upper_bound")
			s.UpperBound.Encode(e)
		}
	}
}

var jsonFieldsNameOfContinuousAnnotationConfigData = [6]string{
	0: "description",
	1: "lower_bound",
	2: "name",
	3: "optimization_direction",
	4: "type",
	5: "upper_bound",
}

// Decode decodes ContinuousAnnotationConfigData from json.
func (s *ContinuousAnnotationConfigData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContinuousAnnotationConfigData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "lower_bound":
			if err := func() error {
				s.LowerBound.Reset()
				if err := s.LowerBound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lower_bound\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optimization_direction":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OptimizationDirection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimization_direction\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "upper_bound":
			if err := func() error {
				s.UpperBound.Reset()
				if err := s.UpperBound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upper_bound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContinuousAnnotationConfigData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContinuousAnnotationConfigData) {
					name = jsonFieldsNameOfContinuousAnnotationConfigData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContinuousAnnotationConfigData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContinuousAnnotationConfigData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContinuousAnnotationConfigDataType as json.
func (s ContinuousAnnotationConfigDataType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ContinuousAnnotationConfigDataType from json.
func (s *ContinuousAnnotationConfigDataType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContinuousAnnotationConfigDataType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ContinuousAnnotationConfigDataType(v) {
	case ContinuousAnnotationConfigDataTypeCONTINUOUS:
		*s = ContinuousAnnotationConfigDataTypeCONTINUOUS
	default:
		*s = ContinuousAnnotationConfigDataType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContinuousAnnotationConfigDataType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContinuousAnnotationConfigDataType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContinuousAnnotationConfigType as json.
func (s ContinuousAnnotationConfigType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ContinuousAnnotationConfigType from json.
func (s *ContinuousAnnotationConfigType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContinuousAnnotationConfigType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ContinuousAnnotationConfigType(v) {
	case ContinuousAnnotationConfigTypeCONTINUOUS:
		*s = ContinuousAnnotationConfigTypeCONTINUOUS
	default:
		*s = ContinuousAnnotationConfigType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContinuousAnnotationConfigType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContinuousAnnotationConfigType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAnnotationConfigData as json.
func (s CreateAnnotationConfigData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s CreateAnnotationConfigData) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CategoricalAnnotationConfigDataCreateAnnotationConfigData:
		e.FieldStart("type")
		e.Str("CATEGORICAL")
		{
			s := s.CategoricalAnnotationConfigData
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				e.FieldStart("values")
				e.ArrStart()
				for _, elem := range s.Values {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case ContinuousAnnotationConfigDataCreateAnnotationConfigData:
		e.FieldStart("type")
		e.Str("CONTINUOUS")
		{
			s := s.ContinuousAnnotationConfigData
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.LowerBound.Set {
					e.FieldStart("lower_bound")
					s.LowerBound.Encode(e)
				}
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				if s.UpperBound.Set {
					e.FieldStart("upper_bound")
					s.UpperBound.Encode(e)
				}
			}
		}
	case FreeformAnnotationConfigDataCreateAnnotationConfigData:
		e.FieldStart("type")
		e.Str("FREEFORM")
		{
			s := s.FreeformAnnotationConfigData
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	}
}

// Decode decodes CreateAnnotationConfigData from json.
func (s *CreateAnnotationConfigData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAnnotationConfigData to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "CATEGORICAL":
					s.Type = CategoricalAnnotationConfigDataCreateAnnotationConfigData
					found = true
				case "CONTINUOUS":
					s.Type = ContinuousAnnotationConfigDataCreateAnnotationConfigData
					found = true
				case "FREEFORM":
					s.Type = FreeformAnnotationConfigDataCreateAnnotationConfigData
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CategoricalAnnotationConfigDataCreateAnnotationConfigData:
		if err := s.CategoricalAnnotationConfigData.Decode(d); err != nil {
			return err
		}
	case ContinuousAnnotationConfigDataCreateAnnotationConfigData:
		if err := s.ContinuousAnnotationConfigData.Decode(d); err != nil {
			return err
		}
	case FreeformAnnotationConfigDataCreateAnnotationConfigData:
		if err := s.FreeformAnnotationConfigData.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateAnnotationConfigData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAnnotationConfigData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAnnotationConfigResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAnnotationConfigResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreateAnnotationConfigResponseBody = [1]string{
	0: "data",
}

// Decode decodes CreateAnnotationConfigResponseBody from json.
func (s *CreateAnnotationConfigResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAnnotationConfigResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAnnotationConfigResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAnnotationConfigResponseBody) {
					name = jsonFieldsNameOfCreateAnnotationConfigResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAnnotationConfigResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAnnotationConfigResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAnnotationConfigResponseBodyData as json.
func (s CreateAnnotationConfigResponseBodyData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s CreateAnnotationConfigResponseBodyData) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CategoricalAnnotationConfigCreateAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("CATEGORICAL")
		{
			s := s.CategoricalAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				e.FieldStart("values")
				e.ArrStart()
				for _, elem := range s.Values {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case ContinuousAnnotationConfigCreateAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("CONTINUOUS")
		{
			s := s.ContinuousAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				if s.LowerBound.Set {
					e.FieldStart("lower_bound")
					s.LowerBound.Encode(e)
				}
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				if s.UpperBound.Set {
					e.FieldStart("upper_bound")
					s.UpperBound.Encode(e)
				}
			}
		}
	case FreeformAnnotationConfigCreateAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("FREEFORM")
		{
			s := s.FreeformAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	}
}

// Decode decodes CreateAnnotationConfigResponseBodyData from json.
func (s *CreateAnnotationConfigResponseBodyData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAnnotationConfigResponseBodyData to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "CATEGORICAL":
					s.Type = CategoricalAnnotationConfigCreateAnnotationConfigResponseBodyData
					found = true
				case "CONTINUOUS":
					s.Type = ContinuousAnnotationConfigCreateAnnotationConfigResponseBodyData
					found = true
				case "FREEFORM":
					s.Type = FreeformAnnotationConfigCreateAnnotationConfigResponseBodyData
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CategoricalAnnotationConfigCreateAnnotationConfigResponseBodyData:
		if err := s.CategoricalAnnotationConfig.Decode(d); err != nil {
			return err
		}
	case ContinuousAnnotationConfigCreateAnnotationConfigResponseBodyData:
		if err := s.ContinuousAnnotationConfig.Decode(d); err != nil {
			return err
		}
	case FreeformAnnotationConfigCreateAnnotationConfigResponseBodyData:
		if err := s.FreeformAnnotationConfig.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateAnnotationConfigResponseBodyData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAnnotationConfigResponseBodyData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateExperimentRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateExperimentRequestBody) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Repetitions.Set {
			e.FieldStart("repetitions")
			s.Repetitions.Encode(e)
		}
	}
	{
		if s.Splits.Set {
			e.FieldStart("splits")
			s.Splits.Encode(e)
		}
	}
	{
		if s.VersionID.Set {
			e.FieldStart("version_id")
			s.VersionID.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateExperimentRequestBody = [6]string{
	0: "description",
	1: "metadata",
	2: "name",
	3: "repetitions",
	4: "splits",
	5: "version_id",
}

// Decode decodes CreateExperimentRequestBody from json.
func (s *CreateExperimentRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExperimentRequestBody to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "repetitions":
			if err := func() error {
				s.Repetitions.Reset()
				if err := s.Repetitions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repetitions\"")
			}
		case "splits":
			if err := func() error {
				s.Splits.Reset()
				if err := s.Splits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"splits\"")
			}
		case "version_id":
			if err := func() error {
				s.VersionID.Reset()
				if err := s.VersionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExperimentRequestBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateExperimentRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExperimentRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CreateExperimentRequestBodyMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CreateExperimentRequestBodyMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes CreateExperimentRequestBodyMetadata from json.
func (s *CreateExperimentRequestBodyMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExperimentRequestBodyMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExperimentRequestBodyMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateExperimentRequestBodyMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExperimentRequestBodyMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateExperimentResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateExperimentResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreateExperimentResponseBody = [1]string{
	0: "data",
}

// Decode decodes CreateExperimentResponseBody from json.
func (s *CreateExperimentResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExperimentResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExperimentResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateExperimentResponseBody) {
					name = jsonFieldsNameOfCreateExperimentResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateExperimentResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExperimentResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateExperimentRunRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateExperimentRunRequestBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataset_example_id")
		e.Str(s.DatasetExampleID)
	}
	{
		e.FieldStart("end_time")
		json.EncodeDateTime(e, s.EndTime)
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if len(s.Output) != 0 {
			e.FieldStart("output")
			e.Raw(s.Output)
		}
	}
	{
		e.FieldStart("repetition_number")
		e.Int(s.RepetitionNumber)
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.TraceID.Set {
			e.FieldStart("trace_id")
			s.TraceID.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateExperimentRunRequestBody = [7]string{
	0: "dataset_example_id",
	1: "end_time",
	2: "error",
	3: "output",
	4: "repetition_number",
	5: "start_time",
	6: "trace_id",
}

// Decode decodes CreateExperimentRunRequestBody from json.
func (s *CreateExperimentRunRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExperimentRunRequestBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_example_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatasetExampleID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_example_id\"")
			}
		case "end_time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.EndTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "output":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Output = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "repetition_number":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.RepetitionNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repetition_number\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "trace_id":
			if err := func() error {
				s.TraceID.Reset()
				if err := s.TraceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExperimentRunRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateExperimentRunRequestBody) {
					name = jsonFieldsNameOfCreateExperimentRunRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateExperimentRunRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExperimentRunRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateExperimentRunResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateExperimentRunResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreateExperimentRunResponseBody = [1]string{
	0: "data",
}

// Decode decodes CreateExperimentRunResponseBody from json.
func (s *CreateExperimentRunResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExperimentRunResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExperimentRunResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateExperimentRunResponseBody) {
					name = jsonFieldsNameOfCreateExperimentRunResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateExperimentRunResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExperimentRunResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateExperimentRunResponseBodyData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateExperimentRunResponseBodyData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfCreateExperimentRunResponseBodyData = [1]string{
	0: "id",
}

// Decode decodes CreateExperimentRunResponseBodyData from json.
func (s *CreateExperimentRunResponseBodyData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExperimentRunResponseBodyData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExperimentRunResponseBodyData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateExperimentRunResponseBodyData) {
					name = jsonFieldsNameOfCreateExperimentRunResponseBodyData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateExperimentRunResponseBodyData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExperimentRunResponseBodyData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateProjectRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateProjectRequestBody) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfCreateProjectRequestBody = [2]string{
	0: "description",
	1: "name",
}

// Decode decodes CreateProjectRequestBody from json.
func (s *CreateProjectRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateProjectRequestBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateProjectRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateProjectRequestBody) {
					name = jsonFieldsNameOfCreateProjectRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateProjectRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateProjectRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateProjectResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateProjectResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreateProjectResponseBody = [1]string{
	0: "data",
}

// Decode decodes CreateProjectResponseBody from json.
func (s *CreateProjectResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateProjectResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateProjectResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateProjectResponseBody) {
					name = jsonFieldsNameOfCreateProjectResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateProjectResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateProjectResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatePromptRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatePromptRequestBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("prompt")
		s.Prompt.Encode(e)
	}
	{
		e.FieldStart("version")
		s.Version.Encode(e)
	}
}

var jsonFieldsNameOfCreatePromptRequestBody = [2]string{
	0: "prompt",
	1: "version",
}

// Decode decodes CreatePromptRequestBody from json.
func (s *CreatePromptRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePromptRequestBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "prompt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Prompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatePromptRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePromptRequestBody) {
					name = jsonFieldsNameOfCreatePromptRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePromptRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePromptRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatePromptResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatePromptResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreatePromptResponseBody = [1]string{
	0: "data",
}

// Decode decodes CreatePromptResponseBody from json.
func (s *CreatePromptResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePromptResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatePromptResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePromptResponseBody) {
					name = jsonFieldsNameOfCreatePromptResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePromptResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePromptResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSpanNoteRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSpanNoteRequestBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreateSpanNoteRequestBody = [1]string{
	0: "data",
}

// Decode decodes CreateSpanNoteRequestBody from json.
func (s *CreateSpanNoteRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpanNoteRequestBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSpanNoteRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSpanNoteRequestBody) {
					name = jsonFieldsNameOfCreateSpanNoteRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSpanNoteRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpanNoteRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSpanNoteResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSpanNoteResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreateSpanNoteResponseBody = [1]string{
	0: "data",
}

// Decode decodes CreateSpanNoteResponseBody from json.
func (s *CreateSpanNoteResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpanNoteResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSpanNoteResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSpanNoteResponseBody) {
					name = jsonFieldsNameOfCreateSpanNoteResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSpanNoteResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpanNoteResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSpansRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSpansRequestBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateSpansRequestBody = [1]string{
	0: "data",
}

// Decode decodes CreateSpansRequestBody from json.
func (s *CreateSpansRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpansRequestBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]Span, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Span
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSpansRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSpansRequestBody) {
					name = jsonFieldsNameOfCreateSpansRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSpansRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpansRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSpansResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSpansResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_queued")
		e.Int(s.TotalQueued)
	}
	{
		e.FieldStart("total_received")
		e.Int(s.TotalReceived)
	}
}

var jsonFieldsNameOfCreateSpansResponseBody = [2]string{
	0: "total_queued",
	1: "total_received",
}

// Decode decodes CreateSpansResponseBody from json.
func (s *CreateSpansResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpansResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_queued":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalQueued = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_queued\"")
			}
		case "total_received":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalReceived = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_received\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSpansResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSpansResponseBody) {
					name = jsonFieldsNameOfCreateSpansResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSpansResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpansResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserRequestBody) encodeFields(e *jx.Encoder) {
	{
		if s.SendWelcomeEmail.Set {
			e.FieldStart("send_welcome_email")
			s.SendWelcomeEmail.Encode(e)
		}
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfCreateUserRequestBody = [2]string{
	0: "send_welcome_email",
	1: "user",
}

// Decode decodes CreateUserRequestBody from json.
func (s *CreateUserRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequestBody to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "send_welcome_email":
			if err := func() error {
				s.SendWelcomeEmail.Reset()
				if err := s.SendWelcomeEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_welcome_email\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserRequestBody) {
					name = jsonFieldsNameOfCreateUserRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestBodyUser as json.
func (s CreateUserRequestBodyUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s CreateUserRequestBodyUser) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case LocalUserDataCreateUserRequestBodyUser:
		e.FieldStart("auth_method")
		e.Str("LOCAL")
		{
			s := s.LocalUserData
			{
				e.FieldStart("email")
				e.Str(s.Email)
			}
			{
				if s.Password.Set {
					e.FieldStart("password")
					s.Password.Encode(e)
				}
			}
			{
				e.FieldStart("role")
				s.Role.Encode(e)
			}
			{
				e.FieldStart("username")
				e.Str(s.Username)
			}
		}
	case OAuth2UserDataCreateUserRequestBodyUser:
		e.FieldStart("auth_method")
		e.Str("OAUTH2")
		{
			s := s.OAuth2UserData
			{
				e.FieldStart("email")
				e.Str(s.Email)
			}
			{
				if s.OAuth2ClientID.Set {
					e.FieldStart("oauth2_client_id")
					s.OAuth2ClientID.Encode(e)
				}
			}
			{
				if s.OAuth2UserID.Set {
					e.FieldStart("oauth2_user_id")
					s.OAuth2UserID.Encode(e)
				}
			}
			{
				e.FieldStart("role")
				s.Role.Encode(e)
			}
			{
				e.FieldStart("username")
				e.Str(s.Username)
			}
		}
	case LDAPUserDataCreateUserRequestBodyUser:
		e.FieldStart("auth_method")
		e.Str("LDAP")
		{
			s := s.LDAPUserData
			{
				e.FieldStart("email")
				e.Str(s.Email)
			}
			{
				e.FieldStart("role")
				s.Role.Encode(e)
			}
			{
				e.FieldStart("username")
				e.Str(s.Username)
			}
		}
	}
}

// Decode decodes CreateUserRequestBodyUser from json.
func (s *CreateUserRequestBodyUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequestBodyUser to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "auth_method":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "LOCAL":
					s.Type = LocalUserDataCreateUserRequestBodyUser
					found = true
				case "OAUTH2":
					s.Type = OAuth2UserDataCreateUserRequestBodyUser
					found = true
				case "LDAP":
					s.Type = LDAPUserDataCreateUserRequestBodyUser
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case LocalUserDataCreateUserRequestBodyUser:
		if err := s.LocalUserData.Decode(d); err != nil {
			return err
		}
	case OAuth2UserDataCreateUserRequestBodyUser:
		if err := s.OAuth2UserData.Decode(d); err != nil {
			return err
		}
	case LDAPUserDataCreateUserRequestBodyUser:
		if err := s.LDAPUserData.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserRequestBodyUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequestBodyUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreateUserResponseBody = [1]string{
	0: "data",
}

// Decode decodes CreateUserResponseBody from json.
func (s *CreateUserResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserResponseBody) {
					name = jsonFieldsNameOfCreateUserResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserResponseBodyData as json.
func (s CreateUserResponseBodyData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s CreateUserResponseBodyData) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case LocalUserCreateUserResponseBodyData:
		e.FieldStart("auth_method")
		e.Str("LOCAL")
		{
			s := s.LocalUser
			{
				e.FieldStart("created_at")
				json.EncodeDateTime(e, s.CreatedAt)
			}
			{
				e.FieldStart("email")
				e.Str(s.Email)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				if s.Password.Set {
					e.FieldStart("password")
					s.Password.Encode(e)
				}
			}
			{
				e.FieldStart("password_needs_reset")
				e.Bool(s.PasswordNeedsReset)
			}
			{
				e.FieldStart("role")
				s.Role.Encode(e)
			}
			{
				e.FieldStart("updated_at")
				json.EncodeDateTime(e, s.UpdatedAt)
			}
			{
				e.FieldStart("username")
				e.Str(s.Username)
			}
		}
	case OAuth2UserCreateUserResponseBodyData:
		e.FieldStart("auth_method")
		e.Str("OAUTH2")
		{
			s := s.OAuth2User
			{
				e.FieldStart("created_at")
				json.EncodeDateTime(e, s.CreatedAt)
			}
			{
				e.FieldStart("email")
				e.Str(s.Email)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				if s.OAuth2ClientID.Set {
					e.FieldStart("oauth2_client_id")
					s.OAuth2ClientID.Encode(e)
				}
			}
			{
				if s.OAuth2UserID.Set {
					e.FieldStart("oauth2_user_id")
					s.OAuth2UserID.Encode(e)
				}
			}
			{
				if s.ProfilePictureURL.Set {
					e.FieldStart("profile_picture_url")
					s.ProfilePictureURL.Encode(e)
				}
			}
			{
				e.FieldStart("role")
				s.Role.Encode(e)
			}
			{
				e.FieldStart("updated_at")
				json.EncodeDateTime(e, s.UpdatedAt)
			}
			{
				e.FieldStart("username")
				e.Str(s.Username)
			}
		}
	case LDAPUserCreateUserResponseBodyData:
		e.FieldStart("auth_method")
		e.Str("LDAP")
		{
			s := s.LDAPUser
			{
				e.FieldStart("created_at")
				json.EncodeDateTime(e, s.CreatedAt)
			}
			{
				e.FieldStart("email")
				e.Str(s.Email)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("role")
				s.Role.Encode(e)
			}
			{
				e.FieldStart("updated_at")
				json.EncodeDateTime(e, s.UpdatedAt)
			}
			{
				e.FieldStart("username")
				e.Str(s.Username)
			}
		}
	}
}

// Decode decodes CreateUserResponseBodyData from json.
func (s *CreateUserResponseBodyData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserResponseBodyData to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "auth_method":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "LOCAL":
					s.Type = LocalUserCreateUserResponseBodyData
					found = true
				case "OAUTH2":
					s.Type = OAuth2UserCreateUserResponseBodyData
					found = true
				case "LDAP":
					s.Type = LDAPUserCreateUserResponseBodyData
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case LocalUserCreateUserResponseBodyData:
		if err := s.LocalUser.Decode(d); err != nil {
			return err
		}
	case OAuth2UserCreateUserResponseBodyData:
		if err := s.OAuth2User.Decode(d); err != nil {
			return err
		}
	case LDAPUserCreateUserResponseBodyData:
		if err := s.LDAPUser.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserResponseBodyData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserResponseBodyData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Dataset) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Dataset) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("example_count")
		e.Int(s.ExampleCount)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfDataset = [7]string{
	0: "created_at",
	1: "description",
	2: "example_count",
	3: "id",
	4: "metadata",
	5: "name",
	6: "updated_at",
}

// Decode decodes Dataset from json.
func (s *Dataset) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Dataset to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "example_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ExampleCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example_count\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Dataset")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataset) {
					name = jsonFieldsNameOfDataset[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Dataset) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Dataset) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetExample) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetExample) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfDatasetExample = [5]string{
	0: "id",
	1: "input",
	2: "metadata",
	3: "output",
	4: "updated_at",
}

// Decode decodes DatasetExample from json.
func (s *DatasetExample) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetExample to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "input":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "output":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetExample")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetExample) {
					name = jsonFieldsNameOfDatasetExample[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetExample) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetExample) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatasetExampleInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatasetExampleInput) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DatasetExampleInput from json.
func (s *DatasetExampleInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetExampleInput to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetExampleInput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetExampleInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetExampleInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatasetExampleMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatasetExampleMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DatasetExampleMetadata from json.
func (s *DatasetExampleMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetExampleMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetExampleMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetExampleMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetExampleMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatasetExampleOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatasetExampleOutput) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DatasetExampleOutput from json.
func (s *DatasetExampleOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetExampleOutput to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetExampleOutput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetExampleOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetExampleOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatasetMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatasetMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DatasetMetadata from json.
func (s *DatasetMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetVersion) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("version_id")
		e.Str(s.VersionID)
	}
}

var jsonFieldsNameOfDatasetVersion = [4]string{
	0: "created_at",
	1: "description",
	2: "metadata",
	3: "version_id",
}

// Decode decodes DatasetVersion from json.
func (s *DatasetVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "version_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VersionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetVersion) {
					name = jsonFieldsNameOfDatasetVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatasetVersionMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatasetVersionMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DatasetVersionMetadata from json.
func (s *DatasetVersionMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetVersionMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetWithExampleCount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetWithExampleCount) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("example_count")
		e.Int(s.ExampleCount)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfDatasetWithExampleCount = [7]string{
	0: "created_at",
	1: "description",
	2: "example_count",
	3: "id",
	4: "metadata",
	5: "name",
	6: "updated_at",
}

// Decode decodes DatasetWithExampleCount from json.
func (s *DatasetWithExampleCount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetWithExampleCount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "example_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ExampleCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example_count\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetWithExampleCount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetWithExampleCount) {
					name = jsonFieldsNameOfDatasetWithExampleCount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetWithExampleCount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetWithExampleCount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatasetWithExampleCountMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatasetWithExampleCountMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DatasetWithExampleCountMetadata from json.
func (s *DatasetWithExampleCountMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetWithExampleCountMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetWithExampleCountMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetWithExampleCountMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetWithExampleCountMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteAnnotationConfigResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteAnnotationConfigResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfDeleteAnnotationConfigResponseBody = [1]string{
	0: "data",
}

// Decode decodes DeleteAnnotationConfigResponseBody from json.
func (s *DeleteAnnotationConfigResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAnnotationConfigResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteAnnotationConfigResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteAnnotationConfigResponseBody) {
					name = jsonFieldsNameOfDeleteAnnotationConfigResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAnnotationConfigResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAnnotationConfigResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteAnnotationConfigResponseBodyData as json.
func (s DeleteAnnotationConfigResponseBodyData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s DeleteAnnotationConfigResponseBodyData) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CategoricalAnnotationConfigDeleteAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("CATEGORICAL")
		{
			s := s.CategoricalAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				e.FieldStart("values")
				e.ArrStart()
				for _, elem := range s.Values {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case ContinuousAnnotationConfigDeleteAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("CONTINUOUS")
		{
			s := s.ContinuousAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				if s.LowerBound.Set {
					e.FieldStart("lower_bound")
					s.LowerBound.Encode(e)
				}
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				if s.UpperBound.Set {
					e.FieldStart("upper_bound")
					s.UpperBound.Encode(e)
				}
			}
		}
	case FreeformAnnotationConfigDeleteAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("FREEFORM")
		{
			s := s.FreeformAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	}
}

// Decode decodes DeleteAnnotationConfigResponseBodyData from json.
func (s *DeleteAnnotationConfigResponseBodyData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAnnotationConfigResponseBodyData to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "CATEGORICAL":
					s.Type = CategoricalAnnotationConfigDeleteAnnotationConfigResponseBodyData
					found = true
				case "CONTINUOUS":
					s.Type = ContinuousAnnotationConfigDeleteAnnotationConfigResponseBodyData
					found = true
				case "FREEFORM":
					s.Type = FreeformAnnotationConfigDeleteAnnotationConfigResponseBodyData
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CategoricalAnnotationConfigDeleteAnnotationConfigResponseBodyData:
		if err := s.CategoricalAnnotationConfig.Decode(d); err != nil {
			return err
		}
	case ContinuousAnnotationConfigDeleteAnnotationConfigResponseBodyData:
		if err := s.ContinuousAnnotationConfig.Decode(d); err != nil {
			return err
		}
	case FreeformAnnotationConfigDeleteAnnotationConfigResponseBodyData:
		if err := s.FreeformAnnotationConfig.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteAnnotationConfigResponseBodyData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAnnotationConfigResponseBodyData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Experiment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Experiment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("dataset_id")
		e.Str(s.DatasetID)
	}
	{
		e.FieldStart("dataset_version_id")
		e.Str(s.DatasetVersionID)
	}
	{
		e.FieldStart("example_count")
		e.Int(s.ExampleCount)
	}
	{
		e.FieldStart("failed_run_count")
		e.Int(s.FailedRunCount)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("missing_run_count")
		e.Int(s.MissingRunCount)
	}
	{
		e.FieldStart("project_name")
		s.ProjectName.Encode(e)
	}
	{
		e.FieldStart("repetitions")
		e.Int(s.Repetitions)
	}
	{
		e.FieldStart("successful_run_count")
		e.Int(s.SuccessfulRunCount)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfExperiment = [12]string{
	0:  "created_at",
	1:  "dataset_id",
	2:  "dataset_version_id",
	3:  "example_count",
	4:  "failed_run_count",
	5:  "id",
	6:  "metadata",
	7:  "missing_run_count",
	8:  "project_name",
	9:  "repetitions",
	10: "successful_run_count",
	11: "updated_at",
}

// Decode decodes Experiment from json.
func (s *Experiment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Experiment to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "dataset_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DatasetID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_id\"")
			}
		case "dataset_version_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DatasetVersionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_version_id\"")
			}
		case "example_count":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ExampleCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example_count\"")
			}
		case "failed_run_count":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.FailedRunCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_run_count\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "missing_run_count":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.MissingRunCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"missing_run_count\"")
			}
		case "project_name":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "repetitions":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Repetitions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repetitions\"")
			}
		case "successful_run_count":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.SuccessfulRunCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successful_run_count\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Experiment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperiment) {
					name = jsonFieldsNameOfExperiment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Experiment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Experiment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentEvaluationResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentEvaluationResult) encodeFields(e *jx.Encoder) {
	{
		if s.Explanation.Set {
			e.FieldStart("explanation")
			s.Explanation.Encode(e)
		}
	}
	{
		if s.Label.Set {
			e.FieldStart("label")
			s.Label.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
}

var jsonFieldsNameOfExperimentEvaluationResult = [3]string{
	0: "explanation",
	1: "label",
	2: "score",
}

// Decode decodes ExperimentEvaluationResult from json.
func (s *ExperimentEvaluationResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentEvaluationResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "explanation":
			if err := func() error {
				s.Explanation.Reset()
				if err := s.Explanation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation\"")
			}
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentEvaluationResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentEvaluationResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentEvaluationResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExperimentMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExperimentMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ExperimentMetadata from json.
func (s *ExperimentMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentRun) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentRun) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataset_example_id")
		e.Str(s.DatasetExampleID)
	}
	{
		e.FieldStart("end_time")
		json.EncodeDateTime(e, s.EndTime)
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		e.FieldStart("experiment_id")
		e.Str(s.ExperimentID)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if len(s.Output) != 0 {
			e.FieldStart("output")
			e.Raw(s.Output)
		}
	}
	{
		e.FieldStart("repetition_number")
		e.Int(s.RepetitionNumber)
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.TraceID.Set {
			e.FieldStart("trace_id")
			s.TraceID.Encode(e)
		}
	}
}

var jsonFieldsNameOfExperimentRun = [9]string{
	0: "dataset_example_id",
	1: "end_time",
	2: "error",
	3: "experiment_id",
	4: "id",
	5: "output",
	6: "repetition_number",
	7: "start_time",
	8: "trace_id",
}

// Decode decodes ExperimentRun from json.
func (s *ExperimentRun) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentRun to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_example_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatasetExampleID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_example_id\"")
			}
		case "end_time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.EndTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "experiment_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ExperimentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_id\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "output":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Output = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "repetition_number":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.RepetitionNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repetition_number\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "trace_id":
			if err := func() error {
				s.TraceID.Reset()
				if err := s.TraceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentRun")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentRun) {
					name = jsonFieldsNameOfExperimentRun[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentRun) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentRun) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FreeformAnnotationConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FreeformAnnotationConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfFreeformAnnotationConfig = [4]string{
	0: "description",
	1: "id",
	2: "name",
	3: "type",
}

// Decode decodes FreeformAnnotationConfig from json.
func (s *FreeformAnnotationConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FreeformAnnotationConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FreeformAnnotationConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFreeformAnnotationConfig) {
					name = jsonFieldsNameOfFreeformAnnotationConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FreeformAnnotationConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FreeformAnnotationConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FreeformAnnotationConfigData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FreeformAnnotationConfigData) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfFreeformAnnotationConfigData = [3]string{
	0: "description",
	1: "name",
	2: "type",
}

// Decode decodes FreeformAnnotationConfigData from json.
func (s *FreeformAnnotationConfigData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FreeformAnnotationConfigData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FreeformAnnotationConfigData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFreeformAnnotationConfigData) {
					name = jsonFieldsNameOfFreeformAnnotationConfigData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FreeformAnnotationConfigData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FreeformAnnotationConfigData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FreeformAnnotationConfigDataType as json.
func (s FreeformAnnotationConfigDataType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FreeformAnnotationConfigDataType from json.
func (s *FreeformAnnotationConfigDataType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FreeformAnnotationConfigDataType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FreeformAnnotationConfigDataType(v) {
	case FreeformAnnotationConfigDataTypeFREEFORM:
		*s = FreeformAnnotationConfigDataTypeFREEFORM
	default:
		*s = FreeformAnnotationConfigDataType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FreeformAnnotationConfigDataType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FreeformAnnotationConfigDataType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FreeformAnnotationConfigType as json.
func (s FreeformAnnotationConfigType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FreeformAnnotationConfigType from json.
func (s *FreeformAnnotationConfigType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FreeformAnnotationConfigType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FreeformAnnotationConfigType(v) {
	case FreeformAnnotationConfigTypeFREEFORM:
		*s = FreeformAnnotationConfigTypeFREEFORM
	default:
		*s = FreeformAnnotationConfigType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FreeformAnnotationConfigType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FreeformAnnotationConfigType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAnnotationConfigResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAnnotationConfigResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGetAnnotationConfigResponseBody = [1]string{
	0: "data",
}

// Decode decodes GetAnnotationConfigResponseBody from json.
func (s *GetAnnotationConfigResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAnnotationConfigResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAnnotationConfigResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAnnotationConfigResponseBody) {
					name = jsonFieldsNameOfGetAnnotationConfigResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAnnotationConfigResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAnnotationConfigResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAnnotationConfigResponseBodyData as json.
func (s GetAnnotationConfigResponseBodyData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetAnnotationConfigResponseBodyData) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CategoricalAnnotationConfigGetAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("CATEGORICAL")
		{
			s := s.CategoricalAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				e.FieldStart("values")
				e.ArrStart()
				for _, elem := range s.Values {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case ContinuousAnnotationConfigGetAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("CONTINUOUS")
		{
			s := s.ContinuousAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				if s.LowerBound.Set {
					e.FieldStart("lower_bound")
					s.LowerBound.Encode(e)
				}
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				if s.UpperBound.Set {
					e.FieldStart("upper_bound")
					s.UpperBound.Encode(e)
				}
			}
		}
	case FreeformAnnotationConfigGetAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("FREEFORM")
		{
			s := s.FreeformAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	}
}

// Decode decodes GetAnnotationConfigResponseBodyData from json.
func (s *GetAnnotationConfigResponseBodyData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAnnotationConfigResponseBodyData to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "CATEGORICAL":
					s.Type = CategoricalAnnotationConfigGetAnnotationConfigResponseBodyData
					found = true
				case "CONTINUOUS":
					s.Type = ContinuousAnnotationConfigGetAnnotationConfigResponseBodyData
					found = true
				case "FREEFORM":
					s.Type = FreeformAnnotationConfigGetAnnotationConfigResponseBodyData
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CategoricalAnnotationConfigGetAnnotationConfigResponseBodyData:
		if err := s.CategoricalAnnotationConfig.Decode(d); err != nil {
			return err
		}
	case ContinuousAnnotationConfigGetAnnotationConfigResponseBodyData:
		if err := s.ContinuousAnnotationConfig.Decode(d); err != nil {
			return err
		}
	case FreeformAnnotationConfigGetAnnotationConfigResponseBodyData:
		if err := s.FreeformAnnotationConfig.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAnnotationConfigResponseBodyData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAnnotationConfigResponseBodyData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAnnotationConfigsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAnnotationConfigsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfGetAnnotationConfigsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes GetAnnotationConfigsResponseBody from json.
func (s *GetAnnotationConfigsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAnnotationConfigsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]GetAnnotationConfigsResponseBodyDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAnnotationConfigsResponseBodyDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAnnotationConfigsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAnnotationConfigsResponseBody) {
					name = jsonFieldsNameOfGetAnnotationConfigsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAnnotationConfigsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAnnotationConfigsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAnnotationConfigsResponseBodyDataItem as json.
func (s GetAnnotationConfigsResponseBodyDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetAnnotationConfigsResponseBodyDataItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CategoricalAnnotationConfigGetAnnotationConfigsResponseBodyDataItem:
		e.FieldStart("type")
		e.Str("CATEGORICAL")
		{
			s := s.CategoricalAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				e.FieldStart("values")
				e.ArrStart()
				for _, elem := range s.Values {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case ContinuousAnnotationConfigGetAnnotationConfigsResponseBodyDataItem:
		e.FieldStart("type")
		e.Str("CONTINUOUS")
		{
			s := s.ContinuousAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				if s.LowerBound.Set {
					e.FieldStart("lower_bound")
					s.LowerBound.Encode(e)
				}
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				if s.UpperBound.Set {
					e.FieldStart("upper_bound")
					s.UpperBound.Encode(e)
				}
			}
		}
	case FreeformAnnotationConfigGetAnnotationConfigsResponseBodyDataItem:
		e.FieldStart("type")
		e.Str("FREEFORM")
		{
			s := s.FreeformAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	}
}

// Decode decodes GetAnnotationConfigsResponseBodyDataItem from json.
func (s *GetAnnotationConfigsResponseBodyDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAnnotationConfigsResponseBodyDataItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "CATEGORICAL":
					s.Type = CategoricalAnnotationConfigGetAnnotationConfigsResponseBodyDataItem
					found = true
				case "CONTINUOUS":
					s.Type = ContinuousAnnotationConfigGetAnnotationConfigsResponseBodyDataItem
					found = true
				case "FREEFORM":
					s.Type = FreeformAnnotationConfigGetAnnotationConfigsResponseBodyDataItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CategoricalAnnotationConfigGetAnnotationConfigsResponseBodyDataItem:
		if err := s.CategoricalAnnotationConfig.Decode(d); err != nil {
			return err
		}
	case ContinuousAnnotationConfigGetAnnotationConfigsResponseBodyDataItem:
		if err := s.ContinuousAnnotationConfig.Decode(d); err != nil {
			return err
		}
	case FreeformAnnotationConfigGetAnnotationConfigsResponseBodyDataItem:
		if err := s.FreeformAnnotationConfig.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAnnotationConfigsResponseBodyDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAnnotationConfigsResponseBodyDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDatasetResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDatasetResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGetDatasetResponseBody = [1]string{
	0: "data",
}

// Decode decodes GetDatasetResponseBody from json.
func (s *GetDatasetResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDatasetResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDatasetResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetDatasetResponseBody) {
					name = jsonFieldsNameOfGetDatasetResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDatasetResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDatasetResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEvaluationsOKApplicationJSON as json.
func (s GetEvaluationsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetEvaluationsOKApplicationJSON from json.
func (s *GetEvaluationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEvaluationsOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEvaluationsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetEvaluationsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEvaluationsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetExperimentCSVOKApplicationJSON as json.
func (s GetExperimentCSVOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetExperimentCSVOKApplicationJSON from json.
func (s *GetExperimentCSVOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExperimentCSVOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetExperimentCSVOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetExperimentCSVOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExperimentCSVOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExperimentResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExperimentResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGetExperimentResponseBody = [1]string{
	0: "data",
}

// Decode decodes GetExperimentResponseBody from json.
func (s *GetExperimentResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExperimentResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExperimentResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetExperimentResponseBody) {
					name = jsonFieldsNameOfGetExperimentResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExperimentResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExperimentResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetIncompleteEvaluationsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetIncompleteEvaluationsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfGetIncompleteEvaluationsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes GetIncompleteEvaluationsResponseBody from json.
func (s *GetIncompleteEvaluationsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIncompleteEvaluationsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]IncompleteExperimentEvaluation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IncompleteExperimentEvaluation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetIncompleteEvaluationsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetIncompleteEvaluationsResponseBody) {
					name = jsonFieldsNameOfGetIncompleteEvaluationsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetIncompleteEvaluationsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIncompleteEvaluationsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetIncompleteExperimentRunsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetIncompleteExperimentRunsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfGetIncompleteExperimentRunsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes GetIncompleteExperimentRunsResponseBody from json.
func (s *GetIncompleteExperimentRunsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIncompleteExperimentRunsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]IncompleteExperimentRun, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IncompleteExperimentRun
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetIncompleteExperimentRunsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetIncompleteExperimentRunsResponseBody) {
					name = jsonFieldsNameOfGetIncompleteExperimentRunsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetIncompleteExperimentRunsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIncompleteExperimentRunsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetProjectResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetProjectResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGetProjectResponseBody = [1]string{
	0: "data",
}

// Decode decodes GetProjectResponseBody from json.
func (s *GetProjectResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetProjectResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetProjectResponseBody) {
					name = jsonFieldsNameOfGetProjectResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProjectResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetProjectsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetProjectsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfGetProjectsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes GetProjectsResponseBody from json.
func (s *GetProjectsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]Project, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Project
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetProjectsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetProjectsResponseBody) {
					name = jsonFieldsNameOfGetProjectsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProjectsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPromptResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPromptResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGetPromptResponseBody = [1]string{
	0: "data",
}

// Decode decodes GetPromptResponseBody from json.
func (s *GetPromptResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPromptResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPromptResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPromptResponseBody) {
					name = jsonFieldsNameOfGetPromptResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPromptResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPromptResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPromptVersionTagsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPromptVersionTagsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfGetPromptVersionTagsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes GetPromptVersionTagsResponseBody from json.
func (s *GetPromptVersionTagsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPromptVersionTagsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]PromptVersionTag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PromptVersionTag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPromptVersionTagsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPromptVersionTagsResponseBody) {
					name = jsonFieldsNameOfGetPromptVersionTagsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPromptVersionTagsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPromptVersionTagsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPromptVersionsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPromptVersionsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfGetPromptVersionsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes GetPromptVersionsResponseBody from json.
func (s *GetPromptVersionsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPromptVersionsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]PromptVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PromptVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPromptVersionsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPromptVersionsResponseBody) {
					name = jsonFieldsNameOfGetPromptVersionsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPromptVersionsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPromptVersionsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPromptsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPromptsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfGetPromptsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes GetPromptsResponseBody from json.
func (s *GetPromptsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPromptsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]Prompt, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Prompt
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPromptsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPromptsResponseBody) {
					name = jsonFieldsNameOfGetPromptsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPromptsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPromptsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUsersResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUsersResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfGetUsersResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes GetUsersResponseBody from json.
func (s *GetUsersResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsersResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]GetUsersResponseBodyDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUsersResponseBodyDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUsersResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUsersResponseBody) {
					name = jsonFieldsNameOfGetUsersResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUsersResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsersResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUsersResponseBodyDataItem as json.
func (s GetUsersResponseBodyDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetUsersResponseBodyDataItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case LocalUserGetUsersResponseBodyDataItem:
		e.FieldStart("auth_method")
		e.Str("LOCAL")
		{
			s := s.LocalUser
			{
				e.FieldStart("created_at")
				json.EncodeDateTime(e, s.CreatedAt)
			}
			{
				e.FieldStart("email")
				e.Str(s.Email)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				if s.Password.Set {
					e.FieldStart("password")
					s.Password.Encode(e)
				}
			}
			{
				e.FieldStart("password_needs_reset")
				e.Bool(s.PasswordNeedsReset)
			}
			{
				e.FieldStart("role")
				s.Role.Encode(e)
			}
			{
				e.FieldStart("updated_at")
				json.EncodeDateTime(e, s.UpdatedAt)
			}
			{
				e.FieldStart("username")
				e.Str(s.Username)
			}
		}
	case OAuth2UserGetUsersResponseBodyDataItem:
		e.FieldStart("auth_method")
		e.Str("OAUTH2")
		{
			s := s.OAuth2User
			{
				e.FieldStart("created_at")
				json.EncodeDateTime(e, s.CreatedAt)
			}
			{
				e.FieldStart("email")
				e.Str(s.Email)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				if s.OAuth2ClientID.Set {
					e.FieldStart("oauth2_client_id")
					s.OAuth2ClientID.Encode(e)
				}
			}
			{
				if s.OAuth2UserID.Set {
					e.FieldStart("oauth2_user_id")
					s.OAuth2UserID.Encode(e)
				}
			}
			{
				if s.ProfilePictureURL.Set {
					e.FieldStart("profile_picture_url")
					s.ProfilePictureURL.Encode(e)
				}
			}
			{
				e.FieldStart("role")
				s.Role.Encode(e)
			}
			{
				e.FieldStart("updated_at")
				json.EncodeDateTime(e, s.UpdatedAt)
			}
			{
				e.FieldStart("username")
				e.Str(s.Username)
			}
		}
	case LDAPUserGetUsersResponseBodyDataItem:
		e.FieldStart("auth_method")
		e.Str("LDAP")
		{
			s := s.LDAPUser
			{
				e.FieldStart("created_at")
				json.EncodeDateTime(e, s.CreatedAt)
			}
			{
				e.FieldStart("email")
				e.Str(s.Email)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("role")
				s.Role.Encode(e)
			}
			{
				e.FieldStart("updated_at")
				json.EncodeDateTime(e, s.UpdatedAt)
			}
			{
				e.FieldStart("username")
				e.Str(s.Username)
			}
		}
	}
}

// Decode decodes GetUsersResponseBodyDataItem from json.
func (s *GetUsersResponseBodyDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsersResponseBodyDataItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "auth_method":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "LOCAL":
					s.Type = LocalUserGetUsersResponseBodyDataItem
					found = true
				case "OAUTH2":
					s.Type = OAuth2UserGetUsersResponseBodyDataItem
					found = true
				case "LDAP":
					s.Type = LDAPUserGetUsersResponseBodyDataItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case LocalUserGetUsersResponseBodyDataItem:
		if err := s.LocalUser.Decode(d); err != nil {
			return err
		}
	case OAuth2UserGetUsersResponseBodyDataItem:
		if err := s.OAuth2User.Decode(d); err != nil {
			return err
		}
	case LDAPUserGetUsersResponseBodyDataItem:
		if err := s.LDAPUser.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUsersResponseBodyDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsersResponseBodyDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTTPValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTTPValidationError) encodeFields(e *jx.Encoder) {
	{
		if s.Detail != nil {
			e.FieldStart("detail")
			e.ArrStart()
			for _, elem := range s.Detail {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHTTPValidationError = [1]string{
	0: "detail",
}

// Decode decodes HTTPValidationError from json.
func (s *HTTPValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTTPValidationError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "detail":
			if err := func() error {
				s.Detail = make([]ValidationError, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationError
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Detail = append(s.Detail, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTTPValidationError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTTPValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTTPValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Identifier as json.
func (s Identifier) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Identifier from json.
func (s *Identifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Identifier to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Identifier(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Identifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Identifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncompleteExperimentEvaluation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncompleteExperimentEvaluation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataset_example")
		s.DatasetExample.Encode(e)
	}
	{
		e.FieldStart("evaluation_names")
		e.ArrStart()
		for _, elem := range s.EvaluationNames {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("experiment_run")
		s.ExperimentRun.Encode(e)
	}
}

var jsonFieldsNameOfIncompleteExperimentEvaluation = [3]string{
	0: "dataset_example",
	1: "evaluation_names",
	2: "experiment_run",
}

// Decode decodes IncompleteExperimentEvaluation from json.
func (s *IncompleteExperimentEvaluation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncompleteExperimentEvaluation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_example":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DatasetExample.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_example\"")
			}
		case "evaluation_names":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.EvaluationNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.EvaluationNames = append(s.EvaluationNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluation_names\"")
			}
		case "experiment_run":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ExperimentRun.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_run\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncompleteExperimentEvaluation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIncompleteExperimentEvaluation) {
					name = jsonFieldsNameOfIncompleteExperimentEvaluation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncompleteExperimentEvaluation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncompleteExperimentEvaluation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncompleteExperimentRun) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncompleteExperimentRun) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataset_example")
		s.DatasetExample.Encode(e)
	}
	{
		e.FieldStart("repetition_numbers")
		e.ArrStart()
		for _, elem := range s.RepetitionNumbers {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIncompleteExperimentRun = [2]string{
	0: "dataset_example",
	1: "repetition_numbers",
}

// Decode decodes IncompleteExperimentRun from json.
func (s *IncompleteExperimentRun) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncompleteExperimentRun to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_example":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DatasetExample.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_example\"")
			}
		case "repetition_numbers":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.RepetitionNumbers = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.RepetitionNumbers = append(s.RepetitionNumbers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repetition_numbers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncompleteExperimentRun")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIncompleteExperimentRun) {
					name = jsonFieldsNameOfIncompleteExperimentRun[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncompleteExperimentRun) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncompleteExperimentRun) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InsertedSessionAnnotation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InsertedSessionAnnotation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfInsertedSessionAnnotation = [1]string{
	0: "id",
}

// Decode decodes InsertedSessionAnnotation from json.
func (s *InsertedSessionAnnotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InsertedSessionAnnotation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InsertedSessionAnnotation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInsertedSessionAnnotation) {
					name = jsonFieldsNameOfInsertedSessionAnnotation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InsertedSessionAnnotation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InsertedSessionAnnotation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InsertedSpanAnnotation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InsertedSpanAnnotation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfInsertedSpanAnnotation = [1]string{
	0: "id",
}

// Decode decodes InsertedSpanAnnotation from json.
func (s *InsertedSpanAnnotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InsertedSpanAnnotation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InsertedSpanAnnotation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInsertedSpanAnnotation) {
					name = jsonFieldsNameOfInsertedSpanAnnotation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InsertedSpanAnnotation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InsertedSpanAnnotation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InsertedSpanDocumentAnnotation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InsertedSpanDocumentAnnotation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfInsertedSpanDocumentAnnotation = [1]string{
	0: "id",
}

// Decode decodes InsertedSpanDocumentAnnotation from json.
func (s *InsertedSpanDocumentAnnotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InsertedSpanDocumentAnnotation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InsertedSpanDocumentAnnotation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInsertedSpanDocumentAnnotation) {
					name = jsonFieldsNameOfInsertedSpanDocumentAnnotation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InsertedSpanDocumentAnnotation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InsertedSpanDocumentAnnotation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InsertedTraceAnnotation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InsertedTraceAnnotation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfInsertedTraceAnnotation = [1]string{
	0: "id",
}

// Decode decodes InsertedTraceAnnotation from json.
func (s *InsertedTraceAnnotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InsertedTraceAnnotation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InsertedTraceAnnotation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInsertedTraceAnnotation) {
					name = jsonFieldsNameOfInsertedTraceAnnotation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InsertedTraceAnnotation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InsertedTraceAnnotation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LDAPUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LDAPUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("auth_method")
		s.AuthMethod.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
}

var jsonFieldsNameOfLDAPUser = [7]string{
	0: "auth_method",
	1: "created_at",
	2: "email",
	3: "id",
	4: "role",
	5: "updated_at",
	6: "username",
}

// Decode decodes LDAPUser from json.
func (s *LDAPUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LDAPUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auth_method":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AuthMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_method\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LDAPUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLDAPUser) {
					name = jsonFieldsNameOfLDAPUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LDAPUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LDAPUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LDAPUserAuthMethod as json.
func (s LDAPUserAuthMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LDAPUserAuthMethod from json.
func (s *LDAPUserAuthMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LDAPUserAuthMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LDAPUserAuthMethod(v) {
	case LDAPUserAuthMethodLDAP:
		*s = LDAPUserAuthMethodLDAP
	default:
		*s = LDAPUserAuthMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LDAPUserAuthMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LDAPUserAuthMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LDAPUserData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LDAPUserData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("auth_method")
		s.AuthMethod.Encode(e)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
}

var jsonFieldsNameOfLDAPUserData = [4]string{
	0: "auth_method",
	1: "email",
	2: "role",
	3: "username",
}

// Decode decodes LDAPUserData from json.
func (s *LDAPUserData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LDAPUserData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auth_method":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AuthMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_method\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LDAPUserData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLDAPUserData) {
					name = jsonFieldsNameOfLDAPUserData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LDAPUserData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LDAPUserData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LDAPUserDataAuthMethod as json.
func (s LDAPUserDataAuthMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LDAPUserDataAuthMethod from json.
func (s *LDAPUserDataAuthMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LDAPUserDataAuthMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LDAPUserDataAuthMethod(v) {
	case LDAPUserDataAuthMethodLDAP:
		*s = LDAPUserDataAuthMethodLDAP
	default:
		*s = LDAPUserDataAuthMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LDAPUserDataAuthMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LDAPUserDataAuthMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LDAPUserDataRole as json.
func (s LDAPUserDataRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LDAPUserDataRole from json.
func (s *LDAPUserDataRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LDAPUserDataRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LDAPUserDataRole(v) {
	case LDAPUserDataRoleSYSTEM:
		*s = LDAPUserDataRoleSYSTEM
	case LDAPUserDataRoleADMIN:
		*s = LDAPUserDataRoleADMIN
	case LDAPUserDataRoleMEMBER:
		*s = LDAPUserDataRoleMEMBER
	case LDAPUserDataRoleVIEWER:
		*s = LDAPUserDataRoleVIEWER
	default:
		*s = LDAPUserDataRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LDAPUserDataRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LDAPUserDataRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LDAPUserRole as json.
func (s LDAPUserRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LDAPUserRole from json.
func (s *LDAPUserRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LDAPUserRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LDAPUserRole(v) {
	case LDAPUserRoleSYSTEM:
		*s = LDAPUserRoleSYSTEM
	case LDAPUserRoleADMIN:
		*s = LDAPUserRoleADMIN
	case LDAPUserRoleMEMBER:
		*s = LDAPUserRoleMEMBER
	case LDAPUserRoleVIEWER:
		*s = LDAPUserRoleVIEWER
	default:
		*s = LDAPUserRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LDAPUserRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LDAPUserRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDatasetExamplesData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDatasetExamplesData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataset_id")
		e.Str(s.DatasetID)
	}
	{
		e.FieldStart("examples")
		e.ArrStart()
		for _, elem := range s.Examples {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.FilteredSplits != nil {
			e.FieldStart("filtered_splits")
			e.ArrStart()
			for _, elem := range s.FilteredSplits {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("version_id")
		e.Str(s.VersionID)
	}
}

var jsonFieldsNameOfListDatasetExamplesData = [4]string{
	0: "dataset_id",
	1: "examples",
	2: "filtered_splits",
	3: "version_id",
}

// Decode decodes ListDatasetExamplesData from json.
func (s *ListDatasetExamplesData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDatasetExamplesData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatasetID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_id\"")
			}
		case "examples":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Examples = make([]DatasetExample, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatasetExample
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Examples = append(s.Examples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"examples\"")
			}
		case "filtered_splits":
			if err := func() error {
				s.FilteredSplits = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FilteredSplits = append(s.FilteredSplits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filtered_splits\"")
			}
		case "version_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VersionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDatasetExamplesData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListDatasetExamplesData) {
					name = jsonFieldsNameOfListDatasetExamplesData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDatasetExamplesData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDatasetExamplesData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDatasetExamplesResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDatasetExamplesResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfListDatasetExamplesResponseBody = [1]string{
	0: "data",
}

// Decode decodes ListDatasetExamplesResponseBody from json.
func (s *ListDatasetExamplesResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDatasetExamplesResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDatasetExamplesResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListDatasetExamplesResponseBody) {
					name = jsonFieldsNameOfListDatasetExamplesResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDatasetExamplesResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDatasetExamplesResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDatasetVersionsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDatasetVersionsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfListDatasetVersionsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes ListDatasetVersionsResponseBody from json.
func (s *ListDatasetVersionsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDatasetVersionsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]DatasetVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatasetVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDatasetVersionsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListDatasetVersionsResponseBody) {
					name = jsonFieldsNameOfListDatasetVersionsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDatasetVersionsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDatasetVersionsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDatasetsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDatasetsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfListDatasetsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes ListDatasetsResponseBody from json.
func (s *ListDatasetsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDatasetsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]Dataset, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Dataset
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDatasetsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListDatasetsResponseBody) {
					name = jsonFieldsNameOfListDatasetsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDatasetsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDatasetsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListExperimentRunsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListExperimentRunsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfListExperimentRunsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes ListExperimentRunsResponseBody from json.
func (s *ListExperimentRunsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListExperimentRunsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]ExperimentRun, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExperimentRun
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListExperimentRunsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListExperimentRunsResponseBody) {
					name = jsonFieldsNameOfListExperimentRunsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListExperimentRunsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListExperimentRunsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListExperimentsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListExperimentsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfListExperimentsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes ListExperimentsResponseBody from json.
func (s *ListExperimentsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListExperimentsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]Experiment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Experiment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListExperimentsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListExperimentsResponseBody) {
					name = jsonFieldsNameOfListExperimentsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListExperimentsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListExperimentsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LocalUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LocalUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("auth_method")
		s.AuthMethod.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		e.FieldStart("password_needs_reset")
		e.Bool(s.PasswordNeedsReset)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
}

var jsonFieldsNameOfLocalUser = [9]string{
	0: "auth_method",
	1: "created_at",
	2: "email",
	3: "id",
	4: "password",
	5: "password_needs_reset",
	6: "role",
	7: "updated_at",
	8: "username",
}

// Decode decodes LocalUser from json.
func (s *LocalUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocalUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auth_method":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AuthMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_method\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "password_needs_reset":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.PasswordNeedsReset = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_needs_reset\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "username":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LocalUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLocalUser) {
					name = jsonFieldsNameOfLocalUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LocalUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocalUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LocalUserAuthMethod as json.
func (s LocalUserAuthMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LocalUserAuthMethod from json.
func (s *LocalUserAuthMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocalUserAuthMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LocalUserAuthMethod(v) {
	case LocalUserAuthMethodLOCAL:
		*s = LocalUserAuthMethodLOCAL
	default:
		*s = LocalUserAuthMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LocalUserAuthMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocalUserAuthMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LocalUserData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LocalUserData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("auth_method")
		s.AuthMethod.Encode(e)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
}

var jsonFieldsNameOfLocalUserData = [5]string{
	0: "auth_method",
	1: "email",
	2: "password",
	3: "role",
	4: "username",
}

// Decode decodes LocalUserData from json.
func (s *LocalUserData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocalUserData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auth_method":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AuthMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_method\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LocalUserData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLocalUserData) {
					name = jsonFieldsNameOfLocalUserData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LocalUserData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocalUserData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LocalUserDataAuthMethod as json.
func (s LocalUserDataAuthMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LocalUserDataAuthMethod from json.
func (s *LocalUserDataAuthMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocalUserDataAuthMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LocalUserDataAuthMethod(v) {
	case LocalUserDataAuthMethodLOCAL:
		*s = LocalUserDataAuthMethodLOCAL
	default:
		*s = LocalUserDataAuthMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LocalUserDataAuthMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocalUserDataAuthMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LocalUserDataRole as json.
func (s LocalUserDataRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LocalUserDataRole from json.
func (s *LocalUserDataRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocalUserDataRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LocalUserDataRole(v) {
	case LocalUserDataRoleSYSTEM:
		*s = LocalUserDataRoleSYSTEM
	case LocalUserDataRoleADMIN:
		*s = LocalUserDataRoleADMIN
	case LocalUserDataRoleMEMBER:
		*s = LocalUserDataRoleMEMBER
	case LocalUserDataRoleVIEWER:
		*s = LocalUserDataRoleVIEWER
	default:
		*s = LocalUserDataRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LocalUserDataRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocalUserDataRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LocalUserRole as json.
func (s LocalUserRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LocalUserRole from json.
func (s *LocalUserRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocalUserRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LocalUserRole(v) {
	case LocalUserRoleSYSTEM:
		*s = LocalUserRoleSYSTEM
	case LocalUserRoleADMIN:
		*s = LocalUserRoleADMIN
	case LocalUserRoleMEMBER:
		*s = LocalUserRoleMEMBER
	case LocalUserRoleVIEWER:
		*s = LocalUserRoleVIEWER
	default:
		*s = LocalUserRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LocalUserRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocalUserRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModelProvider as json.
func (s ModelProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ModelProvider from json.
func (s *ModelProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ModelProvider(v) {
	case ModelProviderOPENAI:
		*s = ModelProviderOPENAI
	case ModelProviderAZUREOPENAI:
		*s = ModelProviderAZUREOPENAI
	case ModelProviderANTHROPIC:
		*s = ModelProviderANTHROPIC
	case ModelProviderGOOGLE:
		*s = ModelProviderGOOGLE
	case ModelProviderDEEPSEEK:
		*s = ModelProviderDEEPSEEK
	case ModelProviderXAI:
		*s = ModelProviderXAI
	case ModelProviderOLLAMA:
		*s = ModelProviderOLLAMA
	case ModelProviderAWS:
		*s = ModelProviderAWS
	default:
		*s = ModelProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModelProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolResultContentPartToolResult as json.
func (o NilToolResultContentPartToolResult) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ToolResultContentPartToolResult from json.
func (o *NilToolResultContentPartToolResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilToolResultContentPartToolResult to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ToolResultContentPartToolResult
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilToolResultContentPartToolResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilToolResultContentPartToolResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadDatasetReqApplicationJSONSplitsItem as json.
func (o NilUploadDatasetReqApplicationJSONSplitsItem) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UploadDatasetReqApplicationJSONSplitsItem from json.
func (o *NilUploadDatasetReqApplicationJSONSplitsItem) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUploadDatasetReqApplicationJSONSplitsItem to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UploadDatasetReqApplicationJSONSplitsItem
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUploadDatasetReqApplicationJSONSplitsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUploadDatasetReqApplicationJSONSplitsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2User) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2User) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("auth_method")
		s.AuthMethod.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.OAuth2ClientID.Set {
			e.FieldStart("oauth2_client_id")
			s.OAuth2ClientID.Encode(e)
		}
	}
	{
		if s.OAuth2UserID.Set {
			e.FieldStart("oauth2_user_id")
			s.OAuth2UserID.Encode(e)
		}
	}
	{
		if s.ProfilePictureURL.Set {
			e.FieldStart("profile_picture_url")
			s.ProfilePictureURL.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
}

var jsonFieldsNameOfOAuth2User = [10]string{
	0: "auth_method",
	1: "created_at",
	2: "email",
	3: "id",
	4: "oauth2_client_id",
	5: "oauth2_user_id",
	6: "profile_picture_url",
	7: "role",
	8: "updated_at",
	9: "username",
}

// Decode decodes OAuth2User from json.
func (s *OAuth2User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2User to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auth_method":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AuthMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_method\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "oauth2_client_id":
			if err := func() error {
				s.OAuth2ClientID.Reset()
				if err := s.OAuth2ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2_client_id\"")
			}
		case "oauth2_user_id":
			if err := func() error {
				s.OAuth2UserID.Reset()
				if err := s.OAuth2UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2_user_id\"")
			}
		case "profile_picture_url":
			if err := func() error {
				s.ProfilePictureURL.Reset()
				if err := s.ProfilePictureURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profile_picture_url\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "username":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2User")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10001111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuth2User) {
					name = jsonFieldsNameOfOAuth2User[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2User) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2User) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuth2UserAuthMethod as json.
func (s OAuth2UserAuthMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OAuth2UserAuthMethod from json.
func (s *OAuth2UserAuthMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2UserAuthMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OAuth2UserAuthMethod(v) {
	case OAuth2UserAuthMethodOAuth2:
		*s = OAuth2UserAuthMethodOAuth2
	default:
		*s = OAuth2UserAuthMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OAuth2UserAuthMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2UserAuthMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2UserData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2UserData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("auth_method")
		s.AuthMethod.Encode(e)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.OAuth2ClientID.Set {
			e.FieldStart("oauth2_client_id")
			s.OAuth2ClientID.Encode(e)
		}
	}
	{
		if s.OAuth2UserID.Set {
			e.FieldStart("oauth2_user_id")
			s.OAuth2UserID.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
}

var jsonFieldsNameOfOAuth2UserData = [6]string{
	0: "auth_method",
	1: "email",
	2: "oauth2_client_id",
	3: "oauth2_user_id",
	4: "role",
	5: "username",
}

// Decode decodes OAuth2UserData from json.
func (s *OAuth2UserData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2UserData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auth_method":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AuthMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_method\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "oauth2_client_id":
			if err := func() error {
				s.OAuth2ClientID.Reset()
				if err := s.OAuth2ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2_client_id\"")
			}
		case "oauth2_user_id":
			if err := func() error {
				s.OAuth2UserID.Reset()
				if err := s.OAuth2UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2_user_id\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2UserData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuth2UserData) {
					name = jsonFieldsNameOfOAuth2UserData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2UserData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2UserData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuth2UserDataAuthMethod as json.
func (s OAuth2UserDataAuthMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OAuth2UserDataAuthMethod from json.
func (s *OAuth2UserDataAuthMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2UserDataAuthMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OAuth2UserDataAuthMethod(v) {
	case OAuth2UserDataAuthMethodOAuth2:
		*s = OAuth2UserDataAuthMethodOAuth2
	default:
		*s = OAuth2UserDataAuthMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OAuth2UserDataAuthMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2UserDataAuthMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuth2UserDataRole as json.
func (s OAuth2UserDataRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OAuth2UserDataRole from json.
func (s *OAuth2UserDataRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2UserDataRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OAuth2UserDataRole(v) {
	case OAuth2UserDataRoleSYSTEM:
		*s = OAuth2UserDataRoleSYSTEM
	case OAuth2UserDataRoleADMIN:
		*s = OAuth2UserDataRoleADMIN
	case OAuth2UserDataRoleMEMBER:
		*s = OAuth2UserDataRoleMEMBER
	case OAuth2UserDataRoleVIEWER:
		*s = OAuth2UserDataRoleVIEWER
	default:
		*s = OAuth2UserDataRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OAuth2UserDataRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2UserDataRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuth2UserRole as json.
func (s OAuth2UserRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OAuth2UserRole from json.
func (s *OAuth2UserRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2UserRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OAuth2UserRole(v) {
	case OAuth2UserRoleSYSTEM:
		*s = OAuth2UserRoleSYSTEM
	case OAuth2UserRoleADMIN:
		*s = OAuth2UserRoleADMIN
	case OAuth2UserRoleMEMBER:
		*s = OAuth2UserRoleMEMBER
	case OAuth2UserRoleVIEWER:
		*s = OAuth2UserRoleVIEWER
	default:
		*s = OAuth2UserRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OAuth2UserRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2UserRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnnotationResult as json.
func (o OptAnnotationResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AnnotationResult from json.
func (o *OptAnnotationResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnnotationResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnnotationResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnnotationResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentEvaluationResult as json.
func (o OptExperimentEvaluationResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentEvaluationResult from json.
func (o *OptExperimentEvaluationResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentEvaluationResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentEvaluationResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentEvaluationResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateExperimentRequestBodyMetadata as json.
func (o OptNilCreateExperimentRequestBodyMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateExperimentRequestBodyMetadata from json.
func (o *OptNilCreateExperimentRequestBodyMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateExperimentRequestBodyMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateExperimentRequestBodyMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(CreateExperimentRequestBodyMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateExperimentRequestBodyMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateExperimentRequestBodyMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptDataMetadata as json.
func (o OptNilPromptDataMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptDataMetadata from json.
func (o *OptNilPromptDataMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPromptDataMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PromptDataMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(PromptDataMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPromptDataMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPromptDataMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptMetadata as json.
func (o OptNilPromptMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptMetadata from json.
func (o *OptNilPromptMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPromptMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PromptMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(PromptMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPromptMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPromptMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionDataResponseFormat as json.
func (o OptNilPromptVersionDataResponseFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptVersionDataResponseFormat from json.
func (o *OptNilPromptVersionDataResponseFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPromptVersionDataResponseFormat to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PromptVersionDataResponseFormat
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPromptVersionDataResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPromptVersionDataResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionResponseFormat as json.
func (o OptNilPromptVersionResponseFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptVersionResponseFormat from json.
func (o *OptNilPromptVersionResponseFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPromptVersionResponseFormat to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PromptVersionResponseFormat
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPromptVersionResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPromptVersionResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionAnnotationDataMetadata as json.
func (o OptNilSessionAnnotationDataMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionAnnotationDataMetadata from json.
func (o *OptNilSessionAnnotationDataMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSessionAnnotationDataMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SessionAnnotationDataMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SessionAnnotationDataMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSessionAnnotationDataMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSessionAnnotationDataMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionAnnotationMetadata as json.
func (o OptNilSessionAnnotationMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionAnnotationMetadata from json.
func (o *OptNilSessionAnnotationMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSessionAnnotationMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SessionAnnotationMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SessionAnnotationMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSessionAnnotationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSessionAnnotationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanAnnotationDataMetadata as json.
func (o OptNilSpanAnnotationDataMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanAnnotationDataMetadata from json.
func (o *OptNilSpanAnnotationDataMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSpanAnnotationDataMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SpanAnnotationDataMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SpanAnnotationDataMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSpanAnnotationDataMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSpanAnnotationDataMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanAnnotationMetadata as json.
func (o OptNilSpanAnnotationMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanAnnotationMetadata from json.
func (o *OptNilSpanAnnotationMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSpanAnnotationMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SpanAnnotationMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SpanAnnotationMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSpanAnnotationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSpanAnnotationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanDocumentAnnotationDataMetadata as json.
func (o OptNilSpanDocumentAnnotationDataMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanDocumentAnnotationDataMetadata from json.
func (o *OptNilSpanDocumentAnnotationDataMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSpanDocumentAnnotationDataMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SpanDocumentAnnotationDataMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SpanDocumentAnnotationDataMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSpanDocumentAnnotationDataMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSpanDocumentAnnotationDataMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]string, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem string
		v, err := d.Str()
		elem = string(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceAnnotationDataMetadata as json.
func (o OptNilTraceAnnotationDataMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceAnnotationDataMetadata from json.
func (o *OptNilTraceAnnotationDataMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTraceAnnotationDataMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v TraceAnnotationDataMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(TraceAnnotationDataMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTraceAnnotationDataMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTraceAnnotationDataMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceAnnotationMetadata as json.
func (o OptNilTraceAnnotationMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceAnnotationMetadata from json.
func (o *OptNilTraceAnnotationMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTraceAnnotationMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v TraceAnnotationMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(TraceAnnotationMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTraceAnnotationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTraceAnnotationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertExperimentEvaluationRequestBodyMetadata as json.
func (o OptNilUpsertExperimentEvaluationRequestBodyMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpsertExperimentEvaluationRequestBodyMetadata from json.
func (o *OptNilUpsertExperimentEvaluationRequestBodyMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUpsertExperimentEvaluationRequestBodyMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpsertExperimentEvaluationRequestBodyMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(UpsertExperimentEvaluationRequestBodyMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUpsertExperimentEvaluationRequestBodyMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUpsertExperimentEvaluationRequestBodyMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptAnthropicInvocationParametersContentThinking as json.
func (o OptPromptAnthropicInvocationParametersContentThinking) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptAnthropicInvocationParametersContentThinking from json.
func (o *OptPromptAnthropicInvocationParametersContentThinking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptAnthropicInvocationParametersContentThinking to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptAnthropicInvocationParametersContentThinking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptAnthropicInvocationParametersContentThinking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptAzureOpenAIInvocationParametersContentReasoningEffort as json.
func (o OptPromptAzureOpenAIInvocationParametersContentReasoningEffort) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptAzureOpenAIInvocationParametersContentReasoningEffort from json.
func (o *OptPromptAzureOpenAIInvocationParametersContentReasoningEffort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptAzureOpenAIInvocationParametersContentReasoningEffort to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptAzureOpenAIInvocationParametersContentReasoningEffort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptAzureOpenAIInvocationParametersContentReasoningEffort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptDeepSeekInvocationParametersContentReasoningEffort as json.
func (o OptPromptDeepSeekInvocationParametersContentReasoningEffort) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptDeepSeekInvocationParametersContentReasoningEffort from json.
func (o *OptPromptDeepSeekInvocationParametersContentReasoningEffort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptDeepSeekInvocationParametersContentReasoningEffort to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptDeepSeekInvocationParametersContentReasoningEffort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptDeepSeekInvocationParametersContentReasoningEffort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptOllamaInvocationParametersContentReasoningEffort as json.
func (o OptPromptOllamaInvocationParametersContentReasoningEffort) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptOllamaInvocationParametersContentReasoningEffort from json.
func (o *OptPromptOllamaInvocationParametersContentReasoningEffort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptOllamaInvocationParametersContentReasoningEffort to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptOllamaInvocationParametersContentReasoningEffort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptOllamaInvocationParametersContentReasoningEffort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptOpenAIInvocationParametersContentReasoningEffort as json.
func (o OptPromptOpenAIInvocationParametersContentReasoningEffort) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptOpenAIInvocationParametersContentReasoningEffort from json.
func (o *OptPromptOpenAIInvocationParametersContentReasoningEffort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptOpenAIInvocationParametersContentReasoningEffort to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptOpenAIInvocationParametersContentReasoningEffort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptOpenAIInvocationParametersContentReasoningEffort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptResponseFormatJSONSchemaDefinitionSchema as json.
func (o OptPromptResponseFormatJSONSchemaDefinitionSchema) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptResponseFormatJSONSchemaDefinitionSchema from json.
func (o *OptPromptResponseFormatJSONSchemaDefinitionSchema) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptResponseFormatJSONSchemaDefinitionSchema to nil")
	}
	o.Set = true
	o.Value = make(PromptResponseFormatJSONSchemaDefinitionSchema)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptResponseFormatJSONSchemaDefinitionSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptResponseFormatJSONSchemaDefinitionSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptToolFunctionDefinitionParameters as json.
func (o OptPromptToolFunctionDefinitionParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptToolFunctionDefinitionParameters from json.
func (o *OptPromptToolFunctionDefinitionParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptToolFunctionDefinitionParameters to nil")
	}
	o.Set = true
	o.Value = make(PromptToolFunctionDefinitionParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptToolFunctionDefinitionParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptToolFunctionDefinitionParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptTools as json.
func (o OptPromptTools) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptTools from json.
func (o *OptPromptTools) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptTools to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptTools) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptTools) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptToolsToolChoice as json.
func (o OptPromptToolsToolChoice) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptToolsToolChoice from json.
func (o *OptPromptToolsToolChoice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptToolsToolChoice to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptToolsToolChoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptToolsToolChoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptXAIInvocationParametersContentReasoningEffort as json.
func (o OptPromptXAIInvocationParametersContentReasoningEffort) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptXAIInvocationParametersContentReasoningEffort from json.
func (o *OptPromptXAIInvocationParametersContentReasoningEffort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptXAIInvocationParametersContentReasoningEffort to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptXAIInvocationParametersContentReasoningEffort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptXAIInvocationParametersContentReasoningEffort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanAttributes as json.
func (o OptSpanAttributes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanAttributes from json.
func (o *OptSpanAttributes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanAttributes to nil")
	}
	o.Set = true
	o.Value = make(SpanAttributes)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanEventAttributes as json.
func (o OptSpanEventAttributes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanEventAttributes from json.
func (o *OptSpanEventAttributes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanEventAttributes to nil")
	}
	o.Set = true
	o.Value = make(SpanEventAttributes)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanEventAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanEventAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadDatasetReqApplicationJSONAction as json.
func (o OptUploadDatasetReqApplicationJSONAction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UploadDatasetReqApplicationJSONAction from json.
func (o *OptUploadDatasetReqApplicationJSONAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUploadDatasetReqApplicationJSONAction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUploadDatasetReqApplicationJSONAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUploadDatasetReqApplicationJSONAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OptimizationDirection as json.
func (s OptimizationDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OptimizationDirection from json.
func (s *OptimizationDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OptimizationDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OptimizationDirection(v) {
	case OptimizationDirectionMINIMIZE:
		*s = OptimizationDirectionMINIMIZE
	case OptimizationDirectionMAXIMIZE:
		*s = OptimizationDirectionMAXIMIZE
	case OptimizationDirectionNONE:
		*s = OptimizationDirectionNONE
	default:
		*s = OptimizationDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptimizationDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptimizationDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Project) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Project) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfProject = [3]string{
	0: "description",
	1: "id",
	2: "name",
}

// Decode decodes Project from json.
func (s *Project) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Project to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Project")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProject) {
					name = jsonFieldsNameOfProject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Project) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Project) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Prompt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Prompt) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.SourcePromptID.Set {
			e.FieldStart("source_prompt_id")
			s.SourcePromptID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPrompt = [5]string{
	0: "description",
	1: "id",
	2: "metadata",
	3: "name",
	4: "source_prompt_id",
}

// Decode decodes Prompt from json.
func (s *Prompt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Prompt to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "source_prompt_id":
			if err := func() error {
				s.SourcePromptID.Reset()
				if err := s.SourcePromptID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_prompt_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Prompt")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPrompt) {
					name = jsonFieldsNameOfPrompt[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Prompt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Prompt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptAnthropicInvocationParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptAnthropicInvocationParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("anthropic")
		s.Anthropic.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptAnthropicInvocationParameters = [2]string{
	0: "anthropic",
	1: "type",
}

// Decode decodes PromptAnthropicInvocationParameters from json.
func (s *PromptAnthropicInvocationParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAnthropicInvocationParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "anthropic":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Anthropic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anthropic\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptAnthropicInvocationParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptAnthropicInvocationParameters) {
					name = jsonFieldsNameOfPromptAnthropicInvocationParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptAnthropicInvocationParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAnthropicInvocationParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptAnthropicInvocationParametersContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptAnthropicInvocationParametersContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("max_tokens")
		e.Int(s.MaxTokens)
	}
	{
		if s.StopSequences != nil {
			e.FieldStart("stop_sequences")
			e.ArrStart()
			for _, elem := range s.StopSequences {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.Thinking.Set {
			e.FieldStart("thinking")
			s.Thinking.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptAnthropicInvocationParametersContent = [5]string{
	0: "max_tokens",
	1: "stop_sequences",
	2: "temperature",
	3: "thinking",
	4: "top_p",
}

// Decode decodes PromptAnthropicInvocationParametersContent from json.
func (s *PromptAnthropicInvocationParametersContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAnthropicInvocationParametersContent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max_tokens":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MaxTokens = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tokens\"")
			}
		case "stop_sequences":
			if err := func() error {
				s.StopSequences = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StopSequences = append(s.StopSequences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_sequences\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "thinking":
			if err := func() error {
				s.Thinking.Reset()
				if err := s.Thinking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thinking\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptAnthropicInvocationParametersContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptAnthropicInvocationParametersContent) {
					name = jsonFieldsNameOfPromptAnthropicInvocationParametersContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptAnthropicInvocationParametersContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAnthropicInvocationParametersContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptAnthropicInvocationParametersContentThinking as json.
func (s PromptAnthropicInvocationParametersContentThinking) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PromptAnthropicInvocationParametersContentThinking) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PromptAnthropicThinkingConfigDisabledPromptAnthropicInvocationParametersContentThinking:
		e.FieldStart("type")
		e.Str("disabled")
	case PromptAnthropicThinkingConfigEnabledPromptAnthropicInvocationParametersContentThinking:
		e.FieldStart("type")
		e.Str("enabled")
		{
			s := s.PromptAnthropicThinkingConfigEnabled
			{
				e.FieldStart("budget_tokens")
				e.Int(s.BudgetTokens)
			}
		}
	}
}

// Decode decodes PromptAnthropicInvocationParametersContentThinking from json.
func (s *PromptAnthropicInvocationParametersContentThinking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAnthropicInvocationParametersContentThinking to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "disabled":
					s.Type = PromptAnthropicThinkingConfigDisabledPromptAnthropicInvocationParametersContentThinking
					found = true
				case "enabled":
					s.Type = PromptAnthropicThinkingConfigEnabledPromptAnthropicInvocationParametersContentThinking
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PromptAnthropicThinkingConfigDisabledPromptAnthropicInvocationParametersContentThinking:
		if err := s.PromptAnthropicThinkingConfigDisabled.Decode(d); err != nil {
			return err
		}
	case PromptAnthropicThinkingConfigEnabledPromptAnthropicInvocationParametersContentThinking:
		if err := s.PromptAnthropicThinkingConfigEnabled.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptAnthropicInvocationParametersContentThinking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAnthropicInvocationParametersContentThinking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptAnthropicInvocationParametersType as json.
func (s PromptAnthropicInvocationParametersType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptAnthropicInvocationParametersType from json.
func (s *PromptAnthropicInvocationParametersType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAnthropicInvocationParametersType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptAnthropicInvocationParametersType(v) {
	case PromptAnthropicInvocationParametersTypeAnthropic:
		*s = PromptAnthropicInvocationParametersTypeAnthropic
	default:
		*s = PromptAnthropicInvocationParametersType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptAnthropicInvocationParametersType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAnthropicInvocationParametersType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptAnthropicThinkingConfigDisabled) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptAnthropicThinkingConfigDisabled) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptAnthropicThinkingConfigDisabled = [1]string{
	0: "type",
}

// Decode decodes PromptAnthropicThinkingConfigDisabled from json.
func (s *PromptAnthropicThinkingConfigDisabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAnthropicThinkingConfigDisabled to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptAnthropicThinkingConfigDisabled")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptAnthropicThinkingConfigDisabled) {
					name = jsonFieldsNameOfPromptAnthropicThinkingConfigDisabled[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptAnthropicThinkingConfigDisabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAnthropicThinkingConfigDisabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptAnthropicThinkingConfigDisabledType as json.
func (s PromptAnthropicThinkingConfigDisabledType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptAnthropicThinkingConfigDisabledType from json.
func (s *PromptAnthropicThinkingConfigDisabledType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAnthropicThinkingConfigDisabledType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptAnthropicThinkingConfigDisabledType(v) {
	case PromptAnthropicThinkingConfigDisabledTypeDisabled:
		*s = PromptAnthropicThinkingConfigDisabledTypeDisabled
	default:
		*s = PromptAnthropicThinkingConfigDisabledType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptAnthropicThinkingConfigDisabledType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAnthropicThinkingConfigDisabledType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptAnthropicThinkingConfigEnabled) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptAnthropicThinkingConfigEnabled) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("budget_tokens")
		e.Int(s.BudgetTokens)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptAnthropicThinkingConfigEnabled = [2]string{
	0: "budget_tokens",
	1: "type",
}

// Decode decodes PromptAnthropicThinkingConfigEnabled from json.
func (s *PromptAnthropicThinkingConfigEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAnthropicThinkingConfigEnabled to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "budget_tokens":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.BudgetTokens = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_tokens\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptAnthropicThinkingConfigEnabled")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptAnthropicThinkingConfigEnabled) {
					name = jsonFieldsNameOfPromptAnthropicThinkingConfigEnabled[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptAnthropicThinkingConfigEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAnthropicThinkingConfigEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptAnthropicThinkingConfigEnabledType as json.
func (s PromptAnthropicThinkingConfigEnabledType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptAnthropicThinkingConfigEnabledType from json.
func (s *PromptAnthropicThinkingConfigEnabledType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAnthropicThinkingConfigEnabledType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptAnthropicThinkingConfigEnabledType(v) {
	case PromptAnthropicThinkingConfigEnabledTypeEnabled:
		*s = PromptAnthropicThinkingConfigEnabledTypeEnabled
	default:
		*s = PromptAnthropicThinkingConfigEnabledType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptAnthropicThinkingConfigEnabledType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAnthropicThinkingConfigEnabledType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptAwsInvocationParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptAwsInvocationParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("aws")
		s.AWS.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptAwsInvocationParameters = [2]string{
	0: "aws",
	1: "type",
}

// Decode decodes PromptAwsInvocationParameters from json.
func (s *PromptAwsInvocationParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAwsInvocationParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "aws":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AWS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aws\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptAwsInvocationParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptAwsInvocationParameters) {
					name = jsonFieldsNameOfPromptAwsInvocationParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptAwsInvocationParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAwsInvocationParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptAwsInvocationParametersContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptAwsInvocationParametersContent) encodeFields(e *jx.Encoder) {
	{
		if s.MaxTokens.Set {
			e.FieldStart("max_tokens")
			s.MaxTokens.Encode(e)
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptAwsInvocationParametersContent = [3]string{
	0: "max_tokens",
	1: "temperature",
	2: "top_p",
}

// Decode decodes PromptAwsInvocationParametersContent from json.
func (s *PromptAwsInvocationParametersContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAwsInvocationParametersContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max_tokens":
			if err := func() error {
				s.MaxTokens.Reset()
				if err := s.MaxTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tokens\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptAwsInvocationParametersContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptAwsInvocationParametersContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAwsInvocationParametersContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptAwsInvocationParametersType as json.
func (s PromptAwsInvocationParametersType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptAwsInvocationParametersType from json.
func (s *PromptAwsInvocationParametersType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAwsInvocationParametersType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptAwsInvocationParametersType(v) {
	case PromptAwsInvocationParametersTypeAWS:
		*s = PromptAwsInvocationParametersTypeAWS
	default:
		*s = PromptAwsInvocationParametersType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptAwsInvocationParametersType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAwsInvocationParametersType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptAzureOpenAIInvocationParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptAzureOpenAIInvocationParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("azure_openai")
		s.AzureOpenai.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptAzureOpenAIInvocationParameters = [2]string{
	0: "azure_openai",
	1: "type",
}

// Decode decodes PromptAzureOpenAIInvocationParameters from json.
func (s *PromptAzureOpenAIInvocationParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAzureOpenAIInvocationParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "azure_openai":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AzureOpenai.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azure_openai\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptAzureOpenAIInvocationParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptAzureOpenAIInvocationParameters) {
					name = jsonFieldsNameOfPromptAzureOpenAIInvocationParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptAzureOpenAIInvocationParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAzureOpenAIInvocationParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptAzureOpenAIInvocationParametersContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptAzureOpenAIInvocationParametersContent) encodeFields(e *jx.Encoder) {
	{
		if s.FrequencyPenalty.Set {
			e.FieldStart("frequency_penalty")
			s.FrequencyPenalty.Encode(e)
		}
	}
	{
		if s.MaxCompletionTokens.Set {
			e.FieldStart("max_completion_tokens")
			s.MaxCompletionTokens.Encode(e)
		}
	}
	{
		if s.MaxTokens.Set {
			e.FieldStart("max_tokens")
			s.MaxTokens.Encode(e)
		}
	}
	{
		if s.PresencePenalty.Set {
			e.FieldStart("presence_penalty")
			s.PresencePenalty.Encode(e)
		}
	}
	{
		if s.ReasoningEffort.Set {
			e.FieldStart("reasoning_effort")
			s.ReasoningEffort.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptAzureOpenAIInvocationParametersContent = [8]string{
	0: "frequency_penalty",
	1: "max_completion_tokens",
	2: "max_tokens",
	3: "presence_penalty",
	4: "reasoning_effort",
	5: "seed",
	6: "temperature",
	7: "top_p",
}

// Decode decodes PromptAzureOpenAIInvocationParametersContent from json.
func (s *PromptAzureOpenAIInvocationParametersContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAzureOpenAIInvocationParametersContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "frequency_penalty":
			if err := func() error {
				s.FrequencyPenalty.Reset()
				if err := s.FrequencyPenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency_penalty\"")
			}
		case "max_completion_tokens":
			if err := func() error {
				s.MaxCompletionTokens.Reset()
				if err := s.MaxCompletionTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_completion_tokens\"")
			}
		case "max_tokens":
			if err := func() error {
				s.MaxTokens.Reset()
				if err := s.MaxTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tokens\"")
			}
		case "presence_penalty":
			if err := func() error {
				s.PresencePenalty.Reset()
				if err := s.PresencePenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"presence_penalty\"")
			}
		case "reasoning_effort":
			if err := func() error {
				s.ReasoningEffort.Reset()
				if err := s.ReasoningEffort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reasoning_effort\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptAzureOpenAIInvocationParametersContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptAzureOpenAIInvocationParametersContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAzureOpenAIInvocationParametersContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptAzureOpenAIInvocationParametersContentReasoningEffort as json.
func (s PromptAzureOpenAIInvocationParametersContentReasoningEffort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptAzureOpenAIInvocationParametersContentReasoningEffort from json.
func (s *PromptAzureOpenAIInvocationParametersContentReasoningEffort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAzureOpenAIInvocationParametersContentReasoningEffort to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptAzureOpenAIInvocationParametersContentReasoningEffort(v) {
	case PromptAzureOpenAIInvocationParametersContentReasoningEffortNone:
		*s = PromptAzureOpenAIInvocationParametersContentReasoningEffortNone
	case PromptAzureOpenAIInvocationParametersContentReasoningEffortMinimal:
		*s = PromptAzureOpenAIInvocationParametersContentReasoningEffortMinimal
	case PromptAzureOpenAIInvocationParametersContentReasoningEffortLow:
		*s = PromptAzureOpenAIInvocationParametersContentReasoningEffortLow
	case PromptAzureOpenAIInvocationParametersContentReasoningEffortMedium:
		*s = PromptAzureOpenAIInvocationParametersContentReasoningEffortMedium
	case PromptAzureOpenAIInvocationParametersContentReasoningEffortHigh:
		*s = PromptAzureOpenAIInvocationParametersContentReasoningEffortHigh
	case PromptAzureOpenAIInvocationParametersContentReasoningEffortXhigh:
		*s = PromptAzureOpenAIInvocationParametersContentReasoningEffortXhigh
	default:
		*s = PromptAzureOpenAIInvocationParametersContentReasoningEffort(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptAzureOpenAIInvocationParametersContentReasoningEffort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAzureOpenAIInvocationParametersContentReasoningEffort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptAzureOpenAIInvocationParametersType as json.
func (s PromptAzureOpenAIInvocationParametersType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptAzureOpenAIInvocationParametersType from json.
func (s *PromptAzureOpenAIInvocationParametersType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAzureOpenAIInvocationParametersType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptAzureOpenAIInvocationParametersType(v) {
	case PromptAzureOpenAIInvocationParametersTypeAzureOpenai:
		*s = PromptAzureOpenAIInvocationParametersTypeAzureOpenai
	default:
		*s = PromptAzureOpenAIInvocationParametersType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptAzureOpenAIInvocationParametersType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAzureOpenAIInvocationParametersType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptChatTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptChatTemplate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("messages")
		e.ArrStart()
		for _, elem := range s.Messages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptChatTemplate = [2]string{
	0: "messages",
	1: "type",
}

// Decode decodes PromptChatTemplate from json.
func (s *PromptChatTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptChatTemplate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Messages = make([]PromptMessage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PromptMessage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Messages = append(s.Messages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messages\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptChatTemplate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptChatTemplate) {
					name = jsonFieldsNameOfPromptChatTemplate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptChatTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptChatTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptChatTemplateType as json.
func (s PromptChatTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptChatTemplateType from json.
func (s *PromptChatTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptChatTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptChatTemplateType(v) {
	case PromptChatTemplateTypeChat:
		*s = PromptChatTemplateTypeChat
	default:
		*s = PromptChatTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptChatTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptChatTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptData) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.SourcePromptID.Set {
			e.FieldStart("source_prompt_id")
			s.SourcePromptID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptData = [4]string{
	0: "description",
	1: "metadata",
	2: "name",
	3: "source_prompt_id",
}

// Decode decodes PromptData from json.
func (s *PromptData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "source_prompt_id":
			if err := func() error {
				s.SourcePromptID.Reset()
				if err := s.SourcePromptID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_prompt_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptData) {
					name = jsonFieldsNameOfPromptData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PromptDataMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PromptDataMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes PromptDataMetadata from json.
func (s *PromptDataMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptDataMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptDataMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptDataMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptDataMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptDeepSeekInvocationParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptDeepSeekInvocationParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("deepseek")
		s.Deepseek.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptDeepSeekInvocationParameters = [2]string{
	0: "deepseek",
	1: "type",
}

// Decode decodes PromptDeepSeekInvocationParameters from json.
func (s *PromptDeepSeekInvocationParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptDeepSeekInvocationParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deepseek":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Deepseek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deepseek\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptDeepSeekInvocationParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptDeepSeekInvocationParameters) {
					name = jsonFieldsNameOfPromptDeepSeekInvocationParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptDeepSeekInvocationParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptDeepSeekInvocationParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptDeepSeekInvocationParametersContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptDeepSeekInvocationParametersContent) encodeFields(e *jx.Encoder) {
	{
		if s.FrequencyPenalty.Set {
			e.FieldStart("frequency_penalty")
			s.FrequencyPenalty.Encode(e)
		}
	}
	{
		if s.MaxCompletionTokens.Set {
			e.FieldStart("max_completion_tokens")
			s.MaxCompletionTokens.Encode(e)
		}
	}
	{
		if s.MaxTokens.Set {
			e.FieldStart("max_tokens")
			s.MaxTokens.Encode(e)
		}
	}
	{
		if s.PresencePenalty.Set {
			e.FieldStart("presence_penalty")
			s.PresencePenalty.Encode(e)
		}
	}
	{
		if s.ReasoningEffort.Set {
			e.FieldStart("reasoning_effort")
			s.ReasoningEffort.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptDeepSeekInvocationParametersContent = [8]string{
	0: "frequency_penalty",
	1: "max_completion_tokens",
	2: "max_tokens",
	3: "presence_penalty",
	4: "reasoning_effort",
	5: "seed",
	6: "temperature",
	7: "top_p",
}

// Decode decodes PromptDeepSeekInvocationParametersContent from json.
func (s *PromptDeepSeekInvocationParametersContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptDeepSeekInvocationParametersContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "frequency_penalty":
			if err := func() error {
				s.FrequencyPenalty.Reset()
				if err := s.FrequencyPenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency_penalty\"")
			}
		case "max_completion_tokens":
			if err := func() error {
				s.MaxCompletionTokens.Reset()
				if err := s.MaxCompletionTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_completion_tokens\"")
			}
		case "max_tokens":
			if err := func() error {
				s.MaxTokens.Reset()
				if err := s.MaxTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tokens\"")
			}
		case "presence_penalty":
			if err := func() error {
				s.PresencePenalty.Reset()
				if err := s.PresencePenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"presence_penalty\"")
			}
		case "reasoning_effort":
			if err := func() error {
				s.ReasoningEffort.Reset()
				if err := s.ReasoningEffort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reasoning_effort\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptDeepSeekInvocationParametersContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptDeepSeekInvocationParametersContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptDeepSeekInvocationParametersContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptDeepSeekInvocationParametersContentReasoningEffort as json.
func (s PromptDeepSeekInvocationParametersContentReasoningEffort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptDeepSeekInvocationParametersContentReasoningEffort from json.
func (s *PromptDeepSeekInvocationParametersContentReasoningEffort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptDeepSeekInvocationParametersContentReasoningEffort to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptDeepSeekInvocationParametersContentReasoningEffort(v) {
	case PromptDeepSeekInvocationParametersContentReasoningEffortNone:
		*s = PromptDeepSeekInvocationParametersContentReasoningEffortNone
	case PromptDeepSeekInvocationParametersContentReasoningEffortMinimal:
		*s = PromptDeepSeekInvocationParametersContentReasoningEffortMinimal
	case PromptDeepSeekInvocationParametersContentReasoningEffortLow:
		*s = PromptDeepSeekInvocationParametersContentReasoningEffortLow
	case PromptDeepSeekInvocationParametersContentReasoningEffortMedium:
		*s = PromptDeepSeekInvocationParametersContentReasoningEffortMedium
	case PromptDeepSeekInvocationParametersContentReasoningEffortHigh:
		*s = PromptDeepSeekInvocationParametersContentReasoningEffortHigh
	case PromptDeepSeekInvocationParametersContentReasoningEffortXhigh:
		*s = PromptDeepSeekInvocationParametersContentReasoningEffortXhigh
	default:
		*s = PromptDeepSeekInvocationParametersContentReasoningEffort(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptDeepSeekInvocationParametersContentReasoningEffort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptDeepSeekInvocationParametersContentReasoningEffort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptDeepSeekInvocationParametersType as json.
func (s PromptDeepSeekInvocationParametersType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptDeepSeekInvocationParametersType from json.
func (s *PromptDeepSeekInvocationParametersType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptDeepSeekInvocationParametersType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptDeepSeekInvocationParametersType(v) {
	case PromptDeepSeekInvocationParametersTypeDeepseek:
		*s = PromptDeepSeekInvocationParametersTypeDeepseek
	default:
		*s = PromptDeepSeekInvocationParametersType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptDeepSeekInvocationParametersType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptDeepSeekInvocationParametersType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptGoogleInvocationParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptGoogleInvocationParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("google")
		s.Google.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptGoogleInvocationParameters = [2]string{
	0: "google",
	1: "type",
}

// Decode decodes PromptGoogleInvocationParameters from json.
func (s *PromptGoogleInvocationParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptGoogleInvocationParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "google":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Google.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptGoogleInvocationParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptGoogleInvocationParameters) {
					name = jsonFieldsNameOfPromptGoogleInvocationParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptGoogleInvocationParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptGoogleInvocationParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptGoogleInvocationParametersContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptGoogleInvocationParametersContent) encodeFields(e *jx.Encoder) {
	{
		if s.FrequencyPenalty.Set {
			e.FieldStart("frequency_penalty")
			s.FrequencyPenalty.Encode(e)
		}
	}
	{
		if s.MaxOutputTokens.Set {
			e.FieldStart("max_output_tokens")
			s.MaxOutputTokens.Encode(e)
		}
	}
	{
		if s.PresencePenalty.Set {
			e.FieldStart("presence_penalty")
			s.PresencePenalty.Encode(e)
		}
	}
	{
		if s.StopSequences != nil {
			e.FieldStart("stop_sequences")
			e.ArrStart()
			for _, elem := range s.StopSequences {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.TopK.Set {
			e.FieldStart("top_k")
			s.TopK.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptGoogleInvocationParametersContent = [7]string{
	0: "frequency_penalty",
	1: "max_output_tokens",
	2: "presence_penalty",
	3: "stop_sequences",
	4: "temperature",
	5: "top_k",
	6: "top_p",
}

// Decode decodes PromptGoogleInvocationParametersContent from json.
func (s *PromptGoogleInvocationParametersContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptGoogleInvocationParametersContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "frequency_penalty":
			if err := func() error {
				s.FrequencyPenalty.Reset()
				if err := s.FrequencyPenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency_penalty\"")
			}
		case "max_output_tokens":
			if err := func() error {
				s.MaxOutputTokens.Reset()
				if err := s.MaxOutputTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_output_tokens\"")
			}
		case "presence_penalty":
			if err := func() error {
				s.PresencePenalty.Reset()
				if err := s.PresencePenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"presence_penalty\"")
			}
		case "stop_sequences":
			if err := func() error {
				s.StopSequences = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StopSequences = append(s.StopSequences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_sequences\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "top_k":
			if err := func() error {
				s.TopK.Reset()
				if err := s.TopK.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_k\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptGoogleInvocationParametersContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptGoogleInvocationParametersContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptGoogleInvocationParametersContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptGoogleInvocationParametersType as json.
func (s PromptGoogleInvocationParametersType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptGoogleInvocationParametersType from json.
func (s *PromptGoogleInvocationParametersType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptGoogleInvocationParametersType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptGoogleInvocationParametersType(v) {
	case PromptGoogleInvocationParametersTypeGoogle:
		*s = PromptGoogleInvocationParametersTypeGoogle
	default:
		*s = PromptGoogleInvocationParametersType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptGoogleInvocationParametersType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptGoogleInvocationParametersType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
}

var jsonFieldsNameOfPromptMessage = [2]string{
	0: "content",
	1: "role",
}

// Decode decodes PromptMessage from json.
func (s *PromptMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptMessage) {
					name = jsonFieldsNameOfPromptMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptMessageContent as json.
func (s PromptMessageContent) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringPromptMessageContent:
		e.Str(s.String)
	case PromptMessageContent1ItemArrayPromptMessageContent:
		e.ArrStart()
		for _, elem := range s.PromptMessageContent1ItemArray {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes PromptMessageContent from json.
func (s *PromptMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptMessageContent to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.PromptMessageContent1ItemArray = make([]PromptMessageContent1Item, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PromptMessageContent1Item
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.PromptMessageContent1ItemArray = append(s.PromptMessageContent1ItemArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = PromptMessageContent1ItemArrayPromptMessageContent
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringPromptMessageContent
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptMessageContent1Item as json.
func (s PromptMessageContent1Item) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PromptMessageContent1Item) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case TextContentPartPromptMessageContent1Item:
		e.FieldStart("type")
		e.Str("text")
		{
			s := s.TextContentPart
			{
				e.FieldStart("text")
				e.Str(s.Text)
			}
		}
	case ToolCallContentPartPromptMessageContent1Item:
		e.FieldStart("type")
		e.Str("tool_call")
		{
			s := s.ToolCallContentPart
			{
				e.FieldStart("tool_call")
				s.ToolCall.Encode(e)
			}
			{
				e.FieldStart("tool_call_id")
				e.Str(s.ToolCallID)
			}
		}
	case ToolResultContentPartPromptMessageContent1Item:
		e.FieldStart("type")
		e.Str("tool_result")
		{
			s := s.ToolResultContentPart
			{
				e.FieldStart("tool_call_id")
				e.Str(s.ToolCallID)
			}
			{
				e.FieldStart("tool_result")
				s.ToolResult.Encode(e)
			}
		}
	}
}

// Decode decodes PromptMessageContent1Item from json.
func (s *PromptMessageContent1Item) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptMessageContent1Item to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "text":
					s.Type = TextContentPartPromptMessageContent1Item
					found = true
				case "tool_call":
					s.Type = ToolCallContentPartPromptMessageContent1Item
					found = true
				case "tool_result":
					s.Type = ToolResultContentPartPromptMessageContent1Item
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case TextContentPartPromptMessageContent1Item:
		if err := s.TextContentPart.Decode(d); err != nil {
			return err
		}
	case ToolCallContentPartPromptMessageContent1Item:
		if err := s.ToolCallContentPart.Decode(d); err != nil {
			return err
		}
	case ToolResultContentPartPromptMessageContent1Item:
		if err := s.ToolResultContentPart.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptMessageContent1Item) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptMessageContent1Item) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptMessageRole as json.
func (s PromptMessageRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptMessageRole from json.
func (s *PromptMessageRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptMessageRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptMessageRole(v) {
	case PromptMessageRoleUser:
		*s = PromptMessageRoleUser
	case PromptMessageRoleAssistant:
		*s = PromptMessageRoleAssistant
	case PromptMessageRoleModel:
		*s = PromptMessageRoleModel
	case PromptMessageRoleAi:
		*s = PromptMessageRoleAi
	case PromptMessageRoleTool:
		*s = PromptMessageRoleTool
	case PromptMessageRoleSystem:
		*s = PromptMessageRoleSystem
	case PromptMessageRoleDeveloper:
		*s = PromptMessageRoleDeveloper
	default:
		*s = PromptMessageRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptMessageRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptMessageRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PromptMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PromptMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes PromptMetadata from json.
func (s *PromptMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptOllamaInvocationParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptOllamaInvocationParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ollama")
		s.Ollama.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptOllamaInvocationParameters = [2]string{
	0: "ollama",
	1: "type",
}

// Decode decodes PromptOllamaInvocationParameters from json.
func (s *PromptOllamaInvocationParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptOllamaInvocationParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ollama":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Ollama.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ollama\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptOllamaInvocationParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptOllamaInvocationParameters) {
					name = jsonFieldsNameOfPromptOllamaInvocationParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptOllamaInvocationParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptOllamaInvocationParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptOllamaInvocationParametersContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptOllamaInvocationParametersContent) encodeFields(e *jx.Encoder) {
	{
		if s.FrequencyPenalty.Set {
			e.FieldStart("frequency_penalty")
			s.FrequencyPenalty.Encode(e)
		}
	}
	{
		if s.MaxCompletionTokens.Set {
			e.FieldStart("max_completion_tokens")
			s.MaxCompletionTokens.Encode(e)
		}
	}
	{
		if s.MaxTokens.Set {
			e.FieldStart("max_tokens")
			s.MaxTokens.Encode(e)
		}
	}
	{
		if s.PresencePenalty.Set {
			e.FieldStart("presence_penalty")
			s.PresencePenalty.Encode(e)
		}
	}
	{
		if s.ReasoningEffort.Set {
			e.FieldStart("reasoning_effort")
			s.ReasoningEffort.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptOllamaInvocationParametersContent = [8]string{
	0: "frequency_penalty",
	1: "max_completion_tokens",
	2: "max_tokens",
	3: "presence_penalty",
	4: "reasoning_effort",
	5: "seed",
	6: "temperature",
	7: "top_p",
}

// Decode decodes PromptOllamaInvocationParametersContent from json.
func (s *PromptOllamaInvocationParametersContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptOllamaInvocationParametersContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "frequency_penalty":
			if err := func() error {
				s.FrequencyPenalty.Reset()
				if err := s.FrequencyPenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency_penalty\"")
			}
		case "max_completion_tokens":
			if err := func() error {
				s.MaxCompletionTokens.Reset()
				if err := s.MaxCompletionTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_completion_tokens\"")
			}
		case "max_tokens":
			if err := func() error {
				s.MaxTokens.Reset()
				if err := s.MaxTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tokens\"")
			}
		case "presence_penalty":
			if err := func() error {
				s.PresencePenalty.Reset()
				if err := s.PresencePenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"presence_penalty\"")
			}
		case "reasoning_effort":
			if err := func() error {
				s.ReasoningEffort.Reset()
				if err := s.ReasoningEffort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reasoning_effort\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptOllamaInvocationParametersContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptOllamaInvocationParametersContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptOllamaInvocationParametersContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptOllamaInvocationParametersContentReasoningEffort as json.
func (s PromptOllamaInvocationParametersContentReasoningEffort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptOllamaInvocationParametersContentReasoningEffort from json.
func (s *PromptOllamaInvocationParametersContentReasoningEffort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptOllamaInvocationParametersContentReasoningEffort to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptOllamaInvocationParametersContentReasoningEffort(v) {
	case PromptOllamaInvocationParametersContentReasoningEffortNone:
		*s = PromptOllamaInvocationParametersContentReasoningEffortNone
	case PromptOllamaInvocationParametersContentReasoningEffortMinimal:
		*s = PromptOllamaInvocationParametersContentReasoningEffortMinimal
	case PromptOllamaInvocationParametersContentReasoningEffortLow:
		*s = PromptOllamaInvocationParametersContentReasoningEffortLow
	case PromptOllamaInvocationParametersContentReasoningEffortMedium:
		*s = PromptOllamaInvocationParametersContentReasoningEffortMedium
	case PromptOllamaInvocationParametersContentReasoningEffortHigh:
		*s = PromptOllamaInvocationParametersContentReasoningEffortHigh
	case PromptOllamaInvocationParametersContentReasoningEffortXhigh:
		*s = PromptOllamaInvocationParametersContentReasoningEffortXhigh
	default:
		*s = PromptOllamaInvocationParametersContentReasoningEffort(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptOllamaInvocationParametersContentReasoningEffort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptOllamaInvocationParametersContentReasoningEffort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptOllamaInvocationParametersType as json.
func (s PromptOllamaInvocationParametersType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptOllamaInvocationParametersType from json.
func (s *PromptOllamaInvocationParametersType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptOllamaInvocationParametersType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptOllamaInvocationParametersType(v) {
	case PromptOllamaInvocationParametersTypeOllama:
		*s = PromptOllamaInvocationParametersTypeOllama
	default:
		*s = PromptOllamaInvocationParametersType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptOllamaInvocationParametersType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptOllamaInvocationParametersType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptOpenAIInvocationParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptOpenAIInvocationParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("openai")
		s.Openai.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptOpenAIInvocationParameters = [2]string{
	0: "openai",
	1: "type",
}

// Decode decodes PromptOpenAIInvocationParameters from json.
func (s *PromptOpenAIInvocationParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptOpenAIInvocationParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "openai":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Openai.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openai\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptOpenAIInvocationParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptOpenAIInvocationParameters) {
					name = jsonFieldsNameOfPromptOpenAIInvocationParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptOpenAIInvocationParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptOpenAIInvocationParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptOpenAIInvocationParametersContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptOpenAIInvocationParametersContent) encodeFields(e *jx.Encoder) {
	{
		if s.FrequencyPenalty.Set {
			e.FieldStart("frequency_penalty")
			s.FrequencyPenalty.Encode(e)
		}
	}
	{
		if s.MaxCompletionTokens.Set {
			e.FieldStart("max_completion_tokens")
			s.MaxCompletionTokens.Encode(e)
		}
	}
	{
		if s.MaxTokens.Set {
			e.FieldStart("max_tokens")
			s.MaxTokens.Encode(e)
		}
	}
	{
		if s.PresencePenalty.Set {
			e.FieldStart("presence_penalty")
			s.PresencePenalty.Encode(e)
		}
	}
	{
		if s.ReasoningEffort.Set {
			e.FieldStart("reasoning_effort")
			s.ReasoningEffort.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptOpenAIInvocationParametersContent = [8]string{
	0: "frequency_penalty",
	1: "max_completion_tokens",
	2: "max_tokens",
	3: "presence_penalty",
	4: "reasoning_effort",
	5: "seed",
	6: "temperature",
	7: "top_p",
}

// Decode decodes PromptOpenAIInvocationParametersContent from json.
func (s *PromptOpenAIInvocationParametersContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptOpenAIInvocationParametersContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "frequency_penalty":
			if err := func() error {
				s.FrequencyPenalty.Reset()
				if err := s.FrequencyPenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency_penalty\"")
			}
		case "max_completion_tokens":
			if err := func() error {
				s.MaxCompletionTokens.Reset()
				if err := s.MaxCompletionTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_completion_tokens\"")
			}
		case "max_tokens":
			if err := func() error {
				s.MaxTokens.Reset()
				if err := s.MaxTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tokens\"")
			}
		case "presence_penalty":
			if err := func() error {
				s.PresencePenalty.Reset()
				if err := s.PresencePenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"presence_penalty\"")
			}
		case "reasoning_effort":
			if err := func() error {
				s.ReasoningEffort.Reset()
				if err := s.ReasoningEffort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reasoning_effort\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptOpenAIInvocationParametersContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptOpenAIInvocationParametersContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptOpenAIInvocationParametersContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptOpenAIInvocationParametersContentReasoningEffort as json.
func (s PromptOpenAIInvocationParametersContentReasoningEffort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptOpenAIInvocationParametersContentReasoningEffort from json.
func (s *PromptOpenAIInvocationParametersContentReasoningEffort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptOpenAIInvocationParametersContentReasoningEffort to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptOpenAIInvocationParametersContentReasoningEffort(v) {
	case PromptOpenAIInvocationParametersContentReasoningEffortNone:
		*s = PromptOpenAIInvocationParametersContentReasoningEffortNone
	case PromptOpenAIInvocationParametersContentReasoningEffortMinimal:
		*s = PromptOpenAIInvocationParametersContentReasoningEffortMinimal
	case PromptOpenAIInvocationParametersContentReasoningEffortLow:
		*s = PromptOpenAIInvocationParametersContentReasoningEffortLow
	case PromptOpenAIInvocationParametersContentReasoningEffortMedium:
		*s = PromptOpenAIInvocationParametersContentReasoningEffortMedium
	case PromptOpenAIInvocationParametersContentReasoningEffortHigh:
		*s = PromptOpenAIInvocationParametersContentReasoningEffortHigh
	case PromptOpenAIInvocationParametersContentReasoningEffortXhigh:
		*s = PromptOpenAIInvocationParametersContentReasoningEffortXhigh
	default:
		*s = PromptOpenAIInvocationParametersContentReasoningEffort(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptOpenAIInvocationParametersContentReasoningEffort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptOpenAIInvocationParametersContentReasoningEffort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptOpenAIInvocationParametersType as json.
func (s PromptOpenAIInvocationParametersType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptOpenAIInvocationParametersType from json.
func (s *PromptOpenAIInvocationParametersType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptOpenAIInvocationParametersType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptOpenAIInvocationParametersType(v) {
	case PromptOpenAIInvocationParametersTypeOpenai:
		*s = PromptOpenAIInvocationParametersTypeOpenai
	default:
		*s = PromptOpenAIInvocationParametersType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptOpenAIInvocationParametersType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptOpenAIInvocationParametersType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptResponseFormatJSONSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptResponseFormatJSONSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("json_schema")
		s.JSONSchema.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptResponseFormatJSONSchema = [2]string{
	0: "json_schema",
	1: "type",
}

// Decode decodes PromptResponseFormatJSONSchema from json.
func (s *PromptResponseFormatJSONSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptResponseFormatJSONSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "json_schema":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.JSONSchema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"json_schema\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptResponseFormatJSONSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptResponseFormatJSONSchema) {
					name = jsonFieldsNameOfPromptResponseFormatJSONSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptResponseFormatJSONSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptResponseFormatJSONSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptResponseFormatJSONSchemaDefinition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptResponseFormatJSONSchemaDefinition) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Schema.Set {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
	{
		if s.Strict.Set {
			e.FieldStart("strict")
			s.Strict.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptResponseFormatJSONSchemaDefinition = [4]string{
	0: "description",
	1: "name",
	2: "schema",
	3: "strict",
}

// Decode decodes PromptResponseFormatJSONSchemaDefinition from json.
func (s *PromptResponseFormatJSONSchemaDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptResponseFormatJSONSchemaDefinition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		case "strict":
			if err := func() error {
				s.Strict.Reset()
				if err := s.Strict.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptResponseFormatJSONSchemaDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptResponseFormatJSONSchemaDefinition) {
					name = jsonFieldsNameOfPromptResponseFormatJSONSchemaDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptResponseFormatJSONSchemaDefinition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptResponseFormatJSONSchemaDefinition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PromptResponseFormatJSONSchemaDefinitionSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PromptResponseFormatJSONSchemaDefinitionSchema) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes PromptResponseFormatJSONSchemaDefinitionSchema from json.
func (s *PromptResponseFormatJSONSchemaDefinitionSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptResponseFormatJSONSchemaDefinitionSchema to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptResponseFormatJSONSchemaDefinitionSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptResponseFormatJSONSchemaDefinitionSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptResponseFormatJSONSchemaDefinitionSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptResponseFormatJSONSchemaType as json.
func (s PromptResponseFormatJSONSchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptResponseFormatJSONSchemaType from json.
func (s *PromptResponseFormatJSONSchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptResponseFormatJSONSchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptResponseFormatJSONSchemaType(v) {
	case PromptResponseFormatJSONSchemaTypeJSONSchema:
		*s = PromptResponseFormatJSONSchemaTypeJSONSchema
	default:
		*s = PromptResponseFormatJSONSchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptResponseFormatJSONSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptResponseFormatJSONSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptStringTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptStringTemplate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("template")
		e.Str(s.Template)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptStringTemplate = [2]string{
	0: "template",
	1: "type",
}

// Decode decodes PromptStringTemplate from json.
func (s *PromptStringTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptStringTemplate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "template":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Template = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptStringTemplate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptStringTemplate) {
					name = jsonFieldsNameOfPromptStringTemplate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptStringTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptStringTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptStringTemplateType as json.
func (s PromptStringTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptStringTemplateType from json.
func (s *PromptStringTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptStringTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptStringTemplateType(v) {
	case PromptStringTemplateTypeString:
		*s = PromptStringTemplateTypeString
	default:
		*s = PromptStringTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptStringTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptStringTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptTemplateFormat as json.
func (s PromptTemplateFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptTemplateFormat from json.
func (s *PromptTemplateFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptTemplateFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptTemplateFormat(v) {
	case PromptTemplateFormatMUSTACHE:
		*s = PromptTemplateFormatMUSTACHE
	case PromptTemplateFormatFSTRING:
		*s = PromptTemplateFormatFSTRING
	case PromptTemplateFormatNONE:
		*s = PromptTemplateFormatNONE
	default:
		*s = PromptTemplateFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptTemplateFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptTemplateFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptTemplateType as json.
func (s PromptTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptTemplateType from json.
func (s *PromptTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptTemplateType(v) {
	case PromptTemplateTypeSTR:
		*s = PromptTemplateTypeSTR
	case PromptTemplateTypeCHAT:
		*s = PromptTemplateTypeCHAT
	default:
		*s = PromptTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptToolChoiceNone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptToolChoiceNone) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptToolChoiceNone = [1]string{
	0: "type",
}

// Decode decodes PromptToolChoiceNone from json.
func (s *PromptToolChoiceNone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolChoiceNone to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptToolChoiceNone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptToolChoiceNone) {
					name = jsonFieldsNameOfPromptToolChoiceNone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptToolChoiceNone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolChoiceNone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptToolChoiceNoneType as json.
func (s PromptToolChoiceNoneType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptToolChoiceNoneType from json.
func (s *PromptToolChoiceNoneType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolChoiceNoneType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptToolChoiceNoneType(v) {
	case PromptToolChoiceNoneTypeNone:
		*s = PromptToolChoiceNoneTypeNone
	default:
		*s = PromptToolChoiceNoneType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptToolChoiceNoneType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolChoiceNoneType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptToolChoiceOneOrMore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptToolChoiceOneOrMore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptToolChoiceOneOrMore = [1]string{
	0: "type",
}

// Decode decodes PromptToolChoiceOneOrMore from json.
func (s *PromptToolChoiceOneOrMore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolChoiceOneOrMore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptToolChoiceOneOrMore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptToolChoiceOneOrMore) {
					name = jsonFieldsNameOfPromptToolChoiceOneOrMore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptToolChoiceOneOrMore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolChoiceOneOrMore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptToolChoiceOneOrMoreType as json.
func (s PromptToolChoiceOneOrMoreType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptToolChoiceOneOrMoreType from json.
func (s *PromptToolChoiceOneOrMoreType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolChoiceOneOrMoreType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptToolChoiceOneOrMoreType(v) {
	case PromptToolChoiceOneOrMoreTypeOneOrMore:
		*s = PromptToolChoiceOneOrMoreTypeOneOrMore
	default:
		*s = PromptToolChoiceOneOrMoreType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptToolChoiceOneOrMoreType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolChoiceOneOrMoreType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptToolChoiceSpecificFunctionTool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptToolChoiceSpecificFunctionTool) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("function_name")
		e.Str(s.FunctionName)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptToolChoiceSpecificFunctionTool = [2]string{
	0: "function_name",
	1: "type",
}

// Decode decodes PromptToolChoiceSpecificFunctionTool from json.
func (s *PromptToolChoiceSpecificFunctionTool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolChoiceSpecificFunctionTool to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "function_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FunctionName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function_name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptToolChoiceSpecificFunctionTool")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptToolChoiceSpecificFunctionTool) {
					name = jsonFieldsNameOfPromptToolChoiceSpecificFunctionTool[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptToolChoiceSpecificFunctionTool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolChoiceSpecificFunctionTool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptToolChoiceSpecificFunctionToolType as json.
func (s PromptToolChoiceSpecificFunctionToolType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptToolChoiceSpecificFunctionToolType from json.
func (s *PromptToolChoiceSpecificFunctionToolType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolChoiceSpecificFunctionToolType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptToolChoiceSpecificFunctionToolType(v) {
	case PromptToolChoiceSpecificFunctionToolTypeSpecificFunction:
		*s = PromptToolChoiceSpecificFunctionToolTypeSpecificFunction
	default:
		*s = PromptToolChoiceSpecificFunctionToolType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptToolChoiceSpecificFunctionToolType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolChoiceSpecificFunctionToolType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptToolChoiceZeroOrMore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptToolChoiceZeroOrMore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptToolChoiceZeroOrMore = [1]string{
	0: "type",
}

// Decode decodes PromptToolChoiceZeroOrMore from json.
func (s *PromptToolChoiceZeroOrMore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolChoiceZeroOrMore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptToolChoiceZeroOrMore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptToolChoiceZeroOrMore) {
					name = jsonFieldsNameOfPromptToolChoiceZeroOrMore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptToolChoiceZeroOrMore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolChoiceZeroOrMore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptToolChoiceZeroOrMoreType as json.
func (s PromptToolChoiceZeroOrMoreType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptToolChoiceZeroOrMoreType from json.
func (s *PromptToolChoiceZeroOrMoreType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolChoiceZeroOrMoreType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptToolChoiceZeroOrMoreType(v) {
	case PromptToolChoiceZeroOrMoreTypeZeroOrMore:
		*s = PromptToolChoiceZeroOrMoreTypeZeroOrMore
	default:
		*s = PromptToolChoiceZeroOrMoreType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptToolChoiceZeroOrMoreType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolChoiceZeroOrMoreType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptToolFunction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptToolFunction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("function")
		s.Function.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptToolFunction = [2]string{
	0: "function",
	1: "type",
}

// Decode decodes PromptToolFunction from json.
func (s *PromptToolFunction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolFunction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "function":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Function.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptToolFunction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptToolFunction) {
					name = jsonFieldsNameOfPromptToolFunction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptToolFunction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolFunction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptToolFunctionDefinition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptToolFunctionDefinition) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
	{
		if s.Strict.Set {
			e.FieldStart("strict")
			s.Strict.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptToolFunctionDefinition = [4]string{
	0: "description",
	1: "name",
	2: "parameters",
	3: "strict",
}

// Decode decodes PromptToolFunctionDefinition from json.
func (s *PromptToolFunctionDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolFunctionDefinition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "strict":
			if err := func() error {
				s.Strict.Reset()
				if err := s.Strict.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptToolFunctionDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptToolFunctionDefinition) {
					name = jsonFieldsNameOfPromptToolFunctionDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptToolFunctionDefinition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolFunctionDefinition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PromptToolFunctionDefinitionParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PromptToolFunctionDefinitionParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes PromptToolFunctionDefinitionParameters from json.
func (s *PromptToolFunctionDefinitionParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolFunctionDefinitionParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptToolFunctionDefinitionParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptToolFunctionDefinitionParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolFunctionDefinitionParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptToolFunctionType as json.
func (s PromptToolFunctionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptToolFunctionType from json.
func (s *PromptToolFunctionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolFunctionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptToolFunctionType(v) {
	case PromptToolFunctionTypeFunction:
		*s = PromptToolFunctionTypeFunction
	default:
		*s = PromptToolFunctionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptToolFunctionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolFunctionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptTools) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptTools) encodeFields(e *jx.Encoder) {
	{
		if s.DisableParallelToolCalls.Set {
			e.FieldStart("disable_parallel_tool_calls")
			s.DisableParallelToolCalls.Encode(e)
		}
	}
	{
		if s.ToolChoice.Set {
			e.FieldStart("tool_choice")
			s.ToolChoice.Encode(e)
		}
	}
	{
		e.FieldStart("tools")
		e.ArrStart()
		for _, elem := range s.Tools {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPromptTools = [4]string{
	0: "disable_parallel_tool_calls",
	1: "tool_choice",
	2: "tools",
	3: "type",
}

// Decode decodes PromptTools from json.
func (s *PromptTools) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptTools to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "disable_parallel_tool_calls":
			if err := func() error {
				s.DisableParallelToolCalls.Reset()
				if err := s.DisableParallelToolCalls.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_parallel_tool_calls\"")
			}
		case "tool_choice":
			if err := func() error {
				s.ToolChoice.Reset()
				if err := s.ToolChoice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_choice\"")
			}
		case "tools":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Tools = make([]PromptToolsToolsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PromptToolsToolsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tools = append(s.Tools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptTools")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptTools) {
					name = jsonFieldsNameOfPromptTools[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptTools) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptTools) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptToolsToolChoice as json.
func (s PromptToolsToolChoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PromptToolsToolChoice) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PromptToolChoiceNonePromptToolsToolChoice:
		e.FieldStart("type")
		e.Str("none")
	case PromptToolChoiceZeroOrMorePromptToolsToolChoice:
		e.FieldStart("type")
		e.Str("zero_or_more")
	case PromptToolChoiceOneOrMorePromptToolsToolChoice:
		e.FieldStart("type")
		e.Str("one_or_more")
	case PromptToolChoiceSpecificFunctionToolPromptToolsToolChoice:
		e.FieldStart("type")
		e.Str("specific_function")
		{
			s := s.PromptToolChoiceSpecificFunctionTool
			{
				e.FieldStart("function_name")
				e.Str(s.FunctionName)
			}
		}
	}
}

// Decode decodes PromptToolsToolChoice from json.
func (s *PromptToolsToolChoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolsToolChoice to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "none":
					s.Type = PromptToolChoiceNonePromptToolsToolChoice
					found = true
				case "zero_or_more":
					s.Type = PromptToolChoiceZeroOrMorePromptToolsToolChoice
					found = true
				case "one_or_more":
					s.Type = PromptToolChoiceOneOrMorePromptToolsToolChoice
					found = true
				case "specific_function":
					s.Type = PromptToolChoiceSpecificFunctionToolPromptToolsToolChoice
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PromptToolChoiceNonePromptToolsToolChoice:
		if err := s.PromptToolChoiceNone.Decode(d); err != nil {
			return err
		}
	case PromptToolChoiceZeroOrMorePromptToolsToolChoice:
		if err := s.PromptToolChoiceZeroOrMore.Decode(d); err != nil {
			return err
		}
	case PromptToolChoiceOneOrMorePromptToolsToolChoice:
		if err := s.PromptToolChoiceOneOrMore.Decode(d); err != nil {
			return err
		}
	case PromptToolChoiceSpecificFunctionToolPromptToolsToolChoice:
		if err := s.PromptToolChoiceSpecificFunctionTool.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptToolsToolChoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolsToolChoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptToolsToolsItem as json.
func (s PromptToolsToolsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PromptToolsToolsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PromptToolFunctionPromptToolsToolsItem:
		e.FieldStart("type")
		e.Str("function")
		{
			s := s.PromptToolFunction
			{
				e.FieldStart("function")
				s.Function.Encode(e)
			}
		}
	}
}

// Decode decodes PromptToolsToolsItem from json.
func (s *PromptToolsToolsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolsToolsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "function":
					s.Type = PromptToolFunctionPromptToolsToolsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PromptToolFunctionPromptToolsToolsItem:
		if err := s.PromptToolFunction.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptToolsToolsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolsToolsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptToolsType as json.
func (s PromptToolsType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptToolsType from json.
func (s *PromptToolsType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptToolsType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptToolsType(v) {
	case PromptToolsTypeTools:
		*s = PromptToolsTypeTools
	default:
		*s = PromptToolsType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptToolsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptToolsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersion) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("invocation_parameters")
		s.InvocationParameters.Encode(e)
	}
	{
		e.FieldStart("model_name")
		e.Str(s.ModelName)
	}
	{
		e.FieldStart("model_provider")
		s.ModelProvider.Encode(e)
	}
	{
		if s.ResponseFormat.Set {
			e.FieldStart("response_format")
			s.ResponseFormat.Encode(e)
		}
	}
	{
		e.FieldStart("template")
		s.Template.Encode(e)
	}
	{
		e.FieldStart("template_format")
		s.TemplateFormat.Encode(e)
	}
	{
		e.FieldStart("template_type")
		s.TemplateType.Encode(e)
	}
	{
		if s.Tools.Set {
			e.FieldStart("tools")
			s.Tools.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptVersion = [10]string{
	0: "description",
	1: "id",
	2: "invocation_parameters",
	3: "model_name",
	4: "model_provider",
	5: "response_format",
	6: "template",
	7: "template_format",
	8: "template_type",
	9: "tools",
}

// Decode decodes PromptVersion from json.
func (s *PromptVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersion to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "invocation_parameters":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.InvocationParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invocation_parameters\"")
			}
		case "model_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ModelName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_name\"")
			}
		case "model_provider":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.ModelProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_provider\"")
			}
		case "response_format":
			if err := func() error {
				s.ResponseFormat.Reset()
				if err := s.ResponseFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response_format\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "template_format":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.TemplateFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_format\"")
			}
		case "template_type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_type\"")
			}
		case "tools":
			if err := func() error {
				s.Tools.Reset()
				if err := s.Tools.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11011110,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptVersion) {
					name = jsonFieldsNameOfPromptVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersionData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersionData) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("invocation_parameters")
		s.InvocationParameters.Encode(e)
	}
	{
		e.FieldStart("model_name")
		e.Str(s.ModelName)
	}
	{
		e.FieldStart("model_provider")
		s.ModelProvider.Encode(e)
	}
	{
		if s.ResponseFormat.Set {
			e.FieldStart("response_format")
			s.ResponseFormat.Encode(e)
		}
	}
	{
		e.FieldStart("template")
		s.Template.Encode(e)
	}
	{
		e.FieldStart("template_format")
		s.TemplateFormat.Encode(e)
	}
	{
		e.FieldStart("template_type")
		s.TemplateType.Encode(e)
	}
	{
		if s.Tools.Set {
			e.FieldStart("tools")
			s.Tools.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptVersionData = [9]string{
	0: "description",
	1: "invocation_parameters",
	2: "model_name",
	3: "model_provider",
	4: "response_format",
	5: "template",
	6: "template_format",
	7: "template_type",
	8: "tools",
}

// Decode decodes PromptVersionData from json.
func (s *PromptVersionData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionData to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "invocation_parameters":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.InvocationParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invocation_parameters\"")
			}
		case "model_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ModelName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_name\"")
			}
		case "model_provider":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ModelProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_provider\"")
			}
		case "response_format":
			if err := func() error {
				s.ResponseFormat.Reset()
				if err := s.ResponseFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response_format\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "template_format":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.TemplateFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_format\"")
			}
		case "template_type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_type\"")
			}
		case "tools":
			if err := func() error {
				s.Tools.Reset()
				if err := s.Tools.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersionData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptVersionData) {
					name = jsonFieldsNameOfPromptVersionData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersionData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionDataInvocationParameters as json.
func (s PromptVersionDataInvocationParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PromptVersionDataInvocationParameters) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PromptOpenAIInvocationParametersPromptVersionDataInvocationParameters:
		e.FieldStart("type")
		e.Str("openai")
		{
			s := s.PromptOpenAIInvocationParameters
			{
				e.FieldStart("openai")
				s.Openai.Encode(e)
			}
		}
	case PromptAzureOpenAIInvocationParametersPromptVersionDataInvocationParameters:
		e.FieldStart("type")
		e.Str("azure_openai")
		{
			s := s.PromptAzureOpenAIInvocationParameters
			{
				e.FieldStart("azure_openai")
				s.AzureOpenai.Encode(e)
			}
		}
	case PromptAnthropicInvocationParametersPromptVersionDataInvocationParameters:
		e.FieldStart("type")
		e.Str("anthropic")
		{
			s := s.PromptAnthropicInvocationParameters
			{
				e.FieldStart("anthropic")
				s.Anthropic.Encode(e)
			}
		}
	case PromptGoogleInvocationParametersPromptVersionDataInvocationParameters:
		e.FieldStart("type")
		e.Str("google")
		{
			s := s.PromptGoogleInvocationParameters
			{
				e.FieldStart("google")
				s.Google.Encode(e)
			}
		}
	case PromptDeepSeekInvocationParametersPromptVersionDataInvocationParameters:
		e.FieldStart("type")
		e.Str("deepseek")
		{
			s := s.PromptDeepSeekInvocationParameters
			{
				e.FieldStart("deepseek")
				s.Deepseek.Encode(e)
			}
		}
	case PromptXAIInvocationParametersPromptVersionDataInvocationParameters:
		e.FieldStart("type")
		e.Str("xai")
		{
			s := s.PromptXAIInvocationParameters
			{
				e.FieldStart("xai")
				s.Xai.Encode(e)
			}
		}
	case PromptOllamaInvocationParametersPromptVersionDataInvocationParameters:
		e.FieldStart("type")
		e.Str("ollama")
		{
			s := s.PromptOllamaInvocationParameters
			{
				e.FieldStart("ollama")
				s.Ollama.Encode(e)
			}
		}
	case PromptAwsInvocationParametersPromptVersionDataInvocationParameters:
		e.FieldStart("type")
		e.Str("aws")
		{
			s := s.PromptAwsInvocationParameters
			{
				e.FieldStart("aws")
				s.AWS.Encode(e)
			}
		}
	}
}

// Decode decodes PromptVersionDataInvocationParameters from json.
func (s *PromptVersionDataInvocationParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionDataInvocationParameters to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "openai":
					s.Type = PromptOpenAIInvocationParametersPromptVersionDataInvocationParameters
					found = true
				case "azure_openai":
					s.Type = PromptAzureOpenAIInvocationParametersPromptVersionDataInvocationParameters
					found = true
				case "anthropic":
					s.Type = PromptAnthropicInvocationParametersPromptVersionDataInvocationParameters
					found = true
				case "google":
					s.Type = PromptGoogleInvocationParametersPromptVersionDataInvocationParameters
					found = true
				case "deepseek":
					s.Type = PromptDeepSeekInvocationParametersPromptVersionDataInvocationParameters
					found = true
				case "xai":
					s.Type = PromptXAIInvocationParametersPromptVersionDataInvocationParameters
					found = true
				case "ollama":
					s.Type = PromptOllamaInvocationParametersPromptVersionDataInvocationParameters
					found = true
				case "aws":
					s.Type = PromptAwsInvocationParametersPromptVersionDataInvocationParameters
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PromptOpenAIInvocationParametersPromptVersionDataInvocationParameters:
		if err := s.PromptOpenAIInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptAzureOpenAIInvocationParametersPromptVersionDataInvocationParameters:
		if err := s.PromptAzureOpenAIInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptAnthropicInvocationParametersPromptVersionDataInvocationParameters:
		if err := s.PromptAnthropicInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptGoogleInvocationParametersPromptVersionDataInvocationParameters:
		if err := s.PromptGoogleInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptDeepSeekInvocationParametersPromptVersionDataInvocationParameters:
		if err := s.PromptDeepSeekInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptXAIInvocationParametersPromptVersionDataInvocationParameters:
		if err := s.PromptXAIInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptOllamaInvocationParametersPromptVersionDataInvocationParameters:
		if err := s.PromptOllamaInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptAwsInvocationParametersPromptVersionDataInvocationParameters:
		if err := s.PromptAwsInvocationParameters.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptVersionDataInvocationParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionDataInvocationParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionDataResponseFormat as json.
func (s PromptVersionDataResponseFormat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PromptVersionDataResponseFormat) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PromptResponseFormatJSONSchemaPromptVersionDataResponseFormat:
		e.FieldStart("type")
		e.Str("json_schema")
		{
			s := s.PromptResponseFormatJSONSchema
			{
				e.FieldStart("json_schema")
				s.JSONSchema.Encode(e)
			}
		}
	}
}

// Decode decodes PromptVersionDataResponseFormat from json.
func (s *PromptVersionDataResponseFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionDataResponseFormat to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "json_schema":
					s.Type = PromptResponseFormatJSONSchemaPromptVersionDataResponseFormat
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PromptResponseFormatJSONSchemaPromptVersionDataResponseFormat:
		if err := s.PromptResponseFormatJSONSchema.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptVersionDataResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionDataResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionDataTemplate as json.
func (s PromptVersionDataTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PromptVersionDataTemplate) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PromptChatTemplatePromptVersionDataTemplate:
		e.FieldStart("type")
		e.Str("chat")
		{
			s := s.PromptChatTemplate
			{
				e.FieldStart("messages")
				e.ArrStart()
				for _, elem := range s.Messages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case PromptStringTemplatePromptVersionDataTemplate:
		e.FieldStart("type")
		e.Str("string")
		{
			s := s.PromptStringTemplate
			{
				e.FieldStart("template")
				e.Str(s.Template)
			}
		}
	}
}

// Decode decodes PromptVersionDataTemplate from json.
func (s *PromptVersionDataTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionDataTemplate to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "chat":
					s.Type = PromptChatTemplatePromptVersionDataTemplate
					found = true
				case "string":
					s.Type = PromptStringTemplatePromptVersionDataTemplate
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PromptChatTemplatePromptVersionDataTemplate:
		if err := s.PromptChatTemplate.Decode(d); err != nil {
			return err
		}
	case PromptStringTemplatePromptVersionDataTemplate:
		if err := s.PromptStringTemplate.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptVersionDataTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionDataTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionInvocationParameters as json.
func (s PromptVersionInvocationParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PromptVersionInvocationParameters) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PromptOpenAIInvocationParametersPromptVersionInvocationParameters:
		e.FieldStart("type")
		e.Str("openai")
		{
			s := s.PromptOpenAIInvocationParameters
			{
				e.FieldStart("openai")
				s.Openai.Encode(e)
			}
		}
	case PromptAzureOpenAIInvocationParametersPromptVersionInvocationParameters:
		e.FieldStart("type")
		e.Str("azure_openai")
		{
			s := s.PromptAzureOpenAIInvocationParameters
			{
				e.FieldStart("azure_openai")
				s.AzureOpenai.Encode(e)
			}
		}
	case PromptAnthropicInvocationParametersPromptVersionInvocationParameters:
		e.FieldStart("type")
		e.Str("anthropic")
		{
			s := s.PromptAnthropicInvocationParameters
			{
				e.FieldStart("anthropic")
				s.Anthropic.Encode(e)
			}
		}
	case PromptGoogleInvocationParametersPromptVersionInvocationParameters:
		e.FieldStart("type")
		e.Str("google")
		{
			s := s.PromptGoogleInvocationParameters
			{
				e.FieldStart("google")
				s.Google.Encode(e)
			}
		}
	case PromptDeepSeekInvocationParametersPromptVersionInvocationParameters:
		e.FieldStart("type")
		e.Str("deepseek")
		{
			s := s.PromptDeepSeekInvocationParameters
			{
				e.FieldStart("deepseek")
				s.Deepseek.Encode(e)
			}
		}
	case PromptXAIInvocationParametersPromptVersionInvocationParameters:
		e.FieldStart("type")
		e.Str("xai")
		{
			s := s.PromptXAIInvocationParameters
			{
				e.FieldStart("xai")
				s.Xai.Encode(e)
			}
		}
	case PromptOllamaInvocationParametersPromptVersionInvocationParameters:
		e.FieldStart("type")
		e.Str("ollama")
		{
			s := s.PromptOllamaInvocationParameters
			{
				e.FieldStart("ollama")
				s.Ollama.Encode(e)
			}
		}
	case PromptAwsInvocationParametersPromptVersionInvocationParameters:
		e.FieldStart("type")
		e.Str("aws")
		{
			s := s.PromptAwsInvocationParameters
			{
				e.FieldStart("aws")
				s.AWS.Encode(e)
			}
		}
	}
}

// Decode decodes PromptVersionInvocationParameters from json.
func (s *PromptVersionInvocationParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionInvocationParameters to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "openai":
					s.Type = PromptOpenAIInvocationParametersPromptVersionInvocationParameters
					found = true
				case "azure_openai":
					s.Type = PromptAzureOpenAIInvocationParametersPromptVersionInvocationParameters
					found = true
				case "anthropic":
					s.Type = PromptAnthropicInvocationParametersPromptVersionInvocationParameters
					found = true
				case "google":
					s.Type = PromptGoogleInvocationParametersPromptVersionInvocationParameters
					found = true
				case "deepseek":
					s.Type = PromptDeepSeekInvocationParametersPromptVersionInvocationParameters
					found = true
				case "xai":
					s.Type = PromptXAIInvocationParametersPromptVersionInvocationParameters
					found = true
				case "ollama":
					s.Type = PromptOllamaInvocationParametersPromptVersionInvocationParameters
					found = true
				case "aws":
					s.Type = PromptAwsInvocationParametersPromptVersionInvocationParameters
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PromptOpenAIInvocationParametersPromptVersionInvocationParameters:
		if err := s.PromptOpenAIInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptAzureOpenAIInvocationParametersPromptVersionInvocationParameters:
		if err := s.PromptAzureOpenAIInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptAnthropicInvocationParametersPromptVersionInvocationParameters:
		if err := s.PromptAnthropicInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptGoogleInvocationParametersPromptVersionInvocationParameters:
		if err := s.PromptGoogleInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptDeepSeekInvocationParametersPromptVersionInvocationParameters:
		if err := s.PromptDeepSeekInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptXAIInvocationParametersPromptVersionInvocationParameters:
		if err := s.PromptXAIInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptOllamaInvocationParametersPromptVersionInvocationParameters:
		if err := s.PromptOllamaInvocationParameters.Decode(d); err != nil {
			return err
		}
	case PromptAwsInvocationParametersPromptVersionInvocationParameters:
		if err := s.PromptAwsInvocationParameters.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptVersionInvocationParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionInvocationParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionResponseFormat as json.
func (s PromptVersionResponseFormat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PromptVersionResponseFormat) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PromptResponseFormatJSONSchemaPromptVersionResponseFormat:
		e.FieldStart("type")
		e.Str("json_schema")
		{
			s := s.PromptResponseFormatJSONSchema
			{
				e.FieldStart("json_schema")
				s.JSONSchema.Encode(e)
			}
		}
	}
}

// Decode decodes PromptVersionResponseFormat from json.
func (s *PromptVersionResponseFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionResponseFormat to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "json_schema":
					s.Type = PromptResponseFormatJSONSchemaPromptVersionResponseFormat
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PromptResponseFormatJSONSchemaPromptVersionResponseFormat:
		if err := s.PromptResponseFormatJSONSchema.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptVersionResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersionTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersionTag) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
}

var jsonFieldsNameOfPromptVersionTag = [3]string{
	0: "description",
	1: "id",
	2: "name",
}

// Decode decodes PromptVersionTag from json.
func (s *PromptVersionTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionTag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersionTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptVersionTag) {
					name = jsonFieldsNameOfPromptVersionTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersionTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersionTagData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersionTagData) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
}

var jsonFieldsNameOfPromptVersionTagData = [2]string{
	0: "description",
	1: "name",
}

// Decode decodes PromptVersionTagData from json.
func (s *PromptVersionTagData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionTagData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersionTagData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptVersionTagData) {
					name = jsonFieldsNameOfPromptVersionTagData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersionTagData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionTagData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionTemplate as json.
func (s PromptVersionTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PromptVersionTemplate) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PromptChatTemplatePromptVersionTemplate:
		e.FieldStart("type")
		e.Str("chat")
		{
			s := s.PromptChatTemplate
			{
				e.FieldStart("messages")
				e.ArrStart()
				for _, elem := range s.Messages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case PromptStringTemplatePromptVersionTemplate:
		e.FieldStart("type")
		e.Str("string")
		{
			s := s.PromptStringTemplate
			{
				e.FieldStart("template")
				e.Str(s.Template)
			}
		}
	}
}

// Decode decodes PromptVersionTemplate from json.
func (s *PromptVersionTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionTemplate to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "chat":
					s.Type = PromptChatTemplatePromptVersionTemplate
					found = true
				case "string":
					s.Type = PromptStringTemplatePromptVersionTemplate
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PromptChatTemplatePromptVersionTemplate:
		if err := s.PromptChatTemplate.Decode(d); err != nil {
			return err
		}
	case PromptStringTemplatePromptVersionTemplate:
		if err := s.PromptStringTemplate.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptVersionTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptXAIInvocationParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptXAIInvocationParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("xai")
		s.Xai.Encode(e)
	}
}

var jsonFieldsNameOfPromptXAIInvocationParameters = [2]string{
	0: "type",
	1: "xai",
}

// Decode decodes PromptXAIInvocationParameters from json.
func (s *PromptXAIInvocationParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptXAIInvocationParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "xai":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Xai.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xai\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptXAIInvocationParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptXAIInvocationParameters) {
					name = jsonFieldsNameOfPromptXAIInvocationParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptXAIInvocationParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptXAIInvocationParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptXAIInvocationParametersContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptXAIInvocationParametersContent) encodeFields(e *jx.Encoder) {
	{
		if s.FrequencyPenalty.Set {
			e.FieldStart("frequency_penalty")
			s.FrequencyPenalty.Encode(e)
		}
	}
	{
		if s.MaxCompletionTokens.Set {
			e.FieldStart("max_completion_tokens")
			s.MaxCompletionTokens.Encode(e)
		}
	}
	{
		if s.MaxTokens.Set {
			e.FieldStart("max_tokens")
			s.MaxTokens.Encode(e)
		}
	}
	{
		if s.PresencePenalty.Set {
			e.FieldStart("presence_penalty")
			s.PresencePenalty.Encode(e)
		}
	}
	{
		if s.ReasoningEffort.Set {
			e.FieldStart("reasoning_effort")
			s.ReasoningEffort.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptXAIInvocationParametersContent = [8]string{
	0: "frequency_penalty",
	1: "max_completion_tokens",
	2: "max_tokens",
	3: "presence_penalty",
	4: "reasoning_effort",
	5: "seed",
	6: "temperature",
	7: "top_p",
}

// Decode decodes PromptXAIInvocationParametersContent from json.
func (s *PromptXAIInvocationParametersContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptXAIInvocationParametersContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "frequency_penalty":
			if err := func() error {
				s.FrequencyPenalty.Reset()
				if err := s.FrequencyPenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency_penalty\"")
			}
		case "max_completion_tokens":
			if err := func() error {
				s.MaxCompletionTokens.Reset()
				if err := s.MaxCompletionTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_completion_tokens\"")
			}
		case "max_tokens":
			if err := func() error {
				s.MaxTokens.Reset()
				if err := s.MaxTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tokens\"")
			}
		case "presence_penalty":
			if err := func() error {
				s.PresencePenalty.Reset()
				if err := s.PresencePenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"presence_penalty\"")
			}
		case "reasoning_effort":
			if err := func() error {
				s.ReasoningEffort.Reset()
				if err := s.ReasoningEffort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reasoning_effort\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptXAIInvocationParametersContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptXAIInvocationParametersContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptXAIInvocationParametersContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptXAIInvocationParametersContentReasoningEffort as json.
func (s PromptXAIInvocationParametersContentReasoningEffort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptXAIInvocationParametersContentReasoningEffort from json.
func (s *PromptXAIInvocationParametersContentReasoningEffort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptXAIInvocationParametersContentReasoningEffort to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptXAIInvocationParametersContentReasoningEffort(v) {
	case PromptXAIInvocationParametersContentReasoningEffortNone:
		*s = PromptXAIInvocationParametersContentReasoningEffortNone
	case PromptXAIInvocationParametersContentReasoningEffortMinimal:
		*s = PromptXAIInvocationParametersContentReasoningEffortMinimal
	case PromptXAIInvocationParametersContentReasoningEffortLow:
		*s = PromptXAIInvocationParametersContentReasoningEffortLow
	case PromptXAIInvocationParametersContentReasoningEffortMedium:
		*s = PromptXAIInvocationParametersContentReasoningEffortMedium
	case PromptXAIInvocationParametersContentReasoningEffortHigh:
		*s = PromptXAIInvocationParametersContentReasoningEffortHigh
	case PromptXAIInvocationParametersContentReasoningEffortXhigh:
		*s = PromptXAIInvocationParametersContentReasoningEffortXhigh
	default:
		*s = PromptXAIInvocationParametersContentReasoningEffort(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptXAIInvocationParametersContentReasoningEffort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptXAIInvocationParametersContentReasoningEffort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptXAIInvocationParametersType as json.
func (s PromptXAIInvocationParametersType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptXAIInvocationParametersType from json.
func (s *PromptXAIInvocationParametersType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptXAIInvocationParametersType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptXAIInvocationParametersType(v) {
	case PromptXAIInvocationParametersTypeXai:
		*s = PromptXAIInvocationParametersTypeXai
	default:
		*s = PromptXAIInvocationParametersType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptXAIInvocationParametersType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptXAIInvocationParametersType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionAnnotation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionAnnotation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("annotator_kind")
		s.AnnotatorKind.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Identifier.Set {
			e.FieldStart("identifier")
			s.Identifier.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("session_id")
		e.Str(s.SessionID)
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("user_id")
		s.UserID.Encode(e)
	}
}

var jsonFieldsNameOfSessionAnnotation = [11]string{
	0:  "annotator_kind",
	1:  "created_at",
	2:  "id",
	3:  "identifier",
	4:  "metadata",
	5:  "name",
	6:  "result",
	7:  "session_id",
	8:  "source",
	9:  "updated_at",
	10: "user_id",
}

// Decode decodes SessionAnnotation from json.
func (s *SessionAnnotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionAnnotation to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotator_kind":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AnnotatorKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotator_kind\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "identifier":
			if err := func() error {
				s.Identifier.Reset()
				if err := s.Identifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "session_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.SessionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "source":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "user_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionAnnotation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10100111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionAnnotation) {
					name = jsonFieldsNameOfSessionAnnotation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionAnnotation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionAnnotation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionAnnotationAnnotatorKind as json.
func (s SessionAnnotationAnnotatorKind) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionAnnotationAnnotatorKind from json.
func (s *SessionAnnotationAnnotatorKind) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionAnnotationAnnotatorKind to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionAnnotationAnnotatorKind(v) {
	case SessionAnnotationAnnotatorKindLLM:
		*s = SessionAnnotationAnnotatorKindLLM
	case SessionAnnotationAnnotatorKindCODE:
		*s = SessionAnnotationAnnotatorKindCODE
	case SessionAnnotationAnnotatorKindHUMAN:
		*s = SessionAnnotationAnnotatorKindHUMAN
	default:
		*s = SessionAnnotationAnnotatorKind(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionAnnotationAnnotatorKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionAnnotationAnnotatorKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionAnnotationData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionAnnotationData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("annotator_kind")
		s.AnnotatorKind.Encode(e)
	}
	{
		if s.Identifier.Set {
			e.FieldStart("identifier")
			s.Identifier.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("session_id")
		e.Str(s.SessionID)
	}
}

var jsonFieldsNameOfSessionAnnotationData = [6]string{
	0: "annotator_kind",
	1: "identifier",
	2: "metadata",
	3: "name",
	4: "result",
	5: "session_id",
}

// Decode decodes SessionAnnotationData from json.
func (s *SessionAnnotationData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionAnnotationData to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotator_kind":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AnnotatorKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotator_kind\"")
			}
		case "identifier":
			if err := func() error {
				s.Identifier.Reset()
				if err := s.Identifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "session_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.SessionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionAnnotationData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionAnnotationData) {
					name = jsonFieldsNameOfSessionAnnotationData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionAnnotationData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionAnnotationData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionAnnotationDataAnnotatorKind as json.
func (s SessionAnnotationDataAnnotatorKind) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionAnnotationDataAnnotatorKind from json.
func (s *SessionAnnotationDataAnnotatorKind) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionAnnotationDataAnnotatorKind to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionAnnotationDataAnnotatorKind(v) {
	case SessionAnnotationDataAnnotatorKindLLM:
		*s = SessionAnnotationDataAnnotatorKindLLM
	case SessionAnnotationDataAnnotatorKindCODE:
		*s = SessionAnnotationDataAnnotatorKindCODE
	case SessionAnnotationDataAnnotatorKindHUMAN:
		*s = SessionAnnotationDataAnnotatorKindHUMAN
	default:
		*s = SessionAnnotationDataAnnotatorKind(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionAnnotationDataAnnotatorKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionAnnotationDataAnnotatorKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SessionAnnotationDataMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SessionAnnotationDataMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SessionAnnotationDataMetadata from json.
func (s *SessionAnnotationDataMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionAnnotationDataMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionAnnotationDataMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionAnnotationDataMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionAnnotationDataMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SessionAnnotationMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SessionAnnotationMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SessionAnnotationMetadata from json.
func (s *SessionAnnotationMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionAnnotationMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionAnnotationMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionAnnotationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionAnnotationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionAnnotationSource as json.
func (s SessionAnnotationSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionAnnotationSource from json.
func (s *SessionAnnotationSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionAnnotationSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionAnnotationSource(v) {
	case SessionAnnotationSourceAPI:
		*s = SessionAnnotationSourceAPI
	case SessionAnnotationSourceAPP:
		*s = SessionAnnotationSourceAPP
	default:
		*s = SessionAnnotationSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionAnnotationSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionAnnotationSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionAnnotationsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionAnnotationsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfSessionAnnotationsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes SessionAnnotationsResponseBody from json.
func (s *SessionAnnotationsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionAnnotationsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]SessionAnnotation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SessionAnnotation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionAnnotationsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionAnnotationsResponseBody) {
					name = jsonFieldsNameOfSessionAnnotationsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionAnnotationsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionAnnotationsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Span) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Span) encodeFields(e *jx.Encoder) {
	{
		if s.Attributes.Set {
			e.FieldStart("attributes")
			s.Attributes.Encode(e)
		}
	}
	{
		e.FieldStart("context")
		s.Context.Encode(e)
	}
	{
		e.FieldStart("end_time")
		json.EncodeDateTime(e, s.EndTime)
	}
	{
		if s.Events != nil {
			e.FieldStart("events")
			e.ArrStart()
			for _, elem := range s.Events {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.ParentID.Set {
			e.FieldStart("parent_id")
			s.ParentID.Encode(e)
		}
	}
	{
		e.FieldStart("span_kind")
		e.Str(s.SpanKind)
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		e.FieldStart("status_code")
		e.Str(s.StatusCode)
	}
	{
		if s.StatusMessage.Set {
			e.FieldStart("status_message")
			s.StatusMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpan = [11]string{
	0:  "attributes",
	1:  "context",
	2:  "end_time",
	3:  "events",
	4:  "id",
	5:  "name",
	6:  "parent_id",
	7:  "span_kind",
	8:  "start_time",
	9:  "status_code",
	10: "status_message",
}

// Decode decodes Span from json.
func (s *Span) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Span to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attributes":
			if err := func() error {
				s.Attributes.Reset()
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "context":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "end_time":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.EndTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "events":
			if err := func() error {
				s.Events = make([]SpanEvent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpanEvent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "parent_id":
			if err := func() error {
				s.ParentID.Reset()
				if err := s.ParentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_id\"")
			}
		case "span_kind":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.SpanKind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_kind\"")
			}
		case "start_time":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "status_code":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.StatusCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_code\"")
			}
		case "status_message":
			if err := func() error {
				s.StatusMessage.Reset()
				if err := s.StatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Span")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10100110,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpan) {
					name = jsonFieldsNameOfSpan[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Span) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Span) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanAnnotation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanAnnotation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("annotator_kind")
		s.AnnotatorKind.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Identifier.Set {
			e.FieldStart("identifier")
			s.Identifier.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		e.FieldStart("span_id")
		e.Str(s.SpanID)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("user_id")
		s.UserID.Encode(e)
	}
}

var jsonFieldsNameOfSpanAnnotation = [11]string{
	0:  "annotator_kind",
	1:  "created_at",
	2:  "id",
	3:  "identifier",
	4:  "metadata",
	5:  "name",
	6:  "result",
	7:  "source",
	8:  "span_id",
	9:  "updated_at",
	10: "user_id",
}

// Decode decodes SpanAnnotation from json.
func (s *SpanAnnotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanAnnotation to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotator_kind":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AnnotatorKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotator_kind\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "identifier":
			if err := func() error {
				s.Identifier.Reset()
				if err := s.Identifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "span_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SpanID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "user_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanAnnotation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10100111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanAnnotation) {
					name = jsonFieldsNameOfSpanAnnotation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanAnnotation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanAnnotation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanAnnotationAnnotatorKind as json.
func (s SpanAnnotationAnnotatorKind) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpanAnnotationAnnotatorKind from json.
func (s *SpanAnnotationAnnotatorKind) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanAnnotationAnnotatorKind to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpanAnnotationAnnotatorKind(v) {
	case SpanAnnotationAnnotatorKindLLM:
		*s = SpanAnnotationAnnotatorKindLLM
	case SpanAnnotationAnnotatorKindCODE:
		*s = SpanAnnotationAnnotatorKindCODE
	case SpanAnnotationAnnotatorKindHUMAN:
		*s = SpanAnnotationAnnotatorKindHUMAN
	default:
		*s = SpanAnnotationAnnotatorKind(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanAnnotationAnnotatorKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanAnnotationAnnotatorKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanAnnotationData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanAnnotationData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("annotator_kind")
		s.AnnotatorKind.Encode(e)
	}
	{
		if s.Identifier.Set {
			e.FieldStart("identifier")
			s.Identifier.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("span_id")
		e.Str(s.SpanID)
	}
}

var jsonFieldsNameOfSpanAnnotationData = [6]string{
	0: "annotator_kind",
	1: "identifier",
	2: "metadata",
	3: "name",
	4: "result",
	5: "span_id",
}

// Decode decodes SpanAnnotationData from json.
func (s *SpanAnnotationData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanAnnotationData to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotator_kind":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AnnotatorKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotator_kind\"")
			}
		case "identifier":
			if err := func() error {
				s.Identifier.Reset()
				if err := s.Identifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "span_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.SpanID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanAnnotationData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanAnnotationData) {
					name = jsonFieldsNameOfSpanAnnotationData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanAnnotationData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanAnnotationData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanAnnotationDataAnnotatorKind as json.
func (s SpanAnnotationDataAnnotatorKind) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpanAnnotationDataAnnotatorKind from json.
func (s *SpanAnnotationDataAnnotatorKind) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanAnnotationDataAnnotatorKind to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpanAnnotationDataAnnotatorKind(v) {
	case SpanAnnotationDataAnnotatorKindLLM:
		*s = SpanAnnotationDataAnnotatorKindLLM
	case SpanAnnotationDataAnnotatorKindCODE:
		*s = SpanAnnotationDataAnnotatorKindCODE
	case SpanAnnotationDataAnnotatorKindHUMAN:
		*s = SpanAnnotationDataAnnotatorKindHUMAN
	default:
		*s = SpanAnnotationDataAnnotatorKind(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanAnnotationDataAnnotatorKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanAnnotationDataAnnotatorKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpanAnnotationDataMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpanAnnotationDataMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpanAnnotationDataMetadata from json.
func (s *SpanAnnotationDataMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanAnnotationDataMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanAnnotationDataMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanAnnotationDataMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanAnnotationDataMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpanAnnotationMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpanAnnotationMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpanAnnotationMetadata from json.
func (s *SpanAnnotationMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanAnnotationMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanAnnotationMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanAnnotationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanAnnotationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanAnnotationSource as json.
func (s SpanAnnotationSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpanAnnotationSource from json.
func (s *SpanAnnotationSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanAnnotationSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpanAnnotationSource(v) {
	case SpanAnnotationSourceAPI:
		*s = SpanAnnotationSourceAPI
	case SpanAnnotationSourceAPP:
		*s = SpanAnnotationSourceAPP
	default:
		*s = SpanAnnotationSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanAnnotationSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanAnnotationSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanAnnotationsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanAnnotationsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfSpanAnnotationsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes SpanAnnotationsResponseBody from json.
func (s *SpanAnnotationsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanAnnotationsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]SpanAnnotation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpanAnnotation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanAnnotationsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanAnnotationsResponseBody) {
					name = jsonFieldsNameOfSpanAnnotationsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanAnnotationsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanAnnotationsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpanAttributes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpanAttributes) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpanAttributes from json.
func (s *SpanAttributes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanAttributes to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanAttributes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanContext) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("span_id")
		e.Str(s.SpanID)
	}
	{
		e.FieldStart("trace_id")
		e.Str(s.TraceID)
	}
}

var jsonFieldsNameOfSpanContext = [2]string{
	0: "span_id",
	1: "trace_id",
}

// Decode decodes SpanContext from json.
func (s *SpanContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanContext to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "span_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SpanID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		case "trace_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TraceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanContext")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanContext) {
					name = jsonFieldsNameOfSpanContext[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanDocumentAnnotationData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanDocumentAnnotationData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("annotator_kind")
		s.AnnotatorKind.Encode(e)
	}
	{
		e.FieldStart("document_position")
		e.Int(s.DocumentPosition)
	}
	{
		if s.Identifier.Set {
			e.FieldStart("identifier")
			s.Identifier.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("span_id")
		e.Str(s.SpanID)
	}
}

var jsonFieldsNameOfSpanDocumentAnnotationData = [7]string{
	0: "annotator_kind",
	1: "document_position",
	2: "identifier",
	3: "metadata",
	4: "name",
	5: "result",
	6: "span_id",
}

// Decode decodes SpanDocumentAnnotationData from json.
func (s *SpanDocumentAnnotationData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanDocumentAnnotationData to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotator_kind":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AnnotatorKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotator_kind\"")
			}
		case "document_position":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DocumentPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document_position\"")
			}
		case "identifier":
			if err := func() error {
				s.Identifier.Reset()
				if err := s.Identifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "span_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.SpanID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanDocumentAnnotationData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanDocumentAnnotationData) {
					name = jsonFieldsNameOfSpanDocumentAnnotationData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanDocumentAnnotationData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanDocumentAnnotationData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanDocumentAnnotationDataAnnotatorKind as json.
func (s SpanDocumentAnnotationDataAnnotatorKind) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpanDocumentAnnotationDataAnnotatorKind from json.
func (s *SpanDocumentAnnotationDataAnnotatorKind) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanDocumentAnnotationDataAnnotatorKind to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpanDocumentAnnotationDataAnnotatorKind(v) {
	case SpanDocumentAnnotationDataAnnotatorKindLLM:
		*s = SpanDocumentAnnotationDataAnnotatorKindLLM
	case SpanDocumentAnnotationDataAnnotatorKindCODE:
		*s = SpanDocumentAnnotationDataAnnotatorKindCODE
	case SpanDocumentAnnotationDataAnnotatorKindHUMAN:
		*s = SpanDocumentAnnotationDataAnnotatorKindHUMAN
	default:
		*s = SpanDocumentAnnotationDataAnnotatorKind(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanDocumentAnnotationDataAnnotatorKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanDocumentAnnotationDataAnnotatorKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpanDocumentAnnotationDataMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpanDocumentAnnotationDataMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpanDocumentAnnotationDataMetadata from json.
func (s *SpanDocumentAnnotationDataMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanDocumentAnnotationDataMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanDocumentAnnotationDataMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanDocumentAnnotationDataMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanDocumentAnnotationDataMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanEvent) encodeFields(e *jx.Encoder) {
	{
		if s.Attributes.Set {
			e.FieldStart("attributes")
			s.Attributes.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
}

var jsonFieldsNameOfSpanEvent = [3]string{
	0: "attributes",
	1: "name",
	2: "timestamp",
}

// Decode decodes SpanEvent from json.
func (s *SpanEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanEvent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attributes":
			if err := func() error {
				s.Attributes.Reset()
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanEvent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanEvent) {
					name = jsonFieldsNameOfSpanEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpanEventAttributes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpanEventAttributes) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpanEventAttributes from json.
func (s *SpanEventAttributes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanEventAttributes to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanEventAttributes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanEventAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanEventAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanNoteData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanNoteData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("note")
		e.Str(s.Note)
	}
	{
		e.FieldStart("span_id")
		e.Str(s.SpanID)
	}
}

var jsonFieldsNameOfSpanNoteData = [2]string{
	0: "note",
	1: "span_id",
}

// Decode decodes SpanNoteData from json.
func (s *SpanNoteData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanNoteData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "note":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Note = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "span_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SpanID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanNoteData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanNoteData) {
					name = jsonFieldsNameOfSpanNoteData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanNoteData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanNoteData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpansResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpansResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfSpansResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes SpansResponseBody from json.
func (s *SpansResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpansResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]Span, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Span
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpansResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpansResponseBody) {
					name = jsonFieldsNameOfSpansResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpansResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpansResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TextContentPart) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TextContentPart) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfTextContentPart = [2]string{
	0: "text",
	1: "type",
}

// Decode decodes TextContentPart from json.
func (s *TextContentPart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TextContentPart to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TextContentPart")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTextContentPart) {
					name = jsonFieldsNameOfTextContentPart[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TextContentPart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TextContentPart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TextContentPartType as json.
func (s TextContentPartType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TextContentPartType from json.
func (s *TextContentPartType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TextContentPartType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TextContentPartType(v) {
	case TextContentPartTypeText:
		*s = TextContentPartTypeText
	default:
		*s = TextContentPartType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TextContentPartType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TextContentPartType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ToolCallContentPart) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ToolCallContentPart) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tool_call")
		s.ToolCall.Encode(e)
	}
	{
		e.FieldStart("tool_call_id")
		e.Str(s.ToolCallID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfToolCallContentPart = [3]string{
	0: "tool_call",
	1: "tool_call_id",
	2: "type",
}

// Decode decodes ToolCallContentPart from json.
func (s *ToolCallContentPart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolCallContentPart to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tool_call":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ToolCall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call\"")
			}
		case "tool_call_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ToolCallID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ToolCallContentPart")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfToolCallContentPart) {
					name = jsonFieldsNameOfToolCallContentPart[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ToolCallContentPart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolCallContentPart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolCallContentPartToolCall as json.
func (s ToolCallContentPartToolCall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ToolCallContentPartToolCall) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ToolCallFunctionToolCallContentPartToolCall:
		e.FieldStart("type")
		e.Str("function")
		{
			s := s.ToolCallFunction
			{
				e.FieldStart("arguments")
				e.Str(s.Arguments)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	}
}

// Decode decodes ToolCallContentPartToolCall from json.
func (s *ToolCallContentPartToolCall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolCallContentPartToolCall to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "function":
					s.Type = ToolCallFunctionToolCallContentPartToolCall
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ToolCallFunctionToolCallContentPartToolCall:
		if err := s.ToolCallFunction.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolCallContentPartToolCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolCallContentPartToolCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolCallContentPartType as json.
func (s ToolCallContentPartType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ToolCallContentPartType from json.
func (s *ToolCallContentPartType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolCallContentPartType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ToolCallContentPartType(v) {
	case ToolCallContentPartTypeToolCall:
		*s = ToolCallContentPartTypeToolCall
	default:
		*s = ToolCallContentPartType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolCallContentPartType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolCallContentPartType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ToolCallFunction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ToolCallFunction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("arguments")
		e.Str(s.Arguments)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfToolCallFunction = [3]string{
	0: "arguments",
	1: "name",
	2: "type",
}

// Decode decodes ToolCallFunction from json.
func (s *ToolCallFunction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolCallFunction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "arguments":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Arguments = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ToolCallFunction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfToolCallFunction) {
					name = jsonFieldsNameOfToolCallFunction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ToolCallFunction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolCallFunction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolCallFunctionType as json.
func (s ToolCallFunctionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ToolCallFunctionType from json.
func (s *ToolCallFunctionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolCallFunctionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ToolCallFunctionType(v) {
	case ToolCallFunctionTypeFunction:
		*s = ToolCallFunctionTypeFunction
	default:
		*s = ToolCallFunctionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolCallFunctionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolCallFunctionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ToolResultContentPart) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ToolResultContentPart) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tool_call_id")
		e.Str(s.ToolCallID)
	}
	{
		e.FieldStart("tool_result")
		s.ToolResult.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfToolResultContentPart = [3]string{
	0: "tool_call_id",
	1: "tool_result",
	2: "type",
}

// Decode decodes ToolResultContentPart from json.
func (s *ToolResultContentPart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolResultContentPart to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tool_call_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ToolCallID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call_id\"")
			}
		case "tool_result":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ToolResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_result\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ToolResultContentPart")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfToolResultContentPart) {
					name = jsonFieldsNameOfToolResultContentPart[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ToolResultContentPart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolResultContentPart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolResultContentPartToolResult as json.
func (s ToolResultContentPartToolResult) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolToolResultContentPartToolResult:
		e.Bool(s.Bool)
	case IntToolResultContentPartToolResult:
		e.Int(s.Int)
	case Float64ToolResultContentPartToolResult:
		e.Float64(s.Float64)
	case StringToolResultContentPartToolResult:
		e.Str(s.String)
	case ToolResultContentPartToolResult4ToolResultContentPartToolResult:
		s.ToolResultContentPartToolResult4.Encode(e)
	case AnyArrayToolResultContentPartToolResult:
		e.ArrStart()
		for _, elem := range s.AnyArray {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ToolResultContentPartToolResult from json.
func (s *ToolResultContentPartToolResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolResultContentPartToolResult to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.AnyArray = make([]jx.Raw, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem jx.Raw
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			s.AnyArray = append(s.AnyArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = AnyArrayToolResultContentPartToolResult
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolToolResultContentPartToolResult
	case jx.Number:
		num, err := d.Num()
		if err != nil {
			return errors.Wrap(err, "parse number")
		}
		if d := jx.DecodeBytes(num); num.IsInt() {
			v, err := d.Int()
			s.Int = int(v)
			if err != nil {
				return err
			}
			s.Type = IntToolResultContentPartToolResult
		} else {
			v, err := d.Float64()
			s.Float64 = float64(v)
			if err != nil {
				return err
			}
			s.Type = Float64ToolResultContentPartToolResult
		}
	case jx.Object:
		if err := s.ToolResultContentPartToolResult4.Decode(d); err != nil {
			return err
		}
		s.Type = ToolResultContentPartToolResult4ToolResultContentPartToolResult
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringToolResultContentPartToolResult
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolResultContentPartToolResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolResultContentPartToolResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ToolResultContentPartToolResult4) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ToolResultContentPartToolResult4) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ToolResultContentPartToolResult4 from json.
func (s *ToolResultContentPartToolResult4) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolResultContentPartToolResult4 to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ToolResultContentPartToolResult4")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolResultContentPartToolResult4) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolResultContentPartToolResult4) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolResultContentPartType as json.
func (s ToolResultContentPartType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ToolResultContentPartType from json.
func (s *ToolResultContentPartType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolResultContentPartType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ToolResultContentPartType(v) {
	case ToolResultContentPartTypeToolResult:
		*s = ToolResultContentPartTypeToolResult
	default:
		*s = ToolResultContentPartType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolResultContentPartType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolResultContentPartType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceAnnotation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceAnnotation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("annotator_kind")
		s.AnnotatorKind.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Identifier.Set {
			e.FieldStart("identifier")
			s.Identifier.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		e.FieldStart("trace_id")
		e.Str(s.TraceID)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("user_id")
		s.UserID.Encode(e)
	}
}

var jsonFieldsNameOfTraceAnnotation = [11]string{
	0:  "annotator_kind",
	1:  "created_at",
	2:  "id",
	3:  "identifier",
	4:  "metadata",
	5:  "name",
	6:  "result",
	7:  "source",
	8:  "trace_id",
	9:  "updated_at",
	10: "user_id",
}

// Decode decodes TraceAnnotation from json.
func (s *TraceAnnotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceAnnotation to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotator_kind":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AnnotatorKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotator_kind\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "identifier":
			if err := func() error {
				s.Identifier.Reset()
				if err := s.Identifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "trace_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TraceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "user_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceAnnotation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10100111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTraceAnnotation) {
					name = jsonFieldsNameOfTraceAnnotation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceAnnotation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceAnnotation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceAnnotationAnnotatorKind as json.
func (s TraceAnnotationAnnotatorKind) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TraceAnnotationAnnotatorKind from json.
func (s *TraceAnnotationAnnotatorKind) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceAnnotationAnnotatorKind to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TraceAnnotationAnnotatorKind(v) {
	case TraceAnnotationAnnotatorKindLLM:
		*s = TraceAnnotationAnnotatorKindLLM
	case TraceAnnotationAnnotatorKindCODE:
		*s = TraceAnnotationAnnotatorKindCODE
	case TraceAnnotationAnnotatorKindHUMAN:
		*s = TraceAnnotationAnnotatorKindHUMAN
	default:
		*s = TraceAnnotationAnnotatorKind(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TraceAnnotationAnnotatorKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceAnnotationAnnotatorKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceAnnotationData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceAnnotationData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("annotator_kind")
		s.AnnotatorKind.Encode(e)
	}
	{
		if s.Identifier.Set {
			e.FieldStart("identifier")
			s.Identifier.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("trace_id")
		e.Str(s.TraceID)
	}
}

var jsonFieldsNameOfTraceAnnotationData = [6]string{
	0: "annotator_kind",
	1: "identifier",
	2: "metadata",
	3: "name",
	4: "result",
	5: "trace_id",
}

// Decode decodes TraceAnnotationData from json.
func (s *TraceAnnotationData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceAnnotationData to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotator_kind":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AnnotatorKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotator_kind\"")
			}
		case "identifier":
			if err := func() error {
				s.Identifier.Reset()
				if err := s.Identifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "trace_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.TraceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceAnnotationData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTraceAnnotationData) {
					name = jsonFieldsNameOfTraceAnnotationData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceAnnotationData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceAnnotationData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceAnnotationDataAnnotatorKind as json.
func (s TraceAnnotationDataAnnotatorKind) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TraceAnnotationDataAnnotatorKind from json.
func (s *TraceAnnotationDataAnnotatorKind) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceAnnotationDataAnnotatorKind to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TraceAnnotationDataAnnotatorKind(v) {
	case TraceAnnotationDataAnnotatorKindLLM:
		*s = TraceAnnotationDataAnnotatorKindLLM
	case TraceAnnotationDataAnnotatorKindCODE:
		*s = TraceAnnotationDataAnnotatorKindCODE
	case TraceAnnotationDataAnnotatorKindHUMAN:
		*s = TraceAnnotationDataAnnotatorKindHUMAN
	default:
		*s = TraceAnnotationDataAnnotatorKind(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TraceAnnotationDataAnnotatorKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceAnnotationDataAnnotatorKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s TraceAnnotationDataMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s TraceAnnotationDataMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes TraceAnnotationDataMetadata from json.
func (s *TraceAnnotationDataMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceAnnotationDataMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceAnnotationDataMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TraceAnnotationDataMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceAnnotationDataMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s TraceAnnotationMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s TraceAnnotationMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes TraceAnnotationMetadata from json.
func (s *TraceAnnotationMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceAnnotationMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceAnnotationMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TraceAnnotationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceAnnotationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceAnnotationSource as json.
func (s TraceAnnotationSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TraceAnnotationSource from json.
func (s *TraceAnnotationSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceAnnotationSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TraceAnnotationSource(v) {
	case TraceAnnotationSourceAPI:
		*s = TraceAnnotationSourceAPI
	case TraceAnnotationSourceAPP:
		*s = TraceAnnotationSourceAPP
	default:
		*s = TraceAnnotationSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TraceAnnotationSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceAnnotationSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceAnnotationsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceAnnotationsResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfTraceAnnotationsResponseBody = [2]string{
	0: "data",
	1: "next_cursor",
}

// Decode decodes TraceAnnotationsResponseBody from json.
func (s *TraceAnnotationsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceAnnotationsResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]TraceAnnotation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TraceAnnotation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceAnnotationsResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTraceAnnotationsResponseBody) {
					name = jsonFieldsNameOfTraceAnnotationsResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceAnnotationsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceAnnotationsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateAnnotationConfigResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateAnnotationConfigResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfUpdateAnnotationConfigResponseBody = [1]string{
	0: "data",
}

// Decode decodes UpdateAnnotationConfigResponseBody from json.
func (s *UpdateAnnotationConfigResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAnnotationConfigResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateAnnotationConfigResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateAnnotationConfigResponseBody) {
					name = jsonFieldsNameOfUpdateAnnotationConfigResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAnnotationConfigResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAnnotationConfigResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAnnotationConfigResponseBodyData as json.
func (s UpdateAnnotationConfigResponseBodyData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s UpdateAnnotationConfigResponseBodyData) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CategoricalAnnotationConfigUpdateAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("CATEGORICAL")
		{
			s := s.CategoricalAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				e.FieldStart("values")
				e.ArrStart()
				for _, elem := range s.Values {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case ContinuousAnnotationConfigUpdateAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("CONTINUOUS")
		{
			s := s.ContinuousAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				if s.LowerBound.Set {
					e.FieldStart("lower_bound")
					s.LowerBound.Encode(e)
				}
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("optimization_direction")
				s.OptimizationDirection.Encode(e)
			}
			{
				if s.UpperBound.Set {
					e.FieldStart("upper_bound")
					s.UpperBound.Encode(e)
				}
			}
		}
	case FreeformAnnotationConfigUpdateAnnotationConfigResponseBodyData:
		e.FieldStart("type")
		e.Str("FREEFORM")
		{
			s := s.FreeformAnnotationConfig
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	}
}

// Decode decodes UpdateAnnotationConfigResponseBodyData from json.
func (s *UpdateAnnotationConfigResponseBodyData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAnnotationConfigResponseBodyData to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "CATEGORICAL":
					s.Type = CategoricalAnnotationConfigUpdateAnnotationConfigResponseBodyData
					found = true
				case "CONTINUOUS":
					s.Type = ContinuousAnnotationConfigUpdateAnnotationConfigResponseBodyData
					found = true
				case "FREEFORM":
					s.Type = FreeformAnnotationConfigUpdateAnnotationConfigResponseBodyData
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CategoricalAnnotationConfigUpdateAnnotationConfigResponseBodyData:
		if err := s.CategoricalAnnotationConfig.Decode(d); err != nil {
			return err
		}
	case ContinuousAnnotationConfigUpdateAnnotationConfigResponseBodyData:
		if err := s.ContinuousAnnotationConfig.Decode(d); err != nil {
			return err
		}
	case FreeformAnnotationConfigUpdateAnnotationConfigResponseBodyData:
		if err := s.FreeformAnnotationConfig.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateAnnotationConfigResponseBodyData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAnnotationConfigResponseBodyData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateProjectRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateProjectRequestBody) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateProjectRequestBody = [1]string{
	0: "description",
}

// Decode decodes UpdateProjectRequestBody from json.
func (s *UpdateProjectRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateProjectRequestBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateProjectRequestBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateProjectRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateProjectRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateProjectResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateProjectResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfUpdateProjectResponseBody = [1]string{
	0: "data",
}

// Decode decodes UpdateProjectResponseBody from json.
func (s *UpdateProjectResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateProjectResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateProjectResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateProjectResponseBody) {
					name = jsonFieldsNameOfUpdateProjectResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateProjectResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateProjectResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UploadDatasetData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UploadDatasetData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataset_id")
		e.Str(s.DatasetID)
	}
	{
		e.FieldStart("version_id")
		e.Str(s.VersionID)
	}
}

var jsonFieldsNameOfUploadDatasetData = [2]string{
	0: "dataset_id",
	1: "version_id",
}

// Decode decodes UploadDatasetData from json.
func (s *UploadDatasetData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadDatasetData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatasetID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_id\"")
			}
		case "version_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VersionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UploadDatasetData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUploadDatasetData) {
					name = jsonFieldsNameOfUploadDatasetData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadDatasetData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadDatasetData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UploadDatasetReqApplicationJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UploadDatasetReqApplicationJSON) encodeFields(e *jx.Encoder) {
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("inputs")
		e.ArrStart()
		for _, elem := range s.Inputs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			e.ArrStart()
			for _, elem := range s.Metadata {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Outputs != nil {
			e.FieldStart("outputs")
			e.ArrStart()
			for _, elem := range s.Outputs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Splits != nil {
			e.FieldStart("splits")
			e.ArrStart()
			for _, elem := range s.Splits {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUploadDatasetReqApplicationJSON = [7]string{
	0: "action",
	1: "description",
	2: "inputs",
	3: "metadata",
	4: "name",
	5: "outputs",
	6: "splits",
}

// Decode decodes UploadDatasetReqApplicationJSON from json.
func (s *UploadDatasetReqApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadDatasetReqApplicationJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "inputs":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Inputs = make([]UploadDatasetReqApplicationJSONInputsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UploadDatasetReqApplicationJSONInputsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inputs = append(s.Inputs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inputs\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = make([]UploadDatasetReqApplicationJSONMetadataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UploadDatasetReqApplicationJSONMetadataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Metadata = append(s.Metadata, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "outputs":
			if err := func() error {
				s.Outputs = make([]UploadDatasetReqApplicationJSONOutputsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UploadDatasetReqApplicationJSONOutputsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Outputs = append(s.Outputs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outputs\"")
			}
		case "splits":
			if err := func() error {
				s.Splits = make([]NilUploadDatasetReqApplicationJSONSplitsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilUploadDatasetReqApplicationJSONSplitsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Splits = append(s.Splits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"splits\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UploadDatasetReqApplicationJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUploadDatasetReqApplicationJSON) {
					name = jsonFieldsNameOfUploadDatasetReqApplicationJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadDatasetReqApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadDatasetReqApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadDatasetReqApplicationJSONAction as json.
func (s UploadDatasetReqApplicationJSONAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UploadDatasetReqApplicationJSONAction from json.
func (s *UploadDatasetReqApplicationJSONAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadDatasetReqApplicationJSONAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UploadDatasetReqApplicationJSONAction(v) {
	case UploadDatasetReqApplicationJSONActionCreate:
		*s = UploadDatasetReqApplicationJSONActionCreate
	case UploadDatasetReqApplicationJSONActionAppend:
		*s = UploadDatasetReqApplicationJSONActionAppend
	default:
		*s = UploadDatasetReqApplicationJSONAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UploadDatasetReqApplicationJSONAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadDatasetReqApplicationJSONAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UploadDatasetReqApplicationJSONInputsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UploadDatasetReqApplicationJSONInputsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUploadDatasetReqApplicationJSONInputsItem = [0]string{}

// Decode decodes UploadDatasetReqApplicationJSONInputsItem from json.
func (s *UploadDatasetReqApplicationJSONInputsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadDatasetReqApplicationJSONInputsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UploadDatasetReqApplicationJSONInputsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadDatasetReqApplicationJSONInputsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadDatasetReqApplicationJSONInputsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UploadDatasetReqApplicationJSONMetadataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UploadDatasetReqApplicationJSONMetadataItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUploadDatasetReqApplicationJSONMetadataItem = [0]string{}

// Decode decodes UploadDatasetReqApplicationJSONMetadataItem from json.
func (s *UploadDatasetReqApplicationJSONMetadataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadDatasetReqApplicationJSONMetadataItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UploadDatasetReqApplicationJSONMetadataItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadDatasetReqApplicationJSONMetadataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadDatasetReqApplicationJSONMetadataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UploadDatasetReqApplicationJSONOutputsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UploadDatasetReqApplicationJSONOutputsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUploadDatasetReqApplicationJSONOutputsItem = [0]string{}

// Decode decodes UploadDatasetReqApplicationJSONOutputsItem from json.
func (s *UploadDatasetReqApplicationJSONOutputsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadDatasetReqApplicationJSONOutputsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UploadDatasetReqApplicationJSONOutputsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadDatasetReqApplicationJSONOutputsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadDatasetReqApplicationJSONOutputsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadDatasetReqApplicationJSONSplitsItem as json.
func (s UploadDatasetReqApplicationJSONSplitsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringUploadDatasetReqApplicationJSONSplitsItem:
		e.Str(s.String)
	case StringArrayUploadDatasetReqApplicationJSONSplitsItem:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes UploadDatasetReqApplicationJSONSplitsItem from json.
func (s *UploadDatasetReqApplicationJSONSplitsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadDatasetReqApplicationJSONSplitsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayUploadDatasetReqApplicationJSONSplitsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringUploadDatasetReqApplicationJSONSplitsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UploadDatasetReqApplicationJSONSplitsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadDatasetReqApplicationJSONSplitsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UploadDatasetResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UploadDatasetResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfUploadDatasetResponseBody = [1]string{
	0: "data",
}

// Decode decodes UploadDatasetResponseBody from json.
func (s *UploadDatasetResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadDatasetResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UploadDatasetResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUploadDatasetResponseBody) {
					name = jsonFieldsNameOfUploadDatasetResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadDatasetResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadDatasetResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpsertExperimentEvaluationRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpsertExperimentEvaluationRequestBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("annotator_kind")
		s.AnnotatorKind.Encode(e)
	}
	{
		e.FieldStart("end_time")
		json.EncodeDateTime(e, s.EndTime)
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		e.FieldStart("experiment_run_id")
		e.Str(s.ExperimentRunID)
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.TraceID.Set {
			e.FieldStart("trace_id")
			s.TraceID.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpsertExperimentEvaluationRequestBody = [9]string{
	0: "annotator_kind",
	1: "end_time",
	2: "error",
	3: "experiment_run_id",
	4: "metadata",
	5: "name",
	6: "result",
	7: "start_time",
	8: "trace_id",
}

// Decode decodes UpsertExperimentEvaluationRequestBody from json.
func (s *UpsertExperimentEvaluationRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertExperimentEvaluationRequestBody to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotator_kind":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AnnotatorKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotator_kind\"")
			}
		case "end_time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.EndTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "experiment_run_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ExperimentRunID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_run_id\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "trace_id":
			if err := func() error {
				s.TraceID.Reset()
				if err := s.TraceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpsertExperimentEvaluationRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10101011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpsertExperimentEvaluationRequestBody) {
					name = jsonFieldsNameOfUpsertExperimentEvaluationRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertExperimentEvaluationRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertExperimentEvaluationRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertExperimentEvaluationRequestBodyAnnotatorKind as json.
func (s UpsertExperimentEvaluationRequestBodyAnnotatorKind) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpsertExperimentEvaluationRequestBodyAnnotatorKind from json.
func (s *UpsertExperimentEvaluationRequestBodyAnnotatorKind) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertExperimentEvaluationRequestBodyAnnotatorKind to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpsertExperimentEvaluationRequestBodyAnnotatorKind(v) {
	case UpsertExperimentEvaluationRequestBodyAnnotatorKindLLM:
		*s = UpsertExperimentEvaluationRequestBodyAnnotatorKindLLM
	case UpsertExperimentEvaluationRequestBodyAnnotatorKindCODE:
		*s = UpsertExperimentEvaluationRequestBodyAnnotatorKindCODE
	case UpsertExperimentEvaluationRequestBodyAnnotatorKindHUMAN:
		*s = UpsertExperimentEvaluationRequestBodyAnnotatorKindHUMAN
	default:
		*s = UpsertExperimentEvaluationRequestBodyAnnotatorKind(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpsertExperimentEvaluationRequestBodyAnnotatorKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertExperimentEvaluationRequestBodyAnnotatorKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpsertExperimentEvaluationRequestBodyMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpsertExperimentEvaluationRequestBodyMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes UpsertExperimentEvaluationRequestBodyMetadata from json.
func (s *UpsertExperimentEvaluationRequestBodyMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertExperimentEvaluationRequestBodyMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpsertExperimentEvaluationRequestBodyMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpsertExperimentEvaluationRequestBodyMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertExperimentEvaluationRequestBodyMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpsertExperimentEvaluationResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpsertExperimentEvaluationResponseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfUpsertExperimentEvaluationResponseBody = [1]string{
	0: "data",
}

// Decode decodes UpsertExperimentEvaluationResponseBody from json.
func (s *UpsertExperimentEvaluationResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertExperimentEvaluationResponseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpsertExperimentEvaluationResponseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpsertExperimentEvaluationResponseBody) {
					name = jsonFieldsNameOfUpsertExperimentEvaluationResponseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertExperimentEvaluationResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertExperimentEvaluationResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpsertExperimentEvaluationResponseBodyData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpsertExperimentEvaluationResponseBodyData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfUpsertExperimentEvaluationResponseBodyData = [1]string{
	0: "id",
}

// Decode decodes UpsertExperimentEvaluationResponseBodyData from json.
func (s *UpsertExperimentEvaluationResponseBodyData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertExperimentEvaluationResponseBodyData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpsertExperimentEvaluationResponseBodyData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpsertExperimentEvaluationResponseBodyData) {
					name = jsonFieldsNameOfUpsertExperimentEvaluationResponseBodyData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertExperimentEvaluationResponseBodyData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertExperimentEvaluationResponseBodyData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("loc")
		e.ArrStart()
		for _, elem := range s.Loc {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("msg")
		e.Str(s.Msg)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfValidationError = [3]string{
	0: "loc",
	1: "msg",
	2: "type",
}

// Decode decodes ValidationError from json.
func (s *ValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "loc":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Loc = make([]ValidationErrorLocItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationErrorLocItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Loc = append(s.Loc, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loc\"")
			}
		case "msg":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Msg = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"msg\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationError) {
					name = jsonFieldsNameOfValidationError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationErrorLocItem as json.
func (s ValidationErrorLocItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringValidationErrorLocItem:
		e.Str(s.String)
	case IntValidationErrorLocItem:
		e.Int(s.Int)
	}
}

// Decode decodes ValidationErrorLocItem from json.
func (s *ValidationErrorLocItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationErrorLocItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntValidationErrorLocItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringValidationErrorLocItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
